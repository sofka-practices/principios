{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Principios de Programaci\u00f3n","text":"<p>Aprendamos todo lo relacionado a los principios de programaci\u00f3n, en este documento ser\u00e1 de gu\u00eda para que usted pueda aplicar de manera conciente los principios y fundamentos de buenas practicas de programaci\u00f3n.</p>"},{"location":"#recomendaciones","title":"Recomendaciones","text":"<ul> <li>Leer de manera conciente y participar en los debates asincronos</li> <li>Desarrollar los talleres propuestos </li> <li>Buscar por tu cuenta mas informaci\u00f3n relacionado al tema tratado</li> <li>Retroalimentaci\u00f3n del contenido expuesto</li> </ul>"},{"location":"#fundamentos","title":"Fundamentos","text":"<p>Los principios de programaci\u00f3n son un conjunto de pautas y pr\u00e1cticas que se utilizan para escribir c\u00f3digo limpio, mantenible y eficiente. Estos principios ayudan a los programadores a crear software de alta calidad que sea f\u00e1cil de leer, modificar y extender.</p> <p>La base de la mayoria de los principios son fundamentados con base a:</p> <ul> <li> <p>La simplicidad: El c\u00f3digo debe ser simple y f\u00e1cil de entender. Esto hace que sea m\u00e1s f\u00e1cil de mantener y reducir errores.</p> </li> <li> <p>La modularidad: El c\u00f3digo debe ser dividido en m\u00f3dulos l\u00f3gicos que realicen una sola tarea. Esto hace que sea m\u00e1s f\u00e1cil de entender y modificar.</p> </li> <li> <p>La reutilizaci\u00f3n: El c\u00f3digo debe ser dise\u00f1ado para ser reutilizado en diferentes partes del programa. Esto ahorra tiempo y reduce la posibilidad de errores.</p> </li> <li> <p>La legibilidad: El c\u00f3digo debe ser f\u00e1cil de leer y entender para otros programadores. Esto hace que sea m\u00e1s f\u00e1cil de mantener y mejorar.</p> </li> <li> <p>La eficiencia: El c\u00f3digo debe ser escrito de tal manera que sea r\u00e1pido y eficiente. Esto mejora el rendimiento del programa y reduce el tiempo de ejecuci\u00f3n.</p> </li> <li> <p>La consistencia: El c\u00f3digo debe seguir un estilo de codificaci\u00f3n consistente en todo el programa. Esto hace que sea m\u00e1s f\u00e1cil de leer y entender.</p> </li> <li> <p>La escalabilidad: El c\u00f3digo debe ser dise\u00f1ado para que pueda manejar grandes vol\u00famenes de datos y procesamiento. Esto permite que el programa crezca y se adapte a las necesidades del usuario.</p> </li> <li> <p>La seguridad: El c\u00f3digo debe ser dise\u00f1ado para ser seguro y resistente a ataques externos. Esto evita que los datos sean robados o manipulados por hackers.</p> </li> </ul> <p>Estos son solo algunos de los principios de programaci\u00f3n m\u00e1s importantes. Los programadores experimentados siempre intentan seguir estas pr\u00e1cticas para crear software de alta calidad.</p>"},{"location":"#principios-bases-de-programacion","title":"Principios bases de programaci\u00f3n","text":"<p>Estos principios son fundamentales dentro del del enfoque de desarrollo de software, se aplica d\u00eda a d\u00eda durante la codificaci\u00f3n. Parte de nuestra cultura de desarrollo deber\u00edamos comprender estos principios.</p> <p></p>"},{"location":"#principios-de-front-end","title":"Principios de front end","text":"<p>Con estos principios nos orientados a dise\u00f1ar soluciones frontend con capacidades de mantenibilidad y usabilidad. Es fundamentar comprender estos principios antes de abordar un desarrollo web, dado que posteriormente ser\u00eda muy complejo adaptarlo o ajustarlo.</p> <p></p>"},{"location":"#principios-de-arquitectura-limpia","title":"Principios de arquitectura limpia","text":"<p>Con estos principios podemos definir arquitecturas de larga durabilidad, su enfoque es gen\u00e9rico y de uso pr\u00e1ctico. Adem\u00e1s de ser principios fundamentales son reglas que se deber\u00edan considerar de manera permanente durante todo el proceso de implementaci\u00f3n de arquitectura. </p> <p></p>"},{"location":"#principios-de-microservicios","title":"Principios de microservicios","text":"<p>Con esta serie de principios nos ayuda a implementar microserivicios con alta capacidad de adaptaci\u00f3n y cambio, gracias a estos principios el mantenimiento se hace mas facil de ejecutar. </p>"},{"location":"#principios-de-arquitectura-cloud","title":"Principios de arquitectura cloud","text":"<p>Estos principios son recomendados por AWS para optimizar y gestionar diferentes elementos de computo en la nube, ademas son recomendaciones para la implementaci\u00f3n de dise\u00f1os de arquitectura  desde diferetes modelo de servicios cloud. </p>"},{"location":"base/","title":"Principios de Base","text":""},{"location":"base/#porque-son-importantes","title":"\u00bfPorqu\u00e9 son importantes?","text":"<p>Los principios de desarrollo de software son importantes porque proporcionan un conjunto de directrices y pr\u00e1cticas que ayudan a los desarrolladores a crear software de alta calidad, que sea f\u00e1cil de mantener, escalable y flexible. Estos principios tambi\u00e9n ayudan a los equipos de desarrollo a trabajar de manera m\u00e1s efectiva y colaborativa, reduciendo los errores y mejorando la calidad del software. Adem\u00e1s, los principios de desarrollo de software tambi\u00e9n permiten a los desarrolladores adaptarse r\u00e1pidamente a los cambios en los requisitos y tecnolog\u00edas, lo que les permite mantenerse al d\u00eda y desarrollar software que cumpla con las necesidades de los usuarios. En resumen, los principios de desarrollo de software son importantes para garantizar la eficacia y eficiencia del proceso de desarrollo de software y para garantizar la calidad del producto final.</p>"},{"location":"clean-arch/","title":"Principios de Arquitectura Limpia","text":""},{"location":"clean-arch/#porque-son-importantes","title":"\u00bfPorqu\u00e9 son importantes?","text":"<p>Los principios de arquitectura limpia son importantes por varias razones:</p> <ol> <li> <p>Ayudan a crear software f\u00e1cil de mantener y modificar a lo largo del tiempo.</p> </li> <li> <p>Facilitan la comprensi\u00f3n del c\u00f3digo por parte de otros desarrolladores, lo que fomenta la colaboraci\u00f3n y el trabajo en equipo.</p> </li> <li> <p>Permiten la creaci\u00f3n de software escalable y extensible, lo que significa que el software puede crecer y adaptarse a medida que cambian las necesidades del negocio.</p> </li> <li> <p>Proporcionan una gu\u00eda clara para el dise\u00f1o y la organizaci\u00f3n del c\u00f3digo, lo que ayuda a evitar la creaci\u00f3n de \"spaghetti code\" o c\u00f3digo desorganizado y dif\u00edcil de entender.</p> </li> <li> <p>Fomentan la reutilizaci\u00f3n del c\u00f3digo, lo que puede ahorrar tiempo y esfuerzo en el desarrollo de nuevos proyectos.</p> </li> </ol> <p>En resumen, los principios de arquitectura limpia son importantes porque ayudan a crear software de alta calidad que es f\u00e1cil de mantener, escalar y extender a lo largo del tiempo.</p>"},{"location":"cloud/","title":"Principios de Arquitectura Cloud","text":"<p>ALos principios en la nube son importantes porque proporcionan una gu\u00eda para dise\u00f1ar y construir arquitecturas eficientes, escalables y seguras en entornos de computaci\u00f3n en la nube. Independientemente del proveedor de servicios en la nube que se elija, seguir estos principios permite aprovechar al m\u00e1ximo los beneficios de la computaci\u00f3n en la nube y superar los desaf\u00edos asociados.</p> <p>Estos principios son relevantes debido a las caracter\u00edsticas \u00fanicas de la computaci\u00f3n en la nube, como la elasticidad, la disponibilidad y la escalabilidad. Al seguir los principios en la nube, se pueden obtener los siguientes beneficios:</p> <ol> <li> <p>Eficiencia: Los principios en la nube ayudan a optimizar los recursos, maximizar el rendimiento y minimizar los costos. Al dise\u00f1ar arquitecturas eficientes, se evita el desperdicio de recursos y se aprovecha al m\u00e1ximo la capacidad de la nube.</p> </li> <li> <p>Escalabilidad: Los principios en la nube permiten dise\u00f1ar sistemas que pueden adaptarse r\u00e1pidamente a cambios en la demanda. Esto proporciona la capacidad de escalar horizontal o verticalmente seg\u00fan sea necesario, lo que garantiza un rendimiento \u00f3ptimo incluso en momentos de alta carga.</p> </li> <li> <p>Resiliencia: Al seguir los principios en la nube, se pueden construir sistemas resilientes que sean capaces de recuperarse autom\u00e1ticamente de fallas y mantener la disponibilidad del servicio. Esto se logra mediante la redundancia, la distribuci\u00f3n de cargas de trabajo y la implementaci\u00f3n de mecanismos de recuperaci\u00f3n ante desastres.</p> </li> <li> <p>Seguridad: Los principios en la nube incluyen enfoques de seguridad en capas, lo que significa que se implementan medidas de seguridad en todas las capas de la arquitectura. Esto garantiza la protecci\u00f3n de datos, aplicaciones y servicios en un entorno en la nube.</p> </li> <li> <p>Automatizaci\u00f3n: La automatizaci\u00f3n es esencial para gestionar eficientemente los recursos en la nube. Al seguir los principios en la nube, se puede implementar la automatizaci\u00f3n en todas las etapas del ciclo de vida de la infraestructura, lo que facilita la implementaci\u00f3n, gesti\u00f3n y escalado de los recursos.</p> </li> </ol> <p>En resumen, los principios en la nube son importantes porque proporcionan una gu\u00eda para aprovechar al m\u00e1ximo los beneficios de la computaci\u00f3n en la nube. Al seguir estos principios, las organizaciones pueden construir arquitecturas eficientes, escalables, seguras y resilientes, lo que les permite adaptarse r\u00e1pidamente a los cambios en la demanda, maximizar el rendimiento y minimizar los costos operativos.</p>"},{"location":"frontend/","title":"Principios de Frontend","text":""},{"location":"frontend/#porque-son-importantes","title":"\u00bfPorqu\u00e9 son importantes?","text":"<p>Los principios de frontend son importantes porque permiten desarrollar aplicaciones web con una experiencia de usuario consistente, eficiente y agradable. Un buen dise\u00f1o de frontend permite que los usuarios puedan interactuar con la aplicaci\u00f3n de manera intuitiva, reduciendo la curva de aprendizaje y mejorando la eficiencia en el uso. Adem\u00e1s, un frontend bien estructurado y organizado permite un mantenimiento m\u00e1s sencillo y escalabilidad de la aplicaci\u00f3n a medida que esta crece en complejidad y caracter\u00edsticas. En resumen, los principios de frontend ayudan a crear aplicaciones web m\u00e1s efectivas, usables y escalables.</p>"},{"location":"microservice/","title":"Principios de Microservicios","text":""},{"location":"microservice/#porque-son-importantes","title":"\u00bfPorqu\u00e9 son importantes?","text":"<p>Los principios de microservicios son importantes porque proporcionan una gu\u00eda para dise\u00f1ar y desarrollar aplicaciones escalables y resilientes utilizando una arquitectura basada en microservicios. Estos principios ayudan a garantizar que los microservicios sean independientes, f\u00e1ciles de mantener, flexibles y escalables. Adem\u00e1s, siguiendo estos principios se pueden evitar errores comunes que pueden surgir durante el desarrollo de aplicaciones basadas en microservicios, como la dependencia excesiva entre servicios y la falta de cohesi\u00f3n entre los componentes. En resumen, los principios de microservicios de Sam Newman son importantes porque ayudan a garantizar que las aplicaciones basadas en microservicios sean escalables, mantenibles y resistentes.</p>"},{"location":"base/automated_tests/","title":"Automated Tests","text":"<p>El principio de automatizaci\u00f3n de pruebas (Automated Tests Principle) se refiere a la pr\u00e1ctica de automatizar la ejecuci\u00f3n de pruebas en el proceso de desarrollo de software. La automatizaci\u00f3n de pruebas permite a los equipos de desarrollo de software verificar el funcionamiento del software de manera r\u00e1pida y eficiente, lo que a su vez ayuda a detectar y solucionar errores o defectos antes de que se libere el software al mercado.</p> <p>Algunas de las ventajas de la automatizaci\u00f3n de pruebas son:</p> <ol> <li> <p>Ahorro de tiempo: la automatizaci\u00f3n de pruebas permite a los equipos de desarrollo de software ejecutar pruebas de manera m\u00e1s r\u00e1pida y eficiente que las pruebas manuales, lo que a su vez ayuda a reducir el tiempo y los costos asociados con el proceso de desarrollo de software.</p> </li> <li> <p>Mejora de la calidad: la automatizaci\u00f3n de pruebas ayuda a detectar y solucionar errores y defectos en el software de manera m\u00e1s temprana en el proceso de desarrollo, lo que a su vez contribuye a mejorar la calidad del software.</p> </li> <li> <p>Mayor cobertura de pruebas: la automatizaci\u00f3n de pruebas permite ejecutar una gran cantidad de pruebas de manera r\u00e1pida y eficiente, lo que a su vez ayuda a aumentar la cobertura de pruebas y detectar errores o defectos en \u00e1reas del software que de otra manera podr\u00edan ser pasadas por alto en el proceso de pruebas manuales.</p> </li> </ol> <p>Sin embargo, tambi\u00e9n es importante tener en cuenta que la automatizaci\u00f3n de pruebas no es adecuada para todos los tipos de pruebas y puede ser costosa y compleja de implementar. Por lo tanto, es importante evaluar cuidadosamente qu\u00e9 pruebas se pueden automatizar y cu\u00e1les no, y asegurarse de que los beneficios de la automatizaci\u00f3n de pruebas superen los costos y esfuerzos asociados.</p>"},{"location":"base/automated_tests/#los-principios-first","title":"Los principios FIRST","text":"<p>Los principios \"FIRST\" de testing son un conjunto de principios que ayudan a los equipos de desarrollo a escribir pruebas de software efectivas. Cada letra en el acr\u00f3nimo \"FIRST\" representa un principio espec\u00edfico, que se detallan a continuaci\u00f3n:</p> <ol> <li> <p>Fast (R\u00e1pido): las pruebas deben ser r\u00e1pidas y ejecutarse en un tiempo razonable. Las pruebas lentas pueden retrasar el proceso de desarrollo y hacer que los desarrolladores eviten ejecutar pruebas con frecuencia, lo que puede afectar la calidad del software.</p> </li> <li> <p>Independent (Independiente): cada prueba debe ser independiente de las dem\u00e1s, y no debe depender del resultado de otras pruebas. Esto garantiza que cada prueba proporcione informaci\u00f3n valiosa y evita que los errores se propaguen a otras partes del sistema.</p> </li> <li> <p>Repeatable (Repetible): las pruebas deben ser repetibles y producir los mismos resultados cada vez que se ejecutan. Esto permite a los desarrolladores identificar y solucionar problemas de manera confiable.</p> </li> <li> <p>Self-validating (Autovalidable): las pruebas deben ser autovalidables, es decir, la prueba debe tener un resultado claro de \"aprobado\" o \"fallido\" sin necesidad de intervenci\u00f3n humana adicional.</p> </li> <li> <p>Timely (Oportuno): las pruebas deben escribirse y ejecutarse oportunamente en el proceso de desarrollo de software. Las pruebas deben ser parte integral del proceso de desarrollo de software y no deben agregarse al final del ciclo de desarrollo.</p> </li> </ol> <p>Los principios \"FIRST\" ayudan a los equipos de desarrollo a crear pruebas de software efectivas y confiables que ayudan a mejorar la calidad del software y garantizar su correcto funcionamiento.</p>"},{"location":"base/automated_tests/#ejemplo","title":"Ejemplo","text":"<p>A continuaci\u00f3n, un ejemplo en Java de c\u00f3mo aplicar los principios \"FIRST\" en una prueba unitaria:</p> <p>Supongamos que tenemos una clase \"Calculator\" que tiene un m\u00e9todo \"sum\" que toma dos n\u00fameros como par\u00e1metros y devuelve su suma. La siguiente ser\u00eda una prueba unitaria que sigue los principios \"FIRST\":</p> <pre><code>import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\npublic class CalculatorTest {\n@Test\npublic void testSum() {\n// Fast: la prueba debe ser r\u00e1pida\nlong startTime = System.currentTimeMillis();\n// Independent: la prueba debe ser independiente\nCalculator calculator = new Calculator();\nint result = calculator.sum(2, 3);\n// Repeatable: la prueba debe ser repetible\nassertEquals(5, result);\n// Self-validating: la prueba debe ser autovalidable\nassertTrue(result &gt;= 0);\n// Timely: la prueba debe ser oportuna\nlong endTime = System.currentTimeMillis();\nassertTrue(endTime - startTime &lt; 100); // La prueba no debe tomar m\u00e1s de 100 milisegundos\n}\n</code></pre> <p>En esta prueba, se asegura que la suma de 2 y 3 sea igual a 5 y que el resultado sea un n\u00famero positivo. Adem\u00e1s, se mide el tiempo de ejecuci\u00f3n de la prueba para garantizar que sea r\u00e1pida.</p>"},{"location":"base/automated_tests/#ejemplo-con-mocking","title":"Ejemplo con Mocking","text":"<p>Aqu\u00ed hay un ejemplo en Java de c\u00f3mo crear una prueba unitaria con mocks:</p> <p>Supongamos que tenemos una clase \"UserService\" que depende de una interfaz \"UserRepository\" para obtener informaci\u00f3n de usuario. La siguiente prueba unitaria utiliza un \"mock\" del repositorio para simular su comportamiento y probar el servicio: <pre><code>import org.junit.jupiter.api.Test;\nimport static org.mockito.Mockito.*;\npublic class UserServiceTest {\n@Test\npublic void testGetUserById() {\n// Configuramos el mock\nUserRepository mockRepository = mock(UserRepository.class);\nUser user = new User(\"1\", \"John Doe\");\nwhen(mockRepository.getUserById(\"1\")).thenReturn(user);\n// Creamos el objeto a probar y lo hacemos dependiente del mock\nUserService userService = new UserService(mockRepository);\n// Ejecutamos el m\u00e9todo y verificamos el resultado\nUser result = userService.getUserById(\"1\");\nassertEquals(user, result);\n// Verificamos que se haya llamado el m\u00e9todo del mock\nverify(mockRepository).getUserById(\"1\");\n}\n}\n</code></pre></p> <p>En esta prueba, se crea un mock de la interfaz \"UserRepository\" y se configura para que devuelva un usuario espec\u00edfico cuando se llame al m\u00e9todo \"getUserById\" con el ID correspondiente. Luego se crea un objeto \"UserService\" y se le hace depender del mock creado anteriormente. Se llama al m\u00e9todo \"getUserById\" del servicio y se verifica que devuelva el mismo usuario que el mock. Finalmente, se verifica que el m\u00e9todo \"getUserById\" del mock se haya llamado exactamente una vez. Esto nos permite probar el servicio sin tener que depender del comportamiento real del repositorio.</p>"},{"location":"base/automated_tests/#en-resumen","title":"En Resumen","text":"<p>En t\u00e9rminos generales, se pueden hacer pruebas unitarias a cualquier componente o unidad de c\u00f3digo que se pueda aislar y probar de manera independiente. A continuaci\u00f3n, algunos ejemplos comunes de componentes que se suelen someter a pruebas unitarias:</p> <ul> <li> <p>Clases: una clase que implementa una funcionalidad espec\u00edfica se puede probar con diferentes casos de prueba.</p> </li> <li> <p>M\u00e9todos: los m\u00e9todos dentro de una clase se pueden probar individualmente, probando diferentes entradas y comparando los resultados con lo que se espera.</p> </li> <li> <p>Funciones: las funciones dentro de un m\u00f3dulo se pueden probar de manera similar a los m\u00e9todos de una clase.</p> </li> <li> <p>Componentes que dependen de servicios externos: si una clase o funci\u00f3n depende de servicios externos, se puede crear un mock o un stub para simular el comportamiento de esos servicios y probar la unidad de c\u00f3digo de manera aislada.</p> </li> <li> <p>Controladores: los controladores de una aplicaci\u00f3n web se pueden probar con diferentes entradas y verificar que la respuesta sea la esperada.</p> </li> </ul> <p>En resumen, cualquier unidad de c\u00f3digo que se pueda aislar y probar de manera independiente se puede someter a pruebas unitarias.</p>"},{"location":"base/automated_tests/#consideraciones-finales","title":"Consideraciones Finales","text":"<p>Aunque la mayor\u00eda del c\u00f3digo puede ser sometido a pruebas automatizadas, hay algunas partes del c\u00f3digo que son m\u00e1s dif\u00edciles o imposibles de probar autom\u00e1ticamente, como por ejemplo:</p> <ul> <li> <p>C\u00f3digo que depende de recursos externos no controlables: si el c\u00f3digo depende de recursos que est\u00e1n fuera del control del equipo de desarrollo, como una base de datos compartida o un servicio externo que no se puede emular, puede resultar dif\u00edcil o imposible probar este c\u00f3digo autom\u00e1ticamente.</p> </li> <li> <p>C\u00f3digo que depende de la interacci\u00f3n con el usuario: si el c\u00f3digo est\u00e1 dise\u00f1ado para interactuar directamente con el usuario, como una interfaz de usuario gr\u00e1fica, puede resultar dif\u00edcil o imposible probar este c\u00f3digo autom\u00e1ticamente.</p> </li> <li> <p>C\u00f3digo que depende de factores externos no controlables: si el c\u00f3digo depende de factores externos que no se pueden controlar o emular, como la fecha o la hora actual, puede resultar dif\u00edcil o imposible probar este c\u00f3digo autom\u00e1ticamente.</p> </li> <li> <p>C\u00f3digo que no es modular o que no est\u00e1 bien dise\u00f1ado: si el c\u00f3digo es dif\u00edcil de aislar y probar de manera independiente, puede resultar dif\u00edcil o imposible crear pruebas automatizadas efectivas para ese c\u00f3digo.</p> </li> </ul> <p>Aunque estas partes del c\u00f3digo pueden ser dif\u00edciles de probar autom\u00e1ticamente, todav\u00eda es importante asegurarse de que est\u00e9n bien probadas de alguna manera. Por ejemplo, se pueden realizar pruebas manuales o pruebas exploratorias para verificar el comportamiento del c\u00f3digo que no se puede probar autom\u00e1ticamente. Adem\u00e1s, se pueden utilizar t\u00e9cnicas de refactorizaci\u00f3n de c\u00f3digo para hacer que estas partes del c\u00f3digo sean m\u00e1s modular y m\u00e1s f\u00e1ciles de probar.</p>"},{"location":"base/bounded_contexts/","title":"Bounded Contexts","text":"<p>El principio de bounded contexts, o contextos delimitados en espa\u00f1ol, es un principio de dise\u00f1o de software que se utiliza en arquitecturas de software basadas en el patr\u00f3n de dise\u00f1o Domain-Driven Design (DDD). Este principio establece que los l\u00edmites de un contexto del negocio deben ser expl\u00edcitamente definidos y que cada contexto debe ser independiente y tener un lenguaje ubicuo propio.</p> <p>En otras palabras, el principio de bounded contexts sugiere que un sistema complejo se puede dividir en m\u00faltiples contextos delimitados, cada uno de los cuales representa una parte del negocio. Cada contexto delimitado debe tener su propio modelo de datos, reglas de negocio y lenguaje espec\u00edfico que se utiliza en la comunicaci\u00f3n entre los diferentes miembros del equipo de desarrollo, los stakeholders y los usuarios del sistema.</p> <p>El principio de bounded contexts ayuda a mantener la claridad y la coherencia en el dise\u00f1o del software al separar el modelo de dominio en diferentes contextos y alentar a que cada uno de ellos tenga su propio lenguaje espec\u00edfico. Esto evita confusiones y malentendidos en el equipo de desarrollo, ya que cada contexto tiene su propio significado espec\u00edfico para los t\u00e9rminos y conceptos utilizados en el negocio.</p> <p>Por ejemplo, en una aplicaci\u00f3n de comercio electr\u00f3nico, se pueden definir dos contextos delimitados: uno para la gesti\u00f3n de pedidos y otro para la gesti\u00f3n de clientes. Cada uno de estos contextos tendr\u00eda su propio modelo de datos, sus propias reglas de negocio y su propio lenguaje espec\u00edfico. Los t\u00e9rminos utilizados en el contexto de gesti\u00f3n de pedidos, como \"estado del pedido\" o \"fecha de entrega\", pueden tener un significado diferente al contexto de gesti\u00f3n de clientes.</p> <p>Al definir contextos delimitados, se puede mantener una estructura clara y coherente en el dise\u00f1o del software, lo que hace que el sistema sea m\u00e1s f\u00e1cil de entender, mantener y escalar. Adem\u00e1s, la independencia entre los diferentes contextos permite que cada uno pueda evolucionar de manera independiente sin afectar a otros contextos, lo que hace que el sistema sea m\u00e1s flexible y adaptable.</p>"},{"location":"base/bounded_contexts/#casos-o-escenarios","title":"Casos o Escenarios","text":"<p>Tomando como ejemplo la aplicaci\u00f3n de comercio electr\u00f3nico mencionada anteriormente, podr\u00edamos definir los siguientes contextos delimitados:</p> <ol> <li> <p>Contexto de gesti\u00f3n de pedidos: Este contexto se encargar\u00eda de la gesti\u00f3n de los pedidos realizados por los clientes. En este contexto se definir\u00edan los modelos de datos para representar los pedidos y se implementar\u00edan las reglas de negocio relacionadas con la gesti\u00f3n de pedidos, como la validaci\u00f3n de datos del pedido, la actualizaci\u00f3n del estado del pedido y la generaci\u00f3n de facturas. El lenguaje espec\u00edfico de este contexto podr\u00eda incluir t\u00e9rminos como \"estado del pedido\", \"fecha de entrega\" o \"n\u00famero de seguimiento\".</p> </li> <li> <p>Contexto de gesti\u00f3n de clientes: Este contexto se encargar\u00eda de la gesti\u00f3n de los clientes de la tienda en l\u00ednea. En este contexto se definir\u00edan los modelos de datos para representar los clientes y se implementar\u00edan las reglas de negocio relacionadas con la gesti\u00f3n de clientes, como la validaci\u00f3n de datos del cliente, la gesti\u00f3n de direcciones de env\u00edo y la autenticaci\u00f3n de los clientes. El lenguaje espec\u00edfico de este contexto podr\u00eda incluir t\u00e9rminos como \"direcci\u00f3n de env\u00edo\", \"historial de compras\" o \"credenciales de acceso\".</p> </li> </ol> <p>Cada uno de estos contextos tendr\u00eda su propia l\u00f3gica de negocio, sus propios modelos de datos y su propio lenguaje espec\u00edfico. Adem\u00e1s, cada contexto tendr\u00eda su propia capa de servicios y controladores para exponer su funcionalidad a otras partes de la aplicaci\u00f3n. Esto permite que cada contexto se pueda evolucionar de manera independiente, sin afectar a otros contextos, lo que hace que el sistema sea m\u00e1s flexible y escalable.</p>"},{"location":"base/bounded_contexts/#como-se-aplicaria-este-principio","title":"\u00bfC\u00f3mo se aplicar\u00eda este principio?","text":"<pre><code>\ngraph TD\n  subgraph Contexto del Dominio\n    A[Agencia]\n    E[Empleado]\n    C[Cliente]\n    P[Paquete]\n  end\n\n  subgraph Contexto de la Log\u00edstica\n    LP[Log\u00edstica Paqueter\u00eda]\n    LS[Log\u00edstica Servicio Postal]\n    T[Transportista]\n  end\n\n  subgraph Contexto del Financiero\n    F[Facturaci\u00f3n]\n    CC[Cuentas por Cobrar]\n    CP[Cuentas por Pagar]\n  end\n\n  A -- Conoce --&gt; E\n  A -- Conoce --&gt; C\n  A -- Conoce --&gt; P\n  A --&gt; LP\n  A --&gt; LS\n  LP --&gt; T\n  LS --&gt; T\n  A --&gt; F\n  F -- Conoce --&gt; CC\n  F -- Conoce --&gt; CP\n</code></pre> <p>En este ejemplo, se pueden ver tres contextos claramente definidos: el Contexto del Dominio, el Contexto de la Log\u00edstica y el Contexto del Financiero. Cada uno tiene un conjunto de entidades relacionadas que se agrupan dentro de ese contexto. Adem\u00e1s, hay algunas conexiones entre los diferentes contextos, como que la Agencia conoce tanto a los Empleados como a los Clientes, y que el Contexto de la Log\u00edstica se comunica con la Agencia a trav\u00e9s de Transportistas. Esto ilustra c\u00f3mo diferentes contextos pueden interactuar entre s\u00ed en un sistema de software.</p>"},{"location":"base/dry/","title":"Don't repeat yourself","text":"<p>\"Don't Repeat Yourself\" (DRY) es un principio de programaci\u00f3n que promueve la idea de que cada pieza de informaci\u00f3n en un sistema debe tener una \u00fanica representaci\u00f3n, una \u00fanica fuente de verdad, para evitar la repetici\u00f3n innecesaria de c\u00f3digo.</p> <p>Este principio se aplica a diferentes niveles en el desarrollo de software, desde la arquitectura de la aplicaci\u00f3n hasta el nivel del c\u00f3digo fuente. En general, se busca evitar la duplicaci\u00f3n de c\u00f3digo o la repetici\u00f3n de l\u00f3gica en diferentes partes del sistema, ya que esto puede llevar a problemas de mantenimiento, inconsistencias y errores.</p> <p>En lugar de repetir el mismo c\u00f3digo, se busca definir una \u00fanica fuente de informaci\u00f3n que se pueda reutilizar en diferentes partes del sistema. Esto puede lograrse a trav\u00e9s de la creaci\u00f3n de funciones, clases, bibliotecas o m\u00f3dulos reutilizables, que encapsulan la l\u00f3gica y se pueden utilizar en diferentes partes del sistema.</p> <p>Por ejemplo, en lugar de repetir la misma validaci\u00f3n de entrada de usuario en diferentes partes de una aplicaci\u00f3n web, se podr\u00eda definir una funci\u00f3n de validaci\u00f3n de entrada de usuario que se pueda reutilizar en diferentes formularios de la aplicaci\u00f3n.</p> <p>El principio DRY se relaciona estrechamente con otros principios de programaci\u00f3n, como el principio de responsabilidad \u00fanica (SRP) y el principio de interfaz de usuario \u00fanica (SUI), ya que todos promueven la idea de tener una \u00fanica fuente de verdad y evitar la duplicaci\u00f3n de informaci\u00f3n. Al seguir estos principios, se puede lograr un c\u00f3digo m\u00e1s limpio, eficiente, mantenible y escalable.</p>"},{"location":"base/dry/#ejemplo","title":"Ejemplo","text":"<p>Un ejemplo concreto en Java que sigue el principio DRY podr\u00eda ser la creaci\u00f3n de una funci\u00f3n que calcule el promedio de una lista de n\u00fameros enteros. En lugar de repetir la misma l\u00f3gica de c\u00e1lculo del promedio en diferentes partes del c\u00f3digo, se podr\u00eda definir una funci\u00f3n que se pueda reutilizar en diferentes partes del sistema.</p> <p>Por ejemplo: <pre><code>public class AverageCalculator {\npublic static double calculateAverage(List&lt;Integer&gt; numbers) {\nint sum = 0;\nfor (int number : numbers) {\nsum += number;\n}\nreturn (double) sum / numbers.size();\n}\n}\n</code></pre> En este ejemplo, la funci\u00f3n calculateAverage recibe una lista de n\u00fameros enteros y calcula el promedio utilizando un bucle for. Al definir esta funci\u00f3n en una clase separada, se puede reutilizar en diferentes partes del sistema sin tener que repetir la misma l\u00f3gica de c\u00e1lculo del promedio.</p> <p>Por ejemplo, en diferentes partes del sistema se podr\u00eda utilizar la funci\u00f3n calculateAverage para calcular el promedio de calificaciones de estudiantes, el promedio de ventas diarias de una tienda o el promedio de edades de un grupo de personas, entre otros usos. En todos los casos, se estar\u00eda reutilizando la misma funci\u00f3n en lugar de duplicar la misma l\u00f3gica en diferentes partes del c\u00f3digo.</p>"},{"location":"base/dry/#programacion-funcional","title":"Programaci\u00f3n funcional","text":"<p>Este principio se ajusta muy bien a la programaci\u00f3n funcional dado los principios de la programaci\u00f3n funcional obliga a tener elementos aislados y que sea reutilizables, por ejemplo  la creaci\u00f3n de una funci\u00f3n que calcule la suma de los n\u00fameros impares en una lista de n\u00fameros enteros. En lugar de repetir la misma l\u00f3gica de filtrado y sumatoria en diferentes partes del c\u00f3digo, se podr\u00eda definir una funci\u00f3n que se pueda reutilizar en diferentes partes del sistema.</p> <p>Por ejemplo, utilizando la librer\u00eda de funciones lambda de Java, se podr\u00eda escribir el siguiente c\u00f3digo:</p> <pre><code>import java.util.Arrays;\nimport java.util.List;\npublic class SumOddNumbers {\npublic static void main(String[] args) {\nList&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\nint sum = sumOddNumbers(numbers);\nSystem.out.println(\"Sum of odd numbers: \" + sum);\n}\npublic static int sumOddNumbers(List&lt;Integer&gt; numbers) {\nreturn numbers.stream()\n.filter(n -&gt; n % 2 != 0)  // filtrar n\u00fameros impares\n.reduce(0, Integer::sum); // sumar los n\u00fameros impares filtrados\n}\n}\n</code></pre> <p>En este ejemplo, la funci\u00f3n sumOddNumbers recibe una lista de n\u00fameros enteros y utiliza la librer\u00eda de funciones lambda de Java  para filtrar los n\u00fameros impares y sumarlos. Al definir esta funci\u00f3n como una funci\u00f3n separada, se puede reutilizar en diferentes partes del sistema sin tener que repetir la misma l\u00f3gica de filtrado y sumatoria en diferentes partes del c\u00f3digo.</p> <p>Por ejemplo, se podr\u00eda utilizar la funci\u00f3n sumOddNumbers en diferentes partes del sistema para calcular la suma de los n\u00fameros impares de diferentes listas de n\u00fameros enteros. En todos los casos, se estar\u00eda reutilizando la misma funci\u00f3n en lugar de duplicar la misma l\u00f3gica en diferentes partes del c\u00f3digo.</p>"},{"location":"base/dry/#como-se-aplicaria-este-principio","title":"\u00bfC\u00f3mo se aplicar\u00eda este principio?","text":"<pre><code>classDiagram\nclass Animal {\n  -name: String\n  -age: int\n  +Animal(name: String, age: int)\n  +setName(name: String)\n  +setAge(age: int)\n  +getName(): String\n  +getAge(): int\n}\n\nclass Dog {\n  -breed: String\n  -sound: String\n  +Dog(name: String, age: int, breed: String, sound: String)\n  +setBreed(breed: String)\n  +setSound(sound: String)\n  +getBreed(): String\n  +getSound(): String\n  +makeSound()\n}\n\nclass Cat {\n  -type: String\n  -sound: String\n  +Cat(name: String, age: int, type: String, sound: String)\n  +setType(type: String)\n  +setSound(sound: String)\n  +getType(): String\n  +getSound(): String\n  +makeSound()\n}\n\nclass Main {\n  +main(args: String[])\n}\n\nAnimal &lt;|-- Dog\nAnimal &lt;|-- Cat\n</code></pre> <p>En este ejemplo, se puede observar que la clase Animal contiene propiedades comunes como name y age, que son utilizadas tanto en la clase Dog como en la clase Cat. En lugar de repetir estas propiedades en ambas clases, se utiliza la herencia para hacer que Dog y Cat hereden de la clase Animal. De esta manera, se evita repetir c\u00f3digo y se sigue el principio de DRY.</p>"},{"location":"base/encapsulation/","title":"Encapsulation","text":"<p>El principio de encapsulamiento es uno de los conceptos fundamentales de la programaci\u00f3n orientada a objetos. Se refiere a la t\u00e9cnica de ocultar los detalles internos de una clase y exponer solo una interfaz p\u00fablica bien definida para interactuar con ella.</p> <p>La encapsulaci\u00f3n permite que el c\u00f3digo sea m\u00e1s modular y m\u00e1s f\u00e1cil de mantener, ya que los cambios en la implementaci\u00f3n interna de una clase no afectar\u00e1n a otros componentes del sistema que dependen de ella. Adem\u00e1s, la encapsulaci\u00f3n promueve la seguridad y la integridad de los datos, ya que solo los m\u00e9todos de la clase que exponen la interfaz p\u00fablica pueden modificar los datos internos de la clase.</p> <p>Para implementar la encapsulaci\u00f3n, se definen los atributos y m\u00e9todos de una clase como p\u00fablicos, privados o protegidos. Los atributos privados solo son accesibles dentro de la propia clase, mientras que los atributos p\u00fablicos pueden ser accedidos desde cualquier parte del sistema. Los m\u00e9todos p\u00fablicos son aquellos que se exponen a trav\u00e9s de la interfaz p\u00fablica de la clase, mientras que los m\u00e9todos privados solo son accesibles dentro de la propia clase.</p> <p>Por ejemplo, considera una clase \"CuentaBancaria\" que tiene los atributos privados \"saldo\" y \"titular\" y los m\u00e9todos p\u00fablicos \"depositar\" y \"retirar\". La encapsulaci\u00f3n permite que los m\u00e9todos \"depositar\" y \"retirar\" actualicen el saldo de la cuenta, mientras que el atributo \"saldo\" est\u00e1 protegido de modificaciones directas desde fuera de la clase.</p> <p>En resumen, el principio de encapsulaci\u00f3n es un concepto clave de la programaci\u00f3n orientada a objetos que se refiere a la t\u00e9cnica de ocultar los detalles internos de una clase y exponer solo una interfaz p\u00fablica bien definida para interactuar con ella. La encapsulaci\u00f3n permite que el c\u00f3digo sea m\u00e1s modular, m\u00e1s f\u00e1cil de mantener y promueve la seguridad y la integridad de los datos.</p>"},{"location":"base/encapsulation/#ejemplo","title":"Ejemplo","text":"<p>Aqu\u00ed tienes un ejemplo en Java que muestra c\u00f3mo se puede implementar la encapsulaci\u00f3n en una clase Persona:</p> <pre><code>public class Persona {\nprivate String nombre;\nprivate int edad;\npublic Persona(String nombre, int edad) {\nthis.nombre = nombre;\nthis.edad = edad;\n}\npublic String getNombre() {\nreturn nombre;\n}\npublic void setNombre(String nombre) {\nthis.nombre = nombre;\n}\npublic int getEdad() {\nreturn edad;\n}\npublic void setEdad(int edad) {\nthis.edad = edad;\n}\n}\n</code></pre> <p>En este ejemplo, los atributos nombre y edad est\u00e1n definidos como privados, lo que significa que solo pueden ser accedidos desde dentro de la propia clase. En su lugar, se proporcionan m\u00e9todos p\u00fablicos getNombre, setNombre, getEdad y setEdad para acceder a los atributos.</p> <p>Estos m\u00e9todos permiten leer y escribir los valores de los atributos de la clase, pero el c\u00f3digo externo no tiene acceso directo a ellos. De esta manera, la clase Persona encapsula la informaci\u00f3n sobre el nombre y la edad de una persona, lo que significa que otros componentes del sistema solo pueden interactuar con ella a trav\u00e9s de la interfaz p\u00fablica proporcionada por los m\u00e9todos get y set.</p>"},{"location":"base/encapsulation/#encapsulacion-de-comportamiento","title":"Encapsulaci\u00f3n de comportamiento","text":"<p>La encapsulaci\u00f3n de comportamiento se refiere a la t\u00e9cnica de ocultar los detalles de implementaci\u00f3n de un comportamiento complejo detr\u00e1s de una interfaz simple y f\u00e1cil de usar. En lugar de exponer todos los detalles de implementaci\u00f3n, la encapsulaci\u00f3n de comportamiento proporciona una interfaz clara y bien definida para interactuar con el comportamiento.</p> <p>La encapsulaci\u00f3n de comportamiento se utiliza a menudo en el dise\u00f1o de patrones de software, como el patr\u00f3n de dise\u00f1o State o el patr\u00f3n de dise\u00f1o Strategy. En estos patrones, la encapsulaci\u00f3n de comportamiento se logra mediante la definici\u00f3n de una interfaz com\u00fan para diferentes implementaciones de comportamiento.</p> <p>Por ejemplo, considera un sistema de procesamiento de pagos que necesita soportar diferentes m\u00e9todos de pago, como tarjetas de cr\u00e9dito, transferencias bancarias y PayPal. En lugar de exponer todos los detalles de implementaci\u00f3n de cada m\u00e9todo de pago, se puede definir una interfaz com\u00fan MetodoPago que define los m\u00e9todos necesarios para procesar un pago:</p> <pre><code>public interface MetodoPago {\npublic void procesarPago(double cantidad);\npublic String getNombreMetodoPago();\n}\n</code></pre> <p>Luego, se pueden implementar diferentes clases que implementen la interfaz MetodoPago, cada una con su propia implementaci\u00f3n de los m\u00e9todos procesarPago y getNombreMetodoPago para soportar diferentes m\u00e9todos de pago. Estas clases pueden encapsular todos los detalles de implementaci\u00f3n de su m\u00e9todo de pago correspondiente detr\u00e1s de la interfaz com\u00fan MetodoPago.</p> <pre><code>public class TarjetaCredito implements MetodoPago {\npublic void procesarPago(double cantidad) {\n// implementaci\u00f3n de procesamiento de pago con tarjeta de cr\u00e9dito\n}\npublic String getNombreMetodoPago() {\nreturn \"Tarjeta de cr\u00e9dito\";\n}\n}\npublic class TransferenciaBancaria implements MetodoPago {\npublic void procesarPago(double cantidad) {\n// implementaci\u00f3n de procesamiento de pago con transferencia bancaria\n}\npublic String getNombreMetodoPago() {\nreturn \"Transferencia bancaria\";\n}\n}\npublic class PayPal implements MetodoPago {\npublic void procesarPago(double cantidad) {\n// implementaci\u00f3n de procesamiento de pago con PayPal\n}\npublic String getNombreMetodoPago() {\nreturn \"PayPal\";\n}\n}\n</code></pre> <p>Con la encapsulaci\u00f3n de comportamiento, el resto del sistema solo necesita interactuar con la interfaz com\u00fan MetodoPago para procesar un pago, sin preocuparse por los detalles de implementaci\u00f3n de cada m\u00e9todo de pago individual. Esto hace que el sistema sea m\u00e1s modular, m\u00e1s f\u00e1cil de mantener y m\u00e1s escalable en caso de que se agreguen nuevos m\u00e9todos de pago en el futuro.</p>"},{"location":"base/encapsulation/#como-se-aplicaria-este-principio","title":"\u00bfC\u00f3mo se aplicar\u00eda este principio?","text":"<pre><code>classDiagram\n    class Animal {\n        -name: String\n        -age: Int\n        +setName(name: String): void\n        +setAge(age: Int): void\n        +getName(): String\n        +getAge(): Int\n    }\n\n    class Dog {\n        -breed: String\n        -weight: Double\n        +setBreed(breed: String): void\n        +setWeight(weight: Double): void\n        +getBreed(): String\n        +getWeight(): Double\n    }\n\n    Animal &lt;|-- Dog\n</code></pre> <p>En este ejemplo, se tiene una clase llamada Animal que representa un animal gen\u00e9rico con atributos privados de nombre y edad, y m\u00e9todos p\u00fablicos para establecer y obtener esos atributos. Luego, se tiene otra clase llamada Dog que hereda de la clase Animal y agrega atributos privados de raza y peso, as\u00ed como m\u00e9todos p\u00fablicos para establecer y obtener esos atributos espec\u00edficos de un perro.</p> <p>Dog es una subclase de Animal, lo que significa que Dog hereda los atributos y m\u00e9todos de Animal, pero tambi\u00e9n puede tener sus propios atributos y m\u00e9todos \u00fanicos.</p> <p>Este ejemplo ilustra el principio de encapsulaci\u00f3n, que es la idea de que los detalles internos de una clase (como los atributos y m\u00e9todos privados) deben estar ocultos al mundo exterior. En este ejemplo, la clase Animal encapsula los detalles de nombre y edad, y la clase Dog encapsula los detalles de raza y peso. Esto permite que los cambios internos en una clase no afecten a otras partes del sistema que utilizan esa clase, lo que a su vez facilita el mantenimiento y la evoluci\u00f3n del sistema.</p>"},{"location":"base/kiss/","title":"Keep it simple stupid","text":"<p>El principio KISS (Keep It Simple, Stupid), en espa\u00f1ol \"mantenlo simple, est\u00fapido\", es un principio de dise\u00f1o que aboga por mantener la simplicidad en todo momento, evitando a\u00f1adir complejidad innecesaria en la implementaci\u00f3n de un sistema o soluci\u00f3n.</p> <p>La idea es que un dise\u00f1o simple es m\u00e1s f\u00e1cil de entender, depurar y mantener, lo que conduce a un c\u00f3digo m\u00e1s robusto y escalable. A menudo, las soluciones m\u00e1s simples son tambi\u00e9n las m\u00e1s eficientes, en t\u00e9rminos de recursos, tiempo y costo.</p> <p>Este principio se aplica en todo tipo de sistemas y soluciones, incluyendo software, hardware, procesos y procedimientos.</p> <p>En el desarrollo de software, el principio KISS implica utilizar el enfoque m\u00e1s simple que cumpla con los requisitos del negocio y del usuario, evitando la tentaci\u00f3n de agregar funcionalidades innecesarias o complejidades t\u00e9cnicas que puedan comprometer la calidad del c\u00f3digo y aumentar la complejidad.</p> <p>En resumen, el principio KISS es una gu\u00eda para la toma de decisiones de dise\u00f1o, que se centra en la simplicidad como clave para crear soluciones efectivas y duraderas.</p>"},{"location":"base/kiss/#ejemplo","title":"Ejemplo","text":"<p>Supongamos que queremos realizar una funci\u00f3n que calcule el promedio de una lista de n\u00fameros enteros. Podr\u00edamos implementar una funci\u00f3n simple como la siguiente:</p> <pre><code>public static double calcularPromedio(int[] numeros) {\nint suma = 0;\nfor (int i = 0; i &lt; numeros.length; i++) {\nsuma += numeros[i];\n}\nreturn (double) suma / numeros.length;\n}\n</code></pre> <p>Esta funci\u00f3n simplemente suma todos los n\u00fameros en la lista y los divide por la cantidad de elementos para obtener el promedio. Es una soluci\u00f3n simple y f\u00e1cil de entender.</p> <p>En cambio, si tratamos de implementar una soluci\u00f3n m\u00e1s compleja que utiliza una estructura de datos m\u00e1s avanzada, como por ejemplo una lista enlazada o un \u00e1rbol, estar\u00edamos violando el principio KISS ya que estar\u00edamos agregando complejidad innecesaria al problema.</p> <p>Es importante recordar que mantener las cosas simples no significa que no puedan ser eficientes o elegantes, sino que se deben buscar soluciones simples y f\u00e1ciles de entender y mantener.</p>"},{"location":"base/persistence_ignorance/","title":"Persistence ignorance","text":"<p>El principio de \"Persistence Ignorance\" o \"Ignorancia de Persistencia\" es un principio de dise\u00f1o de software que establece que los objetos del dominio no deben estar acoplados a los detalles de c\u00f3mo se almacenan en una base de datos u otro tipo de almacenamiento persistente. En otras palabras, los objetos del dominio deben ser agn\u00f3sticos en cuanto a la forma en que se guardan en la persistencia.</p> <p>Este principio tiene como objetivo mantener una separaci\u00f3n clara entre la l\u00f3gica del negocio y la l\u00f3gica de persistencia. Al separar estas dos preocupaciones, se pueden hacer cambios en la forma en que se almacena la informaci\u00f3n sin afectar la l\u00f3gica del negocio, y viceversa.</p> <p>Por ejemplo, supongamos que estamos construyendo una aplicaci\u00f3n de venta de productos en l\u00ednea. Los objetos del dominio podr\u00edan incluir clases como \"Producto\", \"Carrito de compras\", \"Usuario\", etc. Estos objetos se utilizan para representar las entidades del negocio, y deben ser independientes de c\u00f3mo se almacenan en una base de datos o en otro tipo de almacenamiento persistente.</p> <p>En lugar de hacer que los objetos del dominio tengan conocimiento directo de la l\u00f3gica de persistencia, se pueden utilizar patrones de dise\u00f1o como el patr\u00f3n \"Repository\" para manejar la l\u00f3gica de persistencia. Un objeto \"Repository\" es responsable de manejar la creaci\u00f3n, lectura, actualizaci\u00f3n y eliminaci\u00f3n de objetos del dominio en la base de datos o almacenamiento persistente. Al utilizar un objeto \"Repository\", se puede mantener una separaci\u00f3n clara entre la l\u00f3gica del negocio y la l\u00f3gica de persistencia.</p> <p>El principio de \"Persistence Ignorance\" tambi\u00e9n puede ayudar a simplificar el proceso de prueba. Al tener objetos del dominio independientes de la l\u00f3gica de persistencia, se pueden crear objetos de prueba m\u00e1s f\u00e1cilmente, sin tener que preocuparse por detalles de persistencia. Esto permite realizar pruebas m\u00e1s completas y precisas de la l\u00f3gica del negocio.</p> <p>En resumen, el principio de \"Persistence Ignorance\" es importante para mantener una separaci\u00f3n clara entre la l\u00f3gica del negocio y la l\u00f3gica de persistencia en una aplicaci\u00f3n de software. Esto puede hacer que el c\u00f3digo sea m\u00e1s f\u00e1cil de mantener, m\u00e1s f\u00e1cil de probar y m\u00e1s f\u00e1cil de modificar en el futuro.</p>"},{"location":"base/persistence_ignorance/#ejemplo","title":"Ejemplo","text":"<p>En Java, se puede aplicar el principio de \"Persistence Ignorance\" utilizando el patr\u00f3n \"Repository\". Por ejemplo, supongamos que tenemos una clase \"Producto\" que representa un producto en una aplicaci\u00f3n de venta en l\u00ednea. En lugar de tener m\u00e9todos para guardar o cargar el producto directamente en la base de datos, se puede utilizar un objeto \"Repository\" para manejar la l\u00f3gica de persistencia. Aqu\u00ed hay un ejemplo de c\u00f3mo se podr\u00eda implementar esto en Java:</p> <pre><code>public class Producto {\nprivate int id;\nprivate String nombre;\nprivate double precio;\n//... otros atributos y m\u00e9todos del producto\n//constructor, getters y setters\n//no hay m\u00e9todos de persistencia aqu\u00ed\n}\npublic interface ProductoRepository {\npublic void guardarProducto(Producto producto);\npublic void actualizarProducto(Producto producto);\npublic void borrarProducto(Producto producto);\npublic Producto buscarProductoPorId(int id);\n//... otros m\u00e9todos de repositorio\n}\npublic class ProductoRepositoryImpl implements ProductoRepository {\npublic void guardarProducto(Producto producto) {\n//L\u00f3gica para guardar el producto en la base de datos\n}\npublic void actualizarProducto(Producto producto) {\n//L\u00f3gica para actualizar el producto en la base de datos\n}\npublic void borrarProducto(Producto producto) {\n//L\u00f3gica para eliminar el producto de la base de datos\n}\npublic Producto buscarProductoPorId(int id) {\n//L\u00f3gica para buscar el producto por su ID en la base de datos\n//y crear un objeto Producto a partir de los datos recuperados\nreturn new Producto(id, nombre, precio);\n}\n//... otros m\u00e9todos de repositorio\n}\n</code></pre> <p>En este ejemplo, la clase \"Producto\" representa un objeto del dominio, que es independiente de c\u00f3mo se almacena en la base de datos. La interfaz \"ProductoRepository\" define los m\u00e9todos para manejar la l\u00f3gica de persistencia de los objetos del dominio. La implementaci\u00f3n concreta \"ProductoRepositoryImpl\" maneja la l\u00f3gica de persistencia, utilizando una base de datos o alg\u00fan otro tipo de almacenamiento persistente.</p> <p>Al separar la l\u00f3gica de persistencia de los objetos del dominio, se puede mantener una separaci\u00f3n clara entre la l\u00f3gica del negocio y la l\u00f3gica de persistencia. Esto puede hacer que el c\u00f3digo sea m\u00e1s f\u00e1cil de mantener y probar, y tambi\u00e9n puede permitir cambios en la forma en que se almacena la informaci\u00f3n sin afectar la l\u00f3gica del negocio.</p>"},{"location":"base/persistence_ignorance/#como-se-aplicaria-este-principio","title":"\u00bfC\u00f3mo se aplicar\u00eda este principio?","text":"<p><pre><code>classDiagram\nclass Customer {\n        -id: int\n        -name: String\n        -email: String\n        +Customer(id: int, name: String, email: String)\n        +getId(): int\n        +getName(): String\n        +getEmail(): String\n        +updateName(name: String)\n    }\n\nclass CustomerRepository {\n        &lt;&lt;interface&gt;&gt;\n        +save(customer: Customer)\n        +findById(id: int): Customer\n }\n\nclass CustomerService {\n        -customerRepository: CustomerRepository\n        +CustomerService(customerRepository: CustomerRepository)\n        +createCustomer(name: String, email: String): Customer\n        +getCustomerById(id: int): Customer\n}\n\nCustomer --&gt; CustomerService\nCustomerService ..&gt; CustomerRepository</code></pre> En este ejemplo, se pueden observar tres clases: Customer, CustomerRepository y CustomerService.</p> <p>La clase Customer representa un objeto de tipo cliente, con tres atributos privados (id, name y email) y cuatro m\u00e9todos p\u00fablicos (Customer, getId, getName y updateName).</p> <p>La interfaz CustomerRepository define los m\u00e9todos que deben ser implementados por cualquier clase que se encargue de persistir los datos de un cliente. En este caso, se definen dos m\u00e9todos: save y findById.</p> <p>La clase CustomerService representa una clase que utiliza tanto la clase Customer como la interfaz CustomerRepository. Esta clase tiene un atributo privado (customerRepository) que se inicializa en el constructor, y dos m\u00e9todos p\u00fablicos (createCustomer y getCustomerById) que utilizan los m\u00e9todos de la clase Customer y de la interfaz CustomerRepository para crear y obtener clientes.</p> <p>Por \u00faltimo, se pueden observar las relaciones entre las clases, donde Customer se relaciona con CustomerService mediante una flecha y CustomerService se relaciona con CustomerRepository mediante una flecha punteada.</p> <p>Este ejemplo muestra c\u00f3mo se puede aplicar el principio de Persistence Ignorance, donde la clase Customer no sabe nada acerca de c\u00f3mo se guardan sus datos, y la clase CustomerService se encarga de utilizar una implementaci\u00f3n de la interfaz CustomerRepository para persistir y obtener datos de los clientes.</p>"},{"location":"base/separation_of_concerns/","title":"Separation of concerns","text":"<p>El principio de Separaci\u00f3n de preocupaciones (SoC, por sus siglas en ingl\u00e9s) es una gu\u00eda de dise\u00f1o de software que se enfoca en separar los aspectos diferentes de un sistema en diferentes componentes para que cada uno se ocupe de una tarea espec\u00edfica y no haya mezcla de responsabilidades.</p> <p>La idea detr\u00e1s de este principio es que un sistema puede ser m\u00e1s f\u00e1cilmente mantenido, extendido y modificado si cada componente se enfoca en una \u00fanica preocupaci\u00f3n. Por ejemplo, en una aplicaci\u00f3n web, podemos separar la presentaci\u00f3n de la l\u00f3gica de negocio y la persistencia de datos. Cada una de estas preocupaciones se puede tratar de manera independiente.</p> <p>La separaci\u00f3n de preocupaciones puede mejorar la modularidad del sistema, reducir la complejidad y hacer que el c\u00f3digo sea m\u00e1s f\u00e1cil de leer y entender. Adem\u00e1s, tambi\u00e9n puede ayudar a evitar errores al hacer que el c\u00f3digo sea m\u00e1s manejable y menos propenso a bugs.</p> <p>Es importante tener en cuenta que aunque la separaci\u00f3n de preocupaciones es una pr\u00e1ctica recomendada, en algunos casos no siempre es posible o pr\u00e1ctico aplicarla completamente. En cualquier caso, se debe buscar siempre que sea posible separar las diferentes preocupaciones del sistema para lograr un dise\u00f1o m\u00e1s limpio y mantenible.</p>"},{"location":"base/separation_of_concerns/#ejemplo","title":"Ejemplo","text":"<p>El principio de Separation of Concerns (Separaci\u00f3n de Preocupaciones) consiste en separar un programa en partes o m\u00f3dulos distintos, cada uno enfocado en una tarea o preocupaci\u00f3n espec\u00edfica, para reducir la complejidad y mejorar la mantenibilidad.</p> <p>Un ejemplo en Java podr\u00eda ser la separaci\u00f3n de las preocupaciones relacionadas con la capa de presentaci\u00f3n y la capa de l\u00f3gica de negocio. En lugar de mezclar ambas en una sola clase, se pueden crear dos clases diferentes, cada una enfocada en su tarea espec\u00edfica.</p> <p>Por ejemplo, supongamos que estamos desarrollando una aplicaci\u00f3n que maneja los productos de una tienda en l\u00ednea. Podr\u00edamos tener una clase Product que representa un producto y contiene informaci\u00f3n como su nombre, precio, descripci\u00f3n, etc. Esta clase estar\u00eda enfocada en las preocupaciones relacionadas con el producto en s\u00ed.</p> <p>Adem\u00e1s, podr\u00edamos tener otra clase llamada ProductService que se encarga de la l\u00f3gica de negocio relacionada con los productos. Esta clase podr\u00eda tener m\u00e9todos como addProduct, updateProduct y deleteProduct que interact\u00faan con la capa de persistencia para agregar, actualizar o eliminar productos de la base de datos. Esta clase estar\u00eda enfocada en las preocupaciones relacionadas con la l\u00f3gica de negocio.</p> <p>Al separar estas preocupaciones en diferentes clases, podemos mantener un c\u00f3digo m\u00e1s organizado, f\u00e1cil de entender y mantener en el futuro. Adem\u00e1s, si en alg\u00fan momento necesitamos cambiar la forma en que se manejan los productos o la l\u00f3gica de negocio detr\u00e1s de ellos, podremos hacerlo de manera m\u00e1s f\u00e1cil y sin afectar otras partes de la aplicaci\u00f3n.</p>"},{"location":"base/separation_of_concerns/#como-se-aplicaria-este-principio","title":"\u00bfC\u00f3mo se aplicar\u00eda este principio?","text":"<pre><code>\ngraph TD\n    A[User Interface] --&gt;|Sends requests to| B{Controller}\n    B --&gt;|Uses| C[Service Layer]\n    C --&gt;|Uses| D[Data Access Layer]</code></pre> <p>En este ejemplo, el componente de interfaz de usuario (UI) env\u00eda solicitudes al controlador (Controller) que es responsable de procesar la l\u00f3gica del negocio y hacer uso del servicio de capa (Service Layer) para realizar cualquier tarea necesaria. La capa de servicio, a su vez, utiliza la capa de acceso a datos (Data Access Layer) para interactuar con la base de datos o cualquier otro sistema de almacenamiento.</p> <p>Este diagrama muestra c\u00f3mo se separan las diferentes responsabilidades de la aplicaci\u00f3n en capas diferentes, cada una con su propio conjunto de preocupaciones. Al mantener estas preocupaciones separadas, el c\u00f3digo se vuelve m\u00e1s modular y mantenible, lo que facilita las pruebas y la evoluci\u00f3n de la aplicaci\u00f3n con el tiempo.</p>"},{"location":"base/solid/","title":"SOLID","text":"<p>Los principios SOLID en el desarrollo de software son un conjunto de principios de dise\u00f1o orientados a objetos que buscan promover la claridad, la simplicidad y la mantenibilidad del c\u00f3digo. Estos principios fueron propuestos por Robert C. Martin y se basan en la idea de que el c\u00f3digo debe ser f\u00e1cil de entender, extender y modificar.</p> <p>A continuaci\u00f3n, se describen brevemente cada uno de los principios SOLID:</p> <ul> <li> <p>S - Principio de responsabilidad \u00fanica (Single Responsibility Principle): Cada clase o m\u00f3dulo debe tener una sola responsabilidad, es decir, una \u00fanica raz\u00f3n para cambiar. Esto ayuda a mantener el c\u00f3digo claro y organizado, y a reducir la complejidad.</p> </li> <li> <p>O - Principio de abierto/cerrado (Open/Closed Principle): Las clases o m\u00f3dulos deben estar abiertos para la extensi\u00f3n, pero cerrados para la modificaci\u00f3n. Esto significa que se deben poder agregar nuevas funcionalidades sin tener que modificar el c\u00f3digo existente.</p> </li> <li> <p>L - Principio de sustituci\u00f3n de Liskov (Liskov Substitution Principle): Las clases hijas deben poder ser sustituidas por sus clases padres sin afectar el comportamiento del programa. Esto garantiza la interoperabilidad y la reutilizaci\u00f3n del c\u00f3digo.</p> </li> <li> <p>I - Principio de segregaci\u00f3n de interfaces (Interface Segregation Principle): Los clientes de una interfaz no deben estar obligados a implementar m\u00e9todos que no utilizan. Esto promueve la modularidad y la flexibilidad del c\u00f3digo.</p> </li> <li> <p>D - Principio de inversi\u00f3n de dependencias (Dependency Inversion Principle): Los m\u00f3dulos de alto nivel no deben depender de m\u00f3dulos de bajo nivel, sino de abstracciones. Esto permite una mayor independencia de los componentes del sistema y facilita la realizaci\u00f3n de cambios.</p> </li> </ul> <p>En resumen, la aplicaci\u00f3n de los principios SOLID puede ayudar a los desarrolladores de software a crear c\u00f3digo m\u00e1s limpio, mantenible y extensible, lo que a su vez puede mejorar la calidad y eficiencia del software.</p>"},{"location":"base/solid/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p>El principio de responsabilidad \u00fanica (Single Responsibility Principle)  se refiere a que cada clase debe tener una sola responsabilidad. Un ejemplo de aplicaci\u00f3n de este principio podr\u00eda ser el siguiente:</p> <p>Supongamos que tenemos una entidad llamada Empleado que se encarga de almacenar los datos de un empleado, como su nombre, n\u00famero de identificaci\u00f3n, salario y cargo. Si aplicamos el principio de responsabilidad \u00fanica, deber\u00edamos dividir esta clase en dos clases diferentes, cada una con su propia responsabilidad. Una posible soluci\u00f3n podr\u00eda ser la siguiente:</p> <p><pre><code>public class Empleado {\nprivate String nombre;\nprivate int id;\nprivate double salario;\nprivate String cargo;\npublic Empleado(String nombre, int id, double salario, String cargo) {\nthis.nombre = nombre;\nthis.id = id;\nthis.salario = salario;\nthis.cargo = cargo;\n}\npublic String getNombre() {\nreturn nombre;\n}\npublic int getId() {\nreturn id;\n}\npublic double getSalario() {\nreturn salario;\n}\npublic String getCargo() {\nreturn cargo;\n}\n}\n</code></pre> <pre><code>public class EmpleadoDAO {\npublic void guardarEmpleado(Empleado empleado) {\n// L\u00f3gica para guardar el empleado en la base de datos\n}\npublic void actualizarEmpleado(Empleado empleado) {\n// L\u00f3gica para actualizar los datos del empleado en la base de datos\n}\npublic void eliminarEmpleado(Empleado empleado) {\n// L\u00f3gica para eliminar el empleado de la base de datos\n}\n}\n</code></pre></p> <p>En este ejemplo, la clase Empleado se encarga \u00fanicamente de almacenar los datos de un empleado y proporciona m\u00e9todos para acceder a ellos. La clase EmpleadoDAO, por otro lado, se encarga de interactuar con la base de datos para guardar, actualizar y eliminar los datos de un empleado. De esta manera, cada clase tiene su propia responsabilidad y se cumple el principio de responsabilidad \u00fanica.</p>"},{"location":"base/solid/#openclosed-principle","title":"Open/Closed Principle","text":"<p>El principio de abierto/cerrado (Open/Closed Principle)  se refiere a que las clases o m\u00f3dulos deben estar abiertos para la extensi\u00f3n, pero cerrados para la modificaci\u00f3n. Un ejemplo de aplicaci\u00f3n de este principio podr\u00eda ser el siguiente:</p> <p>Supongamos que tenemos una clase llamada Calculadora que se encarga de realizar operaciones matem\u00e1ticas b\u00e1sicas, como sumar, restar, multiplicar y dividir. Si queremos agregar una nueva operaci\u00f3n, por ejemplo, calcular la ra\u00edz cuadrada, no deber\u00edamos modificar la clase Calculadora, sino extenderla mediante una nueva clase. Una posible soluci\u00f3n podr\u00eda ser la siguiente:</p> <p><pre><code>public class Calculadora {\npublic double sumar(double a, double b) {\nreturn a + b;\n}\npublic double restar(double a, double b) {\nreturn a - b;\n}\npublic double multiplicar(double a, double b) {\nreturn a * b;\n}\npublic double dividir(double a, double b) {\nreturn a / b;\n}\n}\npublic class CalculadoraAvanzada extends Calculadora {\npublic double raizCuadrada(double a) {\nreturn Math.sqrt(a);\n}\n}\n</code></pre> En este ejemplo, la clase Calculadora se encarga de realizar las operaciones matem\u00e1ticas b\u00e1sicas. Si queremos agregar una nueva operaci\u00f3n, en este caso la ra\u00edz cuadrada, en lugar de modificar la clase Calculadora, creamos una nueva clase llamada CalculadoraAvanzada que extiende de la clase Calculadora y agrega el m\u00e9todo raizCuadrada(). De esta manera, se cumple el principio de abierto/cerrado, ya que la clase Calculadora est\u00e1 cerrada para la modificaci\u00f3n y abierta para la extensi\u00f3n mediante la creaci\u00f3n de nuevas clases.</p>"},{"location":"base/solid/#liskov-substitution-principle","title":"Liskov Substitution Principle","text":"<p>El principio de sustituci\u00f3n de Liskov (Liskov Substitution Principle)  se refiere a que los objetos de una clase derivada deben poder ser utilizados en lugar de los objetos de la clase base sin afectar la integridad del programa. Un ejemplo de aplicaci\u00f3n de este principio podr\u00eda ser el siguiente:</p> <p>Supongamos que tenemos una clase llamada Figura que representa una figura geom\u00e9trica y tiene un m\u00e9todo para calcular su \u00e1rea:</p> <pre><code>public abstract class Figura {\npublic abstract double area();\n}\n</code></pre> <p>Ahora, creamos dos clases derivadas de Figura: Rectangulo y Triangulo:</p> <pre><code>public class Rectangulo extends Figura {\nprivate double base;\nprivate double altura;\npublic Rectangulo(double base, double altura) {\nthis.base = base;\nthis.altura = altura;\n}\n@Override\npublic double area() {\nreturn base * altura;\n}\n}\npublic class Triangulo extends Figura {\nprivate double base;\nprivate double altura;\npublic Triangulo(double base, double altura) {\nthis.base = base;\nthis.altura = altura;\n}\n@Override\npublic double area() {\nreturn (base * altura) / 2;\n}\n}\n</code></pre> <p>Ahora, si queremos calcular el \u00e1rea de una figura, podemos crear una funci\u00f3n que reciba un objeto de tipo Figura y utilice su m\u00e9todo area() para calcular su \u00e1rea:</p> <pre><code>public static void imprimirArea(Figura figura) {\nSystem.out.println(\"El \u00e1rea es: \" + figura.area());\n}\n</code></pre> <p>Esta funci\u00f3n puede recibir como argumento un objeto de la clase Rectangulo o de la clase Triangulo, ya que ambas clases son subclases de Figura y cumplen el contrato definido por la clase base.</p> <p>De esta manera, se cumple el principio de sustituci\u00f3n de Liskov, ya que los objetos de las clases derivadas (Rectangulo y Triangulo) pueden ser utilizados en lugar de los objetos de la clase base (Figura) sin afectar la integridad del programa.</p>"},{"location":"base/solid/#interface-segregation-principle","title":"Interface Segregation Principle","text":"<p>El principio de segregaci\u00f3n de interfaces (Interface Segregation Principle) se refiere a que una clase no debe implementar interfaces que no utiliza. Un ejemplo de aplicaci\u00f3n de este principio  podr\u00eda ser el siguiente:</p> <p>Supongamos que tenemos una interfaz llamada Vehiculo que define los m\u00e9todos b\u00e1sicos que debe tener cualquier veh\u00edculo:</p> <p><pre><code>public interface Vehiculo {\npublic void acelerar();\npublic void frenar();\npublic void girar();\n}\n</code></pre> Ahora, creamos una clase llamada Coche que implementa la interfaz Vehiculo: <pre><code>public class Coche implements Vehiculo {\n@Override\npublic void acelerar() {\nSystem.out.println(\"El coche est\u00e1 acelerando.\");\n}\n@Override\npublic void frenar() {\nSystem.out.println(\"El coche est\u00e1 frenando.\");\n}\n@Override\npublic void girar() {\nSystem.out.println(\"El coche est\u00e1 girando.\");\n}\n}\n</code></pre></p> <p>Sin embargo, supongamos que ahora queremos agregar la funcionalidad de encender y apagar el coche. En lugar de agregar estos m\u00e9todos a la interfaz Vehiculo, creamos una nueva interfaz llamada CocheElectrico que define los m\u00e9todos adicionales:</p> <p><pre><code>public interface CocheElectrico {\npublic void encender();\npublic void apagar();\n}\n</code></pre> Ahora, podemos crear una nueva clase llamada CocheElectricoImpl que implementa ambas interfaces:</p> <pre><code>public class CocheElectricoImpl implements Vehiculo, CocheElectrico {\n@Override\npublic void acelerar() {\nSystem.out.println(\"El coche el\u00e9ctrico est\u00e1 acelerando.\");\n}\n@Override\npublic void frenar() {\nSystem.out.println(\"El coche el\u00e9ctrico est\u00e1 frenando.\");\n}\n@Override\npublic void girar() {\nSystem.out.println(\"El coche el\u00e9ctrico est\u00e1 girando.\");\n}\n@Override\npublic void encender() {\nSystem.out.println(\"El coche el\u00e9ctrico est\u00e1 encendido.\");\n}\n@Override\npublic void apagar() {\nSystem.out.println(\"El coche el\u00e9ctrico est\u00e1 apagado.\");\n}\n}\n</code></pre> <p>De esta manera, se cumple el principio de segregaci\u00f3n de interfaces, ya que la clase CocheElectricoImpl implementa s\u00f3lo los m\u00e9todos que necesita y no implementa los m\u00e9todos que no utiliza de la interfaz Vehiculo.</p>"},{"location":"base/solid/#dependency-inversion-principle","title":"Dependency Inversion Principle","text":"<p>El principio de inversi\u00f3n de dependencia (Dependency Inversion Principle)  se refiere a que los m\u00f3dulos de un programa deben depender de abstracciones en lugar de depender de implementaciones concretas. Un ejemplo de aplicaci\u00f3n de este principio  podr\u00eda ser el siguiente:</p> <p>Supongamos que tenemos una clase llamada Impresora que tiene un m\u00e9todo para imprimir un documento:</p> <pre><code>public class Impresora {\npublic void imprimir(Documento documento) {\nSystem.out.println(\"Imprimiendo documento: \" + documento.getContenido());\n}\n}\n</code></pre> <p>Ahora, creamos una clase llamada Documento que representa un documento y tiene un m\u00e9todo para obtener su contenido:</p> <pre><code>public class Documento {\nprivate String contenido;\npublic Documento(String contenido) {\nthis.contenido = contenido;\n}\npublic String getContenido() {\nreturn contenido;\n}\n}\n</code></pre> <p>Sin embargo, supongamos que ahora queremos agregar la funcionalidad de enviar el documento por correo electr\u00f3nico. En lugar de modificar la clase Impresora, creamos una interfaz llamada DispositivoSalida que define un m\u00e9todo para enviar el documento a un dispositivo de salida:</p> <pre><code>public interface DispositivoSalida {\npublic void enviarDocumento(Documento documento);\n}\n</code></pre> <p>Ahora, creamos dos nuevas clases que implementan esta interfaz: ImpresoraImpl y CorreoElectronicoImpl.</p> <pre><code>public class ImpresoraImpl implements DispositivoSalida {\n@Override\npublic void enviarDocumento(Documento documento) {\nImpresora impresora = new Impresora();\nimpresora.imprimir(documento);\n}\n}\npublic class CorreoElectronicoImpl implements DispositivoSalida {\n@Override\npublic void enviarDocumento(Documento documento) {\nSystem.out.println(\"Enviando correo electr\u00f3nico con documento: \" + documento.getContenido());\n}\n}\n</code></pre> <p>Por \u00faltimo, modificamos la clase Documento para que reciba como argumento un objeto de tipo DispositivoSalida en lugar de un objeto de tipo Impresora:</p> <pre><code>public class Documento {\nprivate String contenido;\npublic Documento(String contenido) {\nthis.contenido = contenido;\n}\npublic void enviar(DispositivoSalida dispositivoSalida) {\ndispositivoSalida.enviarDocumento(this);\n}\npublic String getContenido() {\nreturn contenido;\n}\n}\n</code></pre> <p>Ahora, podemos crear un objeto de tipo Documento y enviarlo a una impresora o por correo electr\u00f3nico utilizando el m\u00e9todo enviar():</p> <pre><code>Documento documento = new Documento(\"Este es el contenido del documento.\");\nDispositivoSalida dispositivoSalida = new CorreoElectronicoImpl();\ndocumento.enviar(dispositivoSalida);\n</code></pre> <p>De esta manera, se cumple el principio de inversi\u00f3n de dependencia, ya que la clase Documento depende de la abstracci\u00f3n DispositivoSalida en lugar de depender de una implementaci\u00f3n concreta como la clase Impresora.</p>"},{"location":"base/solid/#como-se-aplicaria-este-principio","title":"\u00bfC\u00f3mo se aplicar\u00eda este principio?","text":"<pre><code>classDiagram\n    class Shape {\n        +int x\n        +int y\n        +double area()\n    }\n    class Rectangle {\n        +int width\n        +int height\n        +double area()\n    }\n    class Circle {\n        +int radius\n        +double area()\n    }\n    class ShapeAreaCalculator {\n        +double calculateArea(Shape shape)\n    }\n    Shape &lt;|-- Rectangle\n    Shape &lt;|-- Circle\n    ShapeAreaCalculator ..&gt; Shape</code></pre> <p>En este ejemplo se observa la aplicaci\u00f3n de los principios de Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation y Dependency Inversion, que conforman el acr\u00f3nimo SOLID.</p> <ul> <li>Single Responsibility: Cada clase (Shape, Rectangle y Circle) tiene una \u00fanica responsabilidad, la de calcular su propia \u00e1rea.</li> <li>Open/Closed: Las clases Shape, Rectangle y Circle est\u00e1n abiertas para su extensi\u00f3n (por ejemplo, para agregar nuevas formas), pero cerradas para su modificaci\u00f3n.</li> <li>Liskov Substitution: La clase Rectangle y Circle son subtipos de Shape y pueden ser utilizados en lugar de Shape sin alterar el comportamiento de la clase ShapeAreaCalculator.</li> <li>Interface Segregation: La clase ShapeAreaCalculator s\u00f3lo depende de la interfaz Shape, que contiene los m\u00e9todos necesarios para calcular el \u00e1rea de cualquier forma.</li> <li>Dependency Inversion: La clase ShapeAreaCalculator depende de la abstracci\u00f3n Shape en lugar de las clases concretas Rectangle y Circle.</li> </ul>"},{"location":"base/workshop/","title":"Taller de principios de programaci\u00f3n","text":""},{"location":"base/workshop/#ejercicio-1-aplicar-el-principio-de-single-responsibility","title":"Ejercicio 1 - Aplicar el principio de Single Responsibility","text":"<p>Refactoriza el siguiente c\u00f3digo para aplicar el principio de Single Responsibility:</p> <pre><code>public class Invoice {\nprivate double subtotal;\nprivate double tax;\nprivate double total;\npublic Invoice(double subtotal, double tax) {\nthis.subtotal = subtotal;\nthis.tax = tax;\nthis.total = subtotal + tax;\n}\npublic void print() {\nSystem.out.println(\"Subtotal: \" + subtotal);\nSystem.out.println(\"Tax: \" + tax);\nSystem.out.println(\"Total: \" + total);\n}\n}\n</code></pre>"},{"location":"base/workshop/#ejercicio-2-aplicar-el-principio-de-openclosed","title":"Ejercicio 2 - Aplicar el principio de Open/Closed","text":"<p>Refactoriza el siguiente c\u00f3digo para aplicar el principio de Open/Closed:</p> <pre><code>public class Vehicle {\nprivate String type;\npublic void start() {\nif (type.equals(\"car\")) {\nSystem.out.println(\"Starting car...\");\n} else if (type.equals(\"motorcycle\")) {\nSystem.out.println(\"Starting motorcycle...\");\n}\n}\n}\n</code></pre>"},{"location":"base/workshop/#ejercicio-3-aplicar-el-principio-de-liskov-substitution","title":"Ejercicio 3 - Aplicar el principio de Liskov Substitution","text":"<p>Refactoriza el siguiente c\u00f3digo para aplicar el principio de Liskov Substitution:</p> <pre><code>public interface Shape {\npublic double calculateArea();\n}\npublic class Rectangle implements Shape {\nprivate double width;\nprivate double height;\npublic Rectangle(double width, double height) {\nthis.width = width;\nthis.height = height;\n}\npublic double calculateArea() {\nreturn width * height;\n}\n}\npublic class Square implements Shape {\nprivate double side;\npublic Square(double side) {\nthis.side = side;\n}\npublic double calculateArea() {\nreturn side * side;\n}\n}\n</code></pre>"},{"location":"base/workshop/#ejercicio-4-aplicar-el-principio-de-interface-segregation","title":"Ejercicio 4 - Aplicar el principio de Interface Segregation","text":"<p>Refactoriza el siguiente c\u00f3digo para aplicar el principio de Interface Segregation:</p> <pre><code>public interface IShape {\npublic void draw();\npublic void resize();\n}\npublic class Circle implements IShape {\npublic void draw() {\nSystem.out.println(\"Drawing circle...\");\n}\npublic void resize() {\nSystem.out.println(\"Resizing circle...\");\n}\n}\npublic class Square implements IShape {\npublic void draw() {\nSystem.out.println(\"Drawing square...\");\n}\npublic void resize() {\nSystem.out.println(\"Resizing square...\");\n}\n}\n</code></pre>"},{"location":"base/workshop/#ejercicio-5-aplicar-el-principio-de-dependency-inversion","title":"Ejercicio 5 - Aplicar el principio de Dependency Inversion","text":"<p>Refactoriza el siguiente c\u00f3digo para aplicar el principio de Dependency Inversion:</p> <pre><code>public class UserService {\nprivate UserDao userDao;\npublic UserService() {\nuserDao = new UserDao();\n}\npublic void saveUser(User user) {\nuserDao.save(user);\n}\n}\npublic class UserDao {\npublic void save(User user) {\n// code to save user to database\n}\n}\n</code></pre>"},{"location":"base/workshop/#taller-programacion-orientada-a-principios-con-conceptos-bancarios","title":"Taller: Programaci\u00f3n orientada a principios con conceptos bancarios","text":""},{"location":"base/workshop/#objetivo","title":"Objetivo","text":"<p>Aplicar los principios de programaci\u00f3n para desarrollar un sistema bancario que permita realizar transacciones y consultas de cuentas bancarias.</p>"},{"location":"base/workshop/#requisitos","title":"Requisitos","text":"<ul> <li>Conocimiento b\u00e1sico de programaci\u00f3n orientada a objetos en Java.</li> <li>Un IDE de Java instalado (Eclipse, IntelliJ, NetBeans, entre otros).</li> <li>Conexi\u00f3n a internet.</li> </ul>"},{"location":"base/workshop/#pasos","title":"Pasos","text":"<ol> <li> <p>Definici\u00f3n de clases: En primer lugar, se deben definir las clases necesarias para el sistema bancario. Se sugiere una clase CuentaBancaria que contenga los atributos numeroCuenta, saldo y titular, y los m\u00e9todos depositar(), retirar() y consultarSaldo(). Tambi\u00e9n se pueden crear clases adicionales como Banco y Transaccion para facilitar el manejo del sistema.</p> </li> <li> <p>Aplicaci\u00f3n del principio de responsabilidad \u00fanica: Revisar la implementaci\u00f3n de las clases y asegurarse de que cada una tenga una \u00fanica responsabilidad. Por ejemplo, la clase CuentaBancaria debe ser responsable \u00fanicamente de la gesti\u00f3n de la cuenta bancaria.</p> </li> <li> <p>Aplicaci\u00f3n del principio de abierto/cerrado: Implementar un nuevo tipo de cuenta bancaria que permita acumular intereses sin tener que modificar la clase CuentaBancaria existente. Para ello, se puede crear una nueva clase CuentaAhorro que extienda de CuentaBancaria y agregue el atributo tasaInteres.</p> </li> <li> <p>Aplicaci\u00f3n del principio de sustituci\u00f3n de Liskov: Revisar la implementaci\u00f3n de las clases y asegurarse de que las clases derivadas (CuentaAhorro) se puedan utilizar como las clases base (CuentaBancaria) sin afectar el comportamiento del sistema.</p> </li> <li> <p>Aplicaci\u00f3n del principio de segregaci\u00f3n de interfaz: Revisar las interfaces de las clases y asegurarse de que sean cohesivas y s\u00f3lo contengan los m\u00e9todos necesarios para su responsabilidad. Por ejemplo, la interfaz de la clase CuentaAhorro s\u00f3lo deber\u00eda contener los m\u00e9todos necesarios para la gesti\u00f3n de una cuenta de ahorro.</p> </li> <li> <p>Aplicaci\u00f3n del principio de inversi\u00f3n de dependencia: Utilizar interfaces para reducir la dependencia entre las clases. Por ejemplo, en lugar de depender directamente de la clase CuentaBancaria, la clase Banco puede depender de una interfaz Cuenta para la gesti\u00f3n de cuentas bancarias.</p> </li> </ol>"},{"location":"base/workshop/#conclusiones","title":"Conclusiones","text":"<p>Este taller permiti\u00f3 aplicar los principios de programaci\u00f3n orientada a objetos en un caso de uso real como es un sistema bancario. Es importante recordar que la aplicaci\u00f3n correcta de estos principios permite obtener un c\u00f3digo m\u00e1s limpio, mantenible y escalable.</p>"},{"location":"base/workshop/#preguntas-de-repaso","title":"Preguntas de Repaso","text":"<ol> <li>\u00bfCu\u00e1les son los principios SOLID? \u00bfPuedes describir brevemente cada uno?</li> <li>\u00bfQu\u00e9 es el principio de Responsabilidad \u00danica (SRP)? \u00bfPor qu\u00e9 es importante?</li> <li>\u00bfQu\u00e9 es el principio de Abierto/Cerrado (OCP)? \u00bfPuedes dar un ejemplo?</li> <li>\u00bfQu\u00e9 es el principio de Sustituci\u00f3n de Liskov (LSP)? \u00bfPor qu\u00e9 es importante?</li> <li>\u00bfQu\u00e9 es el principio de Segregaci\u00f3n de Interfaces (ISP)? \u00bfPuedes dar un ejemplo?</li> <li>\u00bfQu\u00e9 es el principio de Inversi\u00f3n de Dependencia (DIP)? \u00bfPor qu\u00e9 es importante?</li> <li>\u00bfQu\u00e9 es el principio de Encapsulamiento? \u00bfPuedes dar un ejemplo en Java?</li> <li>\u00bfQu\u00e9 es el principio de Separaci\u00f3n de Preocupaciones (SoC)? \u00bfPor qu\u00e9 es importante?</li> <li>\u00bfQu\u00e9 es el principio de KISS? \u00bfPuedes dar un ejemplo en Java?</li> <li>\u00bfQu\u00e9 es el principio YAGNI? \u00bfPuedes dar un ejemplo en Java?</li> <li>\u00bfQu\u00e9 es el principio de DRY? \u00bfPor qu\u00e9 es importante?</li> <li>\u00bfQu\u00e9 es el principio de Bounded Contexts? \u00bfPuedes dar un ejemplo?</li> <li>\u00bfQu\u00e9 es el principio de Persistence Ignorance? \u00bfPuedes dar un ejemplo en Java?</li> <li>\u00bfCu\u00e1l es la relaci\u00f3n entre los principios de programaci\u00f3n y la calidad del software?</li> <li>\u00bfPor qu\u00e9 es importante seguir los principios de programaci\u00f3n en el desarrollo de software?</li> </ol>"},{"location":"base/yagni/","title":"You aren't gonna need it","text":"<p>El principio YAGNI (You Ain't Gonna Need It) es un principio de desarrollo de software que se refiere a la idea de que no se debe agregar funcionalidad que no se necesita actualmente en el c\u00f3digo. En otras palabras, no se deben agregar caracter\u00edsticas o funcionalidades en el c\u00f3digo que no son necesarias para resolver el problema actual, sino que se deben agregar solo cuando sean necesarias en el futuro.</p> <p>Este principio es importante porque puede ayudar a evitar la sobreingenier\u00eda, el c\u00f3digo innecesariamente complejo y la duplicaci\u00f3n de c\u00f3digo. Si se agrega una funcionalidad que no se necesita actualmente, esto puede aumentar la complejidad del c\u00f3digo y hacer que sea m\u00e1s dif\u00edcil de entender y mantener. Adem\u00e1s, si se agrega una funcionalidad que nunca se utiliza, esto es un desperdicio de tiempo y recursos.</p> <p>En resumen, el principio YAGNI sugiere que se debe escribir c\u00f3digo para resolver los problemas actuales y no agregar funcionalidades innecesarias que puedan complicar el c\u00f3digo o crear problemas en el futuro.</p>"},{"location":"base/yagni/#en-resumen","title":"En Resumen","text":"<p>El principio YAGNI (You Ain't Gonna Need It) se aplica  al evitar agregar funcionalidades o caracter\u00edsticas en el c\u00f3digo que no son necesarias en el momento actual, sino que se piensan que podr\u00edan ser \u00fatiles en el futuro. Es decir, se debe evitar agregar c\u00f3digo innecesario o complejidad en el dise\u00f1o de la aplicaci\u00f3n, enfoc\u00e1ndose solamente en las funcionalidades actuales.</p> <p>Para aplicar este principio en Java, se recomienda seguir los siguientes pasos:</p> <ol> <li> <p>Enfocarse en implementar las funcionalidades requeridas por el usuario actualmente.</p> </li> <li> <p>No agregar funcionalidades que no se necesitan en el momento actual.</p> </li> <li> <p>Evitar agregar c\u00f3digo redundante o complejo en el dise\u00f1o de la aplicaci\u00f3n.</p> </li> <li> <p>En caso de necesitar agregar nuevas funcionalidades, asegurarse de que son realmente necesarias y que no se est\u00e1n agregando solamente por especulaci\u00f3n o suposiciones.</p> </li> <li> <p>Enfocarse en mantener un dise\u00f1o simple y f\u00e1cil de mantener en el tiempo.</p> </li> </ol> <p>Por ejemplo, en lugar de agregar m\u00e9todos o clases que no se est\u00e1n utilizando actualmente, es mejor esperar a que realmente se necesiten para agregarlos al c\u00f3digo. Adem\u00e1s, se debe evitar agregar complejidad al dise\u00f1o de la aplicaci\u00f3n, como agregar m\u00faltiples capas de abstracci\u00f3n o patrones de dise\u00f1o innecesarios, que solo aumentar\u00e1n la complejidad del c\u00f3digo y har\u00e1n m\u00e1s dif\u00edcil su mantenimiento en el futuro.</p>"},{"location":"base/yagni/#ejemplo","title":"Ejemplo","text":"<p>Supongamos que estamos desarrollando una aplicaci\u00f3n de tienda en l\u00ednea y necesitamos implementar la funcionalidad de enviar un correo electr\u00f3nico al cliente cuando se haya realizado una compra. Sin embargo, sabemos que en el futuro se podr\u00edan agregar otras funcionalidades de notificaci\u00f3n como notificaciones push, mensajes de texto, etc.</p> <p>Seg\u00fan el principio YAGNI, no debemos implementar estas funcionalidades adicionales desde el principio si no se necesitan en este momento, ya que esto agregar\u00e1 complejidad innecesaria a nuestro c\u00f3digo y lo har\u00e1 m\u00e1s dif\u00edcil de mantener.</p> <p>Entonces, en lugar de crear una clase para enviar notificaciones que incluya todos los m\u00e9todos para enviar correos electr\u00f3nicos, notificaciones push, mensajes de texto, etc., podr\u00edamos comenzar por crear una clase simple para enviar correos electr\u00f3nicos. Algo como esto:</p> <pre><code>public class EmailNotificationService {\npublic void sendEmail(String recipient, String subject, String body) {\n// c\u00f3digo para enviar correo electr\u00f3nico\n}\n}\n</code></pre> <p>Con esta clase simple, podemos enviar correos electr\u00f3nicos a los clientes cuando se realiza una compra en la tienda en l\u00ednea. Si en el futuro se necesitan otras funcionalidades de notificaci\u00f3n, podemos agregarlas en ese momento, sin tener que preocuparnos por el c\u00f3digo innecesario que hab\u00edamos creado anteriormente.</p> <p>En resumen, el principio YAGNI nos indica que no debemos agregar funcionalidades a nuestro c\u00f3digo que no se necesitan actualmente, ya que esto agrega complejidad innecesaria y hace que nuestro c\u00f3digo sea m\u00e1s dif\u00edcil de mantener.</p>"},{"location":"clean_arch/acyclic_dependencies/","title":"Acyclic Dependencies","text":"<p>Este principio establece que las dependencias entre los componentes de una arquitectura deben formar un grafo ac\u00edclico dirigido (DAG).</p> <p>En otras palabras, significa que no deben haber ciclos en las dependencias entre los diferentes m\u00f3dulos o componentes de una aplicaci\u00f3n. Esto se logra a trav\u00e9s de la separaci\u00f3n adecuada de las responsabilidades y funcionalidades, para que cada componente tenga una \u00fanica responsabilidad y no dependa de otros componentes que tengan una responsabilidad diferente.</p> <p>La raz\u00f3n por la que este principio es importante es porque los ciclos en las dependencias pueden crear problemas al momento de realizar cambios en la aplicaci\u00f3n, ya que un cambio en un componente puede afectar a otros componentes que dependen de \u00e9l, lo que puede generar efectos en cascada y hacer que el proceso de mantenimiento y evoluci\u00f3n de la aplicaci\u00f3n sea m\u00e1s complejo y costoso.</p> <p>Para aplicar el principio de \"Acyclic Dependencies\" en la pr\u00e1ctica, se deben seguir ciertas pautas de dise\u00f1o, como la separaci\u00f3n de responsabilidades y la utilizaci\u00f3n de patrones de dise\u00f1o que permitan una arquitectura modular y desacoplada. Algunas t\u00e9cnicas comunes que se utilizan para lograr esto incluyen la inyecci\u00f3n de dependencias, la utilizaci\u00f3n de interfaces y la aplicaci\u00f3n de patrones como el patr\u00f3n de dise\u00f1o de fachada.</p> <p>En resumen, el principio de \"Acyclic Dependencies\" es importante porque ayuda a crear una arquitectura limpia y modular, lo que facilita el mantenimiento y evoluci\u00f3n de una aplicaci\u00f3n a largo plazo. Al seguir este principio, se pueden evitar problemas de dependencias circulares y se puede lograr una arquitectura m\u00e1s robusta y escalable.</p>"},{"location":"clean_arch/acyclic_dependencies/#recomendaciones","title":"Recomendaciones","text":"<p>El principio de \"Acyclic Dependencies\" se puede aplicar en la pr\u00e1ctica a trav\u00e9s de varias t\u00e9cnicas de dise\u00f1o y buenas pr\u00e1cticas de programaci\u00f3n, tales como:</p> <ol> <li> <p>Separaci\u00f3n de responsabilidades: cada componente o m\u00f3dulo de la aplicaci\u00f3n debe tener una \u00fanica responsabilidad claramente definida y no debe estar relacionado con otros componentes que tengan una responsabilidad diferente.</p> </li> <li> <p>Inyecci\u00f3n de dependencias: los componentes de una aplicaci\u00f3n no deben crear directamente instancias de otros componentes que requieran, sino que deben ser proporcionados por un tercero a trav\u00e9s de una inyecci\u00f3n de dependencias.</p> </li> <li> <p>Interfaces: los componentes de una aplicaci\u00f3n deben depender de interfaces y no de implementaciones concretas. Esto permite cambiar la implementaci\u00f3n subyacente sin afectar a los componentes que dependen de ella.</p> </li> <li> <p>Patr\u00f3n de dise\u00f1o de fachada: se puede utilizar el patr\u00f3n de dise\u00f1o de fachada para crear una interfaz \u00fanica y simplificada para un conjunto de componentes m\u00e1s complejos, lo que facilita su uso y reduce la dependencia directa entre componentes.</p> </li> <li> <p>Arquitectura basada en eventos: en una arquitectura basada en eventos, los componentes no interact\u00faan directamente entre s\u00ed, sino que se comunican a trav\u00e9s de eventos que son enviados y recibidos por un bus de eventos. Esto reduce la dependencia directa entre componentes y facilita la escalabilidad de la aplicaci\u00f3n.</p> </li> </ol> <p>En general, el principio de \"Acyclic Dependencies\" se puede aplicar mejor mediante la creaci\u00f3n de una arquitectura modular, escalable y desacoplada, en la que cada componente tenga una \u00fanica responsabilidad y se comunique con otros componentes a trav\u00e9s de interfaces y eventos. Esto facilita el mantenimiento y la evoluci\u00f3n de la aplicaci\u00f3n a largo plazo y permite una mayor flexibilidad para realizar cambios en la aplicaci\u00f3n sin afectar a otros componentes.</p>"},{"location":"clean_arch/acyclic_dependencies/#recomendaciones_1","title":"Recomendaciones","text":"<p>Para utilizar el principio de \"Acyclic Dependencies\" de manera efectiva en el dise\u00f1o de una arquitectura limpia, se pueden seguir algunas recomendaciones:</p> <ol> <li> <p>Utilizar una arquitectura basada en capas: Una arquitectura basada en capas permite definir un conjunto de capas que tienen una responsabilidad espec\u00edfica en la aplicaci\u00f3n y que se comunican entre s\u00ed a trav\u00e9s de interfaces. Esto permite evitar la creaci\u00f3n de ciclos de dependencias entre las capas.</p> </li> <li> <p>Definir interfaces claras: Al definir las interfaces entre las diferentes capas de la aplicaci\u00f3n, es importante asegurarse de que sean claras y coherentes. Esto permite que las capas se comuniquen de manera efectiva sin crear dependencias innecesarias.</p> </li> <li> <p>Evitar el uso de dependencias circulares: Es importante evitar crear dependencias circulares entre los diferentes m\u00f3dulos de la aplicaci\u00f3n. Esto puede generar problemas de mantenimiento y dificultar la evoluci\u00f3n de la aplicaci\u00f3n.</p> </li> <li> <p>Aplicar el principio de inversi\u00f3n de dependencias: Al utilizar el principio de inversi\u00f3n de dependencias, se puede reducir el acoplamiento entre los diferentes componentes de la aplicaci\u00f3n. En lugar de depender de componentes concretos, se deben utilizar abstracciones e interfaces que permitan una mayor flexibilidad en el dise\u00f1o de la aplicaci\u00f3n.</p> </li> <li> <p>Utilizar herramientas de an\u00e1lisis de dependencias: Existen herramientas que permiten analizar las dependencias entre los diferentes componentes de una aplicaci\u00f3n. Estas herramientas pueden ser \u00fatiles para identificar dependencias circulares y otros problemas de dise\u00f1o en la arquitectura de la aplicaci\u00f3n.</p> </li> </ol> <p>En resumen, para utilizar el principio de \"Acyclic Dependencies\" de manera efectiva en el dise\u00f1o de una arquitectura limpia, es importante seguir algunas recomendaciones, como utilizar una arquitectura basada en capas, definir interfaces claras, evitar el uso de dependencias circulares, aplicar el principio de inversi\u00f3n de dependencias y utilizar herramientas de an\u00e1lisis de dependencias. Esto puede ayudar a crear una arquitectura limpia y modular que sea f\u00e1cil de mantener y evolucionar en el tiempo.</p>"},{"location":"clean_arch/acyclic_dependencies/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Para aplicar el principio de \"Acyclic Dependencies\" en una aplicaci\u00f3n Java con Maven, se pueden seguir algunas pr\u00e1cticas de dise\u00f1o que permitan crear una arquitectura limpia y modular. Por ejemplo, se puede utilizar una arquitectura basada en capas, en la que cada capa tenga una \u00fanica responsabilidad y se comunique con otras capas a trav\u00e9s de interfaces.</p> <p>Un ejemplo simplificado de aplicaci\u00f3n Java con Maven que aplique el principio de \"Acyclic Dependencies\" podr\u00eda tener la siguiente estructura de capas:</p> <ol> <li> <p>Capa de presentaci\u00f3n: Esta capa se encarga de la interfaz de usuario y la interacci\u00f3n con el usuario. Contiene las clases de controladores y vistas.</p> </li> <li> <p>Capa de l\u00f3gica de negocio: Esta capa se encarga de la l\u00f3gica de negocio de la aplicaci\u00f3n. Contiene las clases de servicios y entidades.</p> </li> <li> <p>Capa de persistencia: Esta capa se encarga de la persistencia de los datos de la aplicaci\u00f3n. Contiene las clases de repositorios y entidades.</p> </li> </ol> <p>Cada capa depende de la capa inferior, pero no de la capa superior. Es decir, la capa de presentaci\u00f3n depende de la capa de l\u00f3gica de negocio, pero la capa de l\u00f3gica de negocio no depende de la capa de presentaci\u00f3n. Esto evita la creaci\u00f3n de ciclos de dependencias y facilita el mantenimiento y la evoluci\u00f3n de la aplicaci\u00f3n.</p> <p>A continuaci\u00f3n, se muestra un ejemplo simplificado de c\u00f3digo Java y Maven que implementa esta arquitectura: <pre><code>|-- pom.xml\n|-- src\n|   |-- main\n|       |-- java\n|           |-- com.example.presentation\n|               |-- UserController.java\n|               |-- UserView.java\n|           |-- com.example.businesslogic\n|               |-- UserService.java\n|               |-- UserEntity.java\n|           |-- com.example.persistence\n|               |-- UserRepository.java\n|               |-- UserEntity.java\n</code></pre></p> <p>En este ejemplo, la capa de presentaci\u00f3n contiene las clases UserController y UserView, la capa de l\u00f3gica de negocio contiene las clases UserService y UserEntity, y la capa de persistencia contiene las clases UserRepository y UserEntity.</p> <p>Cada capa depende de la capa inferior, pero no de la capa superior. Por ejemplo, la capa de presentaci\u00f3n depende de la capa de l\u00f3gica de negocio, pero la capa de l\u00f3gica de negocio no depende de la capa de presentaci\u00f3n. Esto evita la creaci\u00f3n de ciclos de dependencias y facilita el mantenimiento y la evoluci\u00f3n de la aplicaci\u00f3n.</p> <p>En el archivo pom.xml de Maven, se pueden definir las dependencias entre los diferentes m\u00f3dulos de la aplicaci\u00f3n. Por ejemplo, la capa de presentaci\u00f3n puede depender de la capa de l\u00f3gica de negocio y la capa de l\u00f3gica de negocio puede depender de la capa de persistencia.</p> <p>En resumen, para aplicar el principio de \"Acyclic Dependencies\" en una aplicaci\u00f3n Java con Maven, se pueden seguir algunas pr\u00e1cticas de dise\u00f1o que permitan crear una arquitectura limpia y modular, como utilizar una arquitectura basada en capas y definir las dependencias entre los diferentes m\u00f3dulos de la aplicaci\u00f3n en el archivo pom.xml de Maven. Esto facilita el mantenimiento y la evoluci\u00f3n de la aplicaci\u00f3n a largo plazo y permite una mayor flexibilidad para realizar cambios en la aplicaci\u00f3n sin afectar a otros componentes.</p>"},{"location":"clean_arch/acyclic_dependencies/#ejemplo","title":"Ejemplo","text":"<pre><code>graph TD;\n  A[Capa de presentaci\u00f3n]--&gt;B[Capa de aplicaci\u00f3n];\n  B--&gt;C[Capa de dominio];\n  C--&gt;D[Capa de infraestructura];\n  D--&gt;A;</code></pre> <p>En este ejemplo, las flechas indican la direcci\u00f3n de la dependencia entre las diferentes capas de la aplicaci\u00f3n. Se puede observar que no existen ciclos de dependencias, lo que significa que se est\u00e1 cumpliendo el principio de \"Acyclic Dependencies\" en el dise\u00f1o de la arquitectura.</p>"},{"location":"clean_arch/common_closure/","title":"Common Closere","text":"<p>El principio de Common Closure (CC) es un principio de dise\u00f1o de software que se enfoca en agrupar las clases y los m\u00f3dulos de tal forma que los que cambian juntos, permanezcan juntos. En otras palabras, este principio establece que las clases y los m\u00f3dulos que tienen una alta tasa de cambio deben estar agrupados juntos para minimizar el impacto de los cambios en otros m\u00f3dulos y reducir el acoplamiento.</p> <p>En t\u00e9rminos de la arquitectura limpia, el principio de Common Closure sugiere que los m\u00f3dulos que dependen de la misma pol\u00edtica deber\u00edan estar agrupados juntos. Por ejemplo, si un conjunto de m\u00f3dulos est\u00e1n relacionados con el manejo de la autenticaci\u00f3n de usuarios, entonces deber\u00edan estar agrupados juntos en un solo paquete o m\u00f3dulo. De esta manera, los cambios en las pol\u00edticas de autenticaci\u00f3n se limitan a ese conjunto de m\u00f3dulos y no afectan el resto de la aplicaci\u00f3n.</p> <p>Adem\u00e1s, el principio de Common Closure tambi\u00e9n puede ayudar a mejorar la calidad del software, ya que los m\u00f3dulos con alta tasa de cambio suelen ser aquellos que tienen mayor probabilidad de errores. Al agrupar estos m\u00f3dulos juntos, se facilita su mantenimiento y actualizaci\u00f3n, lo que puede mejorar la estabilidad y la calidad del software.</p> <p>En resumen, el principio de Common Closure establece que las clases y los m\u00f3dulos que cambian juntos, permanezcan juntos. Al aplicar este principio en la arquitectura limpia, se busca agrupar los m\u00f3dulos que dependen de la misma pol\u00edtica en un solo paquete o m\u00f3dulo para minimizar el impacto de los cambios y mejorar la calidad del software.</p>"},{"location":"clean_arch/common_closure/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Identificar las clases y los m\u00f3dulos que tienen una alta tasa de cambio. Esto puede incluir clases relacionadas con la gesti\u00f3n de usuarios, la seguridad, la gesti\u00f3n de errores, entre otras.</p> </li> <li> <p>Agrupar las clases y los m\u00f3dulos que cambian juntos en un mismo paquete o m\u00f3dulo. Por ejemplo, si un conjunto de clases est\u00e1n relacionadas con la gesti\u00f3n de errores, se pueden agrupar en un paquete o m\u00f3dulo dedicado a la gesti\u00f3n de errores.</p> </li> <li> <p>Definir una interfaz p\u00fablica para cada m\u00f3dulo agrupado. Esta interfaz p\u00fablica define la funcionalidad ofrecida por el m\u00f3dulo y puede ser utilizada por otros m\u00f3dulos de la aplicaci\u00f3n.</p> </li> <li> <p>Establecer las dependencias entre los m\u00f3dulos. Los m\u00f3dulos que dependen de otro m\u00f3dulo deben utilizar la interfaz p\u00fablica definida para ese m\u00f3dulo.</p> </li> <li> <p>Establecer las restricciones de acceso entre los m\u00f3dulos. Los m\u00f3dulos que no necesiten acceder a un m\u00f3dulo determinado deben tener acceso restringido a ese m\u00f3dulo para reducir el acoplamiento.</p> </li> </ol> <p>Al aplicar el principio de Common Closure en proyectos de Empesariales, se pueden obtener beneficios como una mayor modularidad, una mayor facilidad de mantenimiento, una menor tasa de errores y una mayor facilidad para realizar cambios y actualizaciones.</p>"},{"location":"clean_arch/common_closure/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Supongamos que tenemos un proyecto que consta de diferentes m\u00f3dulos, cada uno con una funcionalidad espec\u00edfica, por ejemplo:</p> <ul> <li>proyecto-app: contiene las clases principales del proyecto.</li> <li>proyecto-infra: contiene las clases relacionadas con los elementos t\u00e9cnicos adaptativos.</li> <li>proyecto-dominio: contiene las clases que implementan las entidades y casos de uso del proyecto.</li> </ul> <p>Para aplicar el principio de Common Closure, es recomendable agrupar los m\u00f3dulos que cambian juntos en un mismo paquete. En este caso, podr\u00edamos agrupar el proyecto-app y el proyecto-infra en un mismo paquete, ya que es probable que si cambiamos algo en el proyecto-app, tambi\u00e9n tengamos que modificar los dominio que lo utilizan. Adem\u00e1s, el proyecto-infra es independiente de los otros dos m\u00f3dulos, por lo que deber\u00eda estar en un paquete separado.</p> <p>Para implementar esto en Maven, podemos crear una estructura de directorios como la siguiente:</p> <p><pre><code>proyecto\n|-- proyecto-app\n|   |-- src/main/java/com/proyecto/app\n|   `-- pom.xml\n|-- proyecto-infra\n|   |-- src/main/java/com/proyecto/infra\n|   `-- pom.xml\n|-- proyecto-dominio\n|   |-- src/main/java/com/proyecto/dominio\n|   `-- pom.xml\n`-- pom.xml\n</code></pre> En cada m\u00f3dulo, debemos especificar el paquete correspondiente en el archivo pom.xml:</p> <p><pre><code>&lt;parent&gt;\n&lt;groupId&gt;com.proyecto&lt;/groupId&gt;\n&lt;artifactId&gt;proyecto&lt;/artifactId&gt;\n&lt;version&gt;1.0.0&lt;/version&gt;\n&lt;/parent&gt;\n&lt;groupId&gt;com.proyecto&lt;/groupId&gt;\n&lt;artifactId&gt;proyecto-app&lt;/artifactId&gt;\n&lt;version&gt;1.0.0&lt;/version&gt;\n&lt;packaging&gt;jar&lt;/packaging&gt;\n&lt;modules&gt;\n&lt;module&gt;proyecto-infra&lt;/module&gt;\n&lt;module&gt;proyecto-dominio&lt;/module&gt;\n&lt;/modules&gt;\n</code></pre> En este ejemplo, hemos agregado la secci\u00f3n  para indicar que este m\u00f3dulo es un subm\u00f3dulo del proyecto principal (proyecto), que deber\u00e1 tener su propio pom.xml y estar ubicado en el directorio ra\u00edz del proyecto. <p>De esta manera, podemos asegurar que los m\u00f3dulos que cambian juntos est\u00e9n agrupados en el mismo paquete y que los cambios en un m\u00f3dulo no afecten a los dem\u00e1s, lo que facilita el mantenimiento y evita posibles errores en el proyecto.</p>"},{"location":"clean_arch/common_closure/#ejemplo","title":"Ejemplo","text":"<pre><code>graph TD;\n    A[Modulo de ventas] --&gt;|Depende de| B[Modulo de inventario];\n    A --&gt;|Depende de| C[Modulo de clientes];\n    B --&gt;|Depende de| D[Modulo de compras];\n    B --&gt;|Depende de| E[Modulo de proveedores];\n    C --&gt;|Depende de| F[Modulo de facturaci\u00f3n];\n</code></pre> <p>En este ejemplo, se tiene una arquitectura de software que consta de diferentes m\u00f3dulos relacionados con ventas, inventario, clientes, compras, proveedores y facturaci\u00f3n. Se puede ver que el m\u00f3dulo de ventas depende de los m\u00f3dulos de inventario y clientes, y que estos m\u00f3dulos a su vez dependen de otros m\u00f3dulos.</p> <p>El principio de Common Closure sugiere que los m\u00f3dulos que cambian juntos deben estar encapsulados juntos. En este caso, los m\u00f3dulos relacionados con ventas, inventario y clientes pueden cambiar juntos, por lo que ser\u00eda recomendable agruparlos en un mismo m\u00f3dulo, mientras que los m\u00f3dulos de compras, proveedores y facturaci\u00f3n pueden cambiar independientemente, por lo que se recomendar\u00eda separarlos en otros m\u00f3dulos.</p> <p>De esta manera, se puede asegurar que los cambios que se realicen en los m\u00f3dulos relacionados con ventas, inventario y clientes afecten \u00fanicamente a estos m\u00f3dulos y no a los dem\u00e1s, lo que facilita el mantenimiento y evita posibles errores en el sistema.</p>"},{"location":"clean_arch/common_reuse/","title":"Common Reuse","text":"<p>El principio de Common Reuse es uno de los principios de la arquitectura limpia que se enfoca en la reutilizaci\u00f3n de c\u00f3digo. Seg\u00fan este principio, los m\u00f3dulos de un sistema deben ser dise\u00f1ados de tal manera que los componentes reutilizables se agrupen en m\u00f3dulos separados de los componentes espec\u00edficos del negocio.</p> <p>El principio de Common Reuse establece que los m\u00f3dulos de un sistema deber\u00edan ser dise\u00f1ados para que se puedan reutilizar en diferentes contextos. Esto significa que el c\u00f3digo que se escribe para un m\u00f3dulo deber\u00eda ser lo m\u00e1s general posible y no estar dise\u00f1ado espec\u00edficamente para un caso de uso o requisito en particular.</p> <p>El objetivo de este principio es fomentar la reutilizaci\u00f3n de c\u00f3digo en todo el sistema, lo que reduce la cantidad de c\u00f3digo duplicado y mejora la calidad general del sistema. Adem\u00e1s, la reutilizaci\u00f3n de c\u00f3digo tambi\u00e9n puede reducir el tiempo y los costos de desarrollo, ya que los desarrolladores pueden utilizar c\u00f3digo existente en lugar de escribirlo desde cero.</p>"},{"location":"clean_arch/common_reuse/#recomendaciones","title":"Recomendaciones","text":"<ul> <li>Identificar los componentes reutilizables del sistema y agruparlos en m\u00f3dulos separados.</li> <li>Dise\u00f1ar los m\u00f3dulos de manera que los componentes reutilizables sean lo m\u00e1s generales posible y no est\u00e9n espec\u00edficamente dise\u00f1ados para un caso de uso en particular.</li> <li>Establecer interfaces claras y bien definidas entre los m\u00f3dulos para promover la independencia y la interoperabilidad. Documentar y publicar los m\u00f3dulos reutilizables para que otros desarrolladores puedan utilizarlos f\u00e1cilmente.</li> <li>Establecer pr\u00e1cticas de control de versiones y actualizaci\u00f3n de los m\u00f3dulos para garantizar que se mantengan actualizados y sean compatibles con otras partes del sistema.</li> </ul> <p>En resumen, el principio de Common Reuse se enfoca en fomentar la reutilizaci\u00f3n de c\u00f3digo en la arquitectura de un sistema. Al seguir las pr\u00e1cticas recomendadas y dise\u00f1ar los m\u00f3dulos de manera que los componentes reutilizables sean lo m\u00e1s generales posible, se puede mejorar la calidad general del sistema, reducir los costos de desarrollo y fomentar la colaboraci\u00f3n y la interoperabilidad entre los equipos de desarrollo.</p>"},{"location":"clean_arch/common_reuse/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<ol> <li> <p>Identificar el componente com\u00fan: Ejemplo, la base de datos es el componente com\u00fan que se utilizar\u00e1 en todo el proyecto.</p> </li> <li> <p>Separar el componente com\u00fan: Se puede crear un m\u00f3dulo separado en el proyecto para manejar todas las interacciones con la base de datos. Este m\u00f3dulo puede ser un proyecto de  independiente dentro del proyecto principal.</p> </li> <li> <p>Establecer est\u00e1ndares de codificaci\u00f3n: Para establecer est\u00e1ndares de codificaci\u00f3n, ejemplo se puede utilizar un patr\u00f3n de dise\u00f1o DAO (Data Access Object) para la capa de acceso a datos. Este patr\u00f3n de dise\u00f1o establece una interfaz para el acceso a datos y proporciona una implementaci\u00f3n para cada tipo de entidad.</p> </li> <li> <p>Documentar el componente com\u00fan: Es importante documentar la estructura y el funcionamiento del m\u00f3dulo de acceso a datos, de modo que otros desarrolladores puedan comprender c\u00f3mo usarlo de manera efectiva y eficiente.</p> </li> <li> <p>Hacer pruebas de regresi\u00f3n: Es necesario hacer pruebas de regresi\u00f3n en el m\u00f3dulo de acceso a datos para asegurarse de que cualquier cambio en la interacci\u00f3n con la base de datos  no afecte negativamente a otras partes del proyecto.</p> </li> </ol>"},{"location":"clean_arch/common_reuse/#ejemplo","title":"Ejemplo","text":"<p>Supongamos que tenemos un proyecto Java que tiene que interactuar con una base de datos MySQL en diferentes partes del c\u00f3digo. En lugar de escribir el c\u00f3digo para interactuar con la base de datos en cada parte del proyecto, podemos crear un m\u00f3dulo separado que maneje todas las interacciones con la base de datos.</p> <p>El siguiente diagrama Mermaid ilustra la estructura del proyecto y c\u00f3mo se relacionan los diferentes m\u00f3dulos: <pre><code>graph TD\nA[Proyecto Maven] --&gt;|Dependencia| B[myproject-dao]\nB --&gt;|Interacciones con BD| C[MySQL Connector]</code></pre></p> <p>En este diagrama, la caja A representa el proyecto Maven principal, la caja B representa el m\u00f3dulo myproject-dao que maneja todas las interacciones con la base de datos, y la caja C representa la dependencia de MySQL Connector que se utiliza en el m\u00f3dulo myproject-dao.</p> <p>El siguiente diagrama Mermaid ilustra c\u00f3mo se utiliza el m\u00f3dulo myproject-dao en el proyecto principal:</p> <pre><code>graph TD\nA[Proyecto Maven] --&gt;|Utiliza| B[myproject-dao]\nB --&gt;|Interacciones con BD| C[MySQL Connector]</code></pre> <p>En este diagrama, la caja A representa el proyecto Maven principal, la caja B representa el m\u00f3dulo myproject-dao que maneja todas las interacciones con la base de datos, y la caja C representa la dependencia de MySQL Connector que se utiliza en el m\u00f3dulo myproject-dao.</p> <p>Al utilizar la estructura de proyecto ilustrada en estos diagramas, hemos creado un m\u00f3dulo separado que maneja todas las interacciones con la base de datos, lo que nos permite reutilizar el c\u00f3digo en diferentes partes del proyecto, mientras mantenemos una estructura clara y estandarizada para nuestro proyecto.</p>"},{"location":"clean_arch/reuse/","title":"Reuse/release Equivalence","text":"<p>El principio de Reutilizaci\u00f3n/Liberaci\u00f3n Equivalente (en ingl\u00e9s, \"Reuse/Release Equivalence Principle\") es un principio de dise\u00f1o de software que se centra en la reutilizaci\u00f3n de c\u00f3digo y la liberaci\u00f3n de recursos en igual medida. Este principio establece que cualquier recurso que se adquiera durante la ejecuci\u00f3n de un programa debe ser liberado tan pronto como ya no sea necesario, de manera que no se desperdicien recursos valiosos del sistema.</p> <p>En t\u00e9rminos pr\u00e1cticos, esto significa que los desarrolladores deben escribir c\u00f3digo de manera que los recursos que se adquieran se liberen de forma consistente y oportuna. Esto puede incluir recursos como memoria, conexiones de red, archivos abiertos y cualquier otro recurso que el programa pueda utilizar.</p> <p>Adem\u00e1s, el principio de Reutilizaci\u00f3n/Liberaci\u00f3n Equivalente tambi\u00e9n implica que los recursos que se adquieran deben ser reutilizados siempre que sea posible. Por ejemplo, en lugar de abrir una nueva conexi\u00f3n de red cada vez que se necesite enviar o recibir datos, el programa deber\u00eda reutilizar una conexi\u00f3n existente para evitar la sobrecarga y el desperdicio de recursos.</p> <p>Este principio es importante porque ayuda a mejorar el rendimiento y la eficiencia del programa, as\u00ed como a reducir los errores y los problemas relacionados con los recursos. Al seguir este principio, los desarrolladores pueden crear software m\u00e1s robusto y confiable que funcione de manera m\u00e1s efectiva y eficiente en el sistema en el que se ejecuta.</p> <p>En resumen, el principio de Reutilizaci\u00f3n/Liberaci\u00f3n Equivalente es un importante principio de dise\u00f1o de software que se centra en la reutilizaci\u00f3n de c\u00f3digo y la liberaci\u00f3n de recursos en igual medida. Siguiendo este principio, los desarrolladores pueden crear software m\u00e1s eficiente, confiable y robusto que funcione de manera efectiva en el sistema en el que se ejecuta.</p>"},{"location":"clean_arch/reuse/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Dise\u00f1o modular: En la Arquitectura Limpia, se busca crear componentes altamente cohesivos y bajo acoplamiento. Para aplicar el principio de Reuse/Release Equivalence, los componentes deben estar dise\u00f1ados para adquirir y liberar recursos de manera consistente y adecuada. Los componentes deben ser dise\u00f1ados para liberar todos los recursos que adquieren, de manera que otros componentes puedan reutilizarlos sin preocuparse por la liberaci\u00f3n de recursos.</p> </li> <li> <p>Uso de patrones de dise\u00f1o: En la Arquitectura Limpia, se utilizan patrones de dise\u00f1o para crear componentes reutilizables y modularizar el c\u00f3digo. Los patrones de dise\u00f1o pueden ayudar a aplicar el principio de Reuse/Release Equivalence al proporcionar soluciones a problemas comunes relacionados con la adquisici\u00f3n y liberaci\u00f3n de recursos.</p> </li> <li> <p>Gesti\u00f3n adecuada de recursos: La Arquitectura Limpia enfatiza la necesidad de una gesti\u00f3n adecuada de recursos, como la memoria, la CPU y la red. Los componentes deben ser dise\u00f1ados para adquirir y liberar recursos de manera oportuna y adecuada. Esto puede lograrse mediante el uso de t\u00e9cnicas de cach\u00e9, pooling y otros patrones de dise\u00f1o.</p> </li> <li> <p>Pruebas exhaustivas: Para garantizar que el principio de Reuse/Release Equivalence se aplique correctamente, se deben realizar pruebas exhaustivas que incluyan escenarios que permitan identificar recursos que no se liberan adecuadamente y aquellos que no se reutilizan cuando es posible.</p> </li> </ol> <p>En resumen, el principio de Reuse/Release Equivalence se puede aplicar en la Arquitectura Limpia mediante el dise\u00f1o modular, el uso de patrones de dise\u00f1o, la gesti\u00f3n adecuada de recursos y la realizaci\u00f3n de pruebas exhaustivas. Al aplicar este principio, se puede mejorar la eficiencia y la confiabilidad del software al garantizar que los recursos se adquieran y liberen de manera oportuna y que se reutilicen siempre que sea posible.</p>"},{"location":"clean_arch/reuse/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Maven es una herramienta de construcci\u00f3n de proyectos que se utiliza com\u00fanmente en proyectos de Java. Una de las principales ventajas de Maven es que permite la gesti\u00f3n de dependencias entre los diferentes m\u00f3dulos de la aplicaci\u00f3n, lo que facilita la reutilizaci\u00f3n de c\u00f3digo y la implementaci\u00f3n del principio de Reuse/Release Equivalence.</p> <p>A continuaci\u00f3n, describimos c\u00f3mo podr\u00edamos aplicar este principio en una arquitectura de Java con Maven:</p> <ol> <li> <p>Definici\u00f3n de m\u00f3dulos: Definimos los diferentes m\u00f3dulos que componen la aplicaci\u00f3n y especificamos las dependencias necesarias para cada uno de ellos. Por ejemplo, podr\u00edamos tener diferentes m\u00f3dulos para diferentes componentes de la aplicaci\u00f3n, como la capa de servicios, la capa de datos, la capa de presentaci\u00f3n, etc.</p> </li> <li> <p>Creaci\u00f3n de dependencias compartidas: Creamos dependencias compartidas que se puedan reutilizar en diferentes m\u00f3dulos de la aplicaci\u00f3n. Por ejemplo, podr\u00edamos crear una dependencia para manejar la conexi\u00f3n a la base de datos, otra dependencia para manejar la autenticaci\u00f3n de usuarios, etc.</p> </li> <li> <p>Uso de dependencias compartidas: Utilizamos las dependencias compartidas en diferentes m\u00f3dulos de la aplicaci\u00f3n que necesiten dicha funcionalidad. Por ejemplo, podr\u00edamos utilizar la dependencia de conexi\u00f3n a la base de datos en diferentes m\u00f3dulos de la capa de datos que necesiten acceder a la base de datos.</p> </li> <li> <p>Liberaci\u00f3n de recursos: Nos aseguramos de que las dependencias compartidas liberen adecuadamente los recursos adquiridos cuando ya no sean necesarios. Por ejemplo, podr\u00edamos utilizar el m\u00e9todo close() para asegurarnos de que se liberen adecuadamente los recursos cuando se deja de utilizar una conexi\u00f3n a la base de datos.</p> </li> </ol> <p>Al aplicar el principio de Reuse/Release Equivalence a trav\u00e9s del uso de dependencias compartidas en una arquitectura de Java con Maven, estamos asegurando la reutilizaci\u00f3n de componentes comunes en diferentes partes de la aplicaci\u00f3n, lo que reduce la duplicaci\u00f3n de c\u00f3digo y mejora la eficiencia y mantenibilidad de la aplicaci\u00f3n. Adem\u00e1s, al liberar adecuadamente los recursos adquiridos, estamos garantizando la correcta gesti\u00f3n de los mismos, lo que ayuda a prevenir posibles errores y problemas de rendimiento.</p>"},{"location":"clean_arch/reuse/#ejemplo","title":"Ejemplo","text":"<pre><code>graph TD;\n    A[M\u00f3dulo A] --&gt;|Dependencia compartida| C[Componente compartido];\n    B[M\u00f3dulo B] --&gt;|Dependencia compartida| C;\n    C --&gt;|Liberaci\u00f3n de recursos| D[Recurso externo];</code></pre> <p>En este diagrama, los m\u00f3dulos A y B dependen del componente compartido C. El componente compartido C, a su vez, utiliza un recurso externo D, como una base de datos o una API. La flecha entre el componente compartido C y el recurso externo D representa la necesidad de liberar adecuadamente los recursos adquiridos por el componente compartido.</p> <p>Este diagrama ilustra c\u00f3mo el principio de Reuse/Release Equivalence se puede aplicar en una arquitectura de software mediante el uso de componentes compartidos y la liberaci\u00f3n adecuada de recursos. Los m\u00f3dulos A y B pueden reutilizar el c\u00f3digo del componente compartido C, lo que mejora la eficiencia y la mantenibilidad de la aplicaci\u00f3n. Al mismo tiempo, la liberaci\u00f3n adecuada de los recursos adquiridos por el componente compartido C ayuda a prevenir posibles errores y problemas de rendimiento.</p>"},{"location":"clean_arch/stable_abstractions/","title":"Stable Abstractions","text":"<p>El principio de \"Stable Abstractions\" de arquitectura limpia establece que los m\u00f3dulos m\u00e1s estables deben ser los m\u00e1s abstractos, mientras que los m\u00f3dulos menos estables deben ser los menos abstractos. Esto significa que los m\u00f3dulos m\u00e1s estables deben tener la mayor cantidad de abstracciones posibles, mientras que los m\u00f3dulos menos estables deben tener menos abstracciones.</p> <p>En t\u00e9rminos simples, la abstracci\u00f3n se refiere a la capacidad de un m\u00f3dulo de ocultar sus detalles de implementaci\u00f3n y exponer solo una interfaz p\u00fablica. La estabilidad se refiere a la frecuencia con la que se realizan cambios en el m\u00f3dulo. Por lo tanto, un m\u00f3dulo estable es uno que cambia con poca frecuencia y un m\u00f3dulo inestable es uno que cambia con frecuencia.</p> <p>La idea detr\u00e1s del principio de \"Stable Abstractions\" es que los m\u00f3dulos m\u00e1s estables deben ser m\u00e1s abstractos porque es menos probable que cambien y, por lo tanto, pueden tener abstracciones m\u00e1s complejas. Por otro lado, los m\u00f3dulos menos estables deben tener menos abstracciones porque es m\u00e1s probable que cambien y, por lo tanto, es m\u00e1s importante que su implementaci\u00f3n sea clara y f\u00e1cil de modificar.</p> <p>Al aplicar este principio, se busca minimizar el impacto de los cambios en los m\u00f3dulos menos estables, ya que estos cambios no deben afectar a los m\u00f3dulos m\u00e1s estables. Adem\u00e1s, los m\u00f3dulos m\u00e1s estables pueden reutilizarse m\u00e1s f\u00e1cilmente en otros sistemas o proyectos, ya que tienen abstracciones m\u00e1s complejas que pueden ser \u00fatiles en diferentes contextos.</p> <p>En resumen, el principio de \"Stable Abstractions\" busca equilibrar la estabilidad y la abstracci\u00f3n de los m\u00f3dulos de un sistema para mejorar su mantenibilidad y reutilizaci\u00f3n.</p>"},{"location":"clean_arch/stable_abstractions/#recomendaciones","title":"Recomendaciones","text":"<p>Para aplicar el principio de \"Stable Abstractions\" en el dise\u00f1o de un sistema, se deben seguir los siguientes pasos:</p> <ol> <li> <p>Identificar los m\u00f3dulos del sistema: Primero, se deben identificar los m\u00f3dulos del sistema y clasificarlos en funci\u00f3n de su estabilidad. Los m\u00f3dulos m\u00e1s estables son aquellos que cambian con menos frecuencia, mientras que los m\u00f3dulos menos estables son aquellos que cambian con mayor frecuencia.</p> </li> <li> <p>Analizar la abstracci\u00f3n de cada m\u00f3dulo: A continuaci\u00f3n, se debe analizar la abstracci\u00f3n de cada m\u00f3dulo. La abstracci\u00f3n se refiere a la capacidad del m\u00f3dulo de ocultar sus detalles de implementaci\u00f3n y exponer solo una interfaz p\u00fablica. Los m\u00f3dulos m\u00e1s abstractos son aquellos que tienen una interfaz p\u00fablica m\u00e1s compleja y menos dependencia de los detalles de implementaci\u00f3n.</p> </li> <li> <p>Equilibrar la estabilidad y la abstracci\u00f3n: Una vez que se han analizado la estabilidad y la abstracci\u00f3n de cada m\u00f3dulo, se debe buscar equilibrar estos factores. Los m\u00f3dulos m\u00e1s estables deben tener una mayor abstracci\u00f3n, mientras que los m\u00f3dulos menos estables deben tener una menor abstracci\u00f3n. De esta manera, se garantiza que los cambios en los m\u00f3dulos menos estables no afecten a los m\u00f3dulos m\u00e1s estables, y que los m\u00f3dulos m\u00e1s estables puedan ser reutilizados en diferentes contextos.</p> </li> <li> <p>Refinar la abstracci\u00f3n: Finalmente, se debe refinar la abstracci\u00f3n de los m\u00f3dulos a medida que se realizan cambios en el sistema. Si un m\u00f3dulo se vuelve m\u00e1s estable con el tiempo, se puede aumentar su abstracci\u00f3n. Por otro lado, si un m\u00f3dulo se vuelve menos estable, se debe reducir su abstracci\u00f3n para garantizar que sea m\u00e1s f\u00e1cil de mantener y modificar.</p> </li> </ol> <p>En resumen, para aplicar el principio de \"Stable Abstractions\" se debe analizar y equilibrar la estabilidad y la abstracci\u00f3n de los m\u00f3dulos del sistema, y refinar la abstracci\u00f3n a medida que se realizan cambios. De esta manera, se garantiza que el sistema sea m\u00e1s mantenible y reutilizable.</p>"},{"location":"clean_arch/stable_abstractions/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Supongamos que estamos desarrollando un sistema de gesti\u00f3n de inventarios para una tienda. Podr\u00edamos aplicar el principio de \"Stable Abstractions\" de la siguiente manera:</p> <ol> <li> <p>Identificar los m\u00f3dulos del sistema: Los m\u00f3dulos del sistema podr\u00edan ser: gesti\u00f3n de productos, gesti\u00f3n de clientes, gesti\u00f3n de ventas, gesti\u00f3n de inventarios y gesti\u00f3n de pedidos.</p> </li> <li> <p>Analizar la abstracci\u00f3n de cada m\u00f3dulo: Por ejemplo, el m\u00f3dulo de gesti\u00f3n de productos podr\u00eda tener una interfaz p\u00fablica que permita agregar, eliminar y actualizar productos. El m\u00f3dulo de gesti\u00f3n de clientes podr\u00eda tener una interfaz p\u00fablica que permita agregar, eliminar y actualizar clientes. El m\u00f3dulo de gesti\u00f3n de ventas podr\u00eda tener una interfaz p\u00fablica que permita registrar ventas y generar facturas. El m\u00f3dulo de gesti\u00f3n de inventarios podr\u00eda tener una interfaz p\u00fablica que permita verificar la disponibilidad de productos en el inventario. El m\u00f3dulo de gesti\u00f3n de pedidos podr\u00eda tener una interfaz p\u00fablica que permita registrar pedidos de productos.</p> </li> <li> <p>Equilibrar la estabilidad y la abstracci\u00f3n: En este caso, los m\u00f3dulos de gesti\u00f3n de productos y gesti\u00f3n de clientes podr\u00edan ser m\u00e1s estables, ya que no cambian con tanta frecuencia como los m\u00f3dulos de gesti\u00f3n de ventas y gesti\u00f3n de pedidos. Por lo tanto, se podr\u00eda aumentar su abstracci\u00f3n para hacerlos m\u00e1s reutilizables. Por otro lado, los m\u00f3dulos de gesti\u00f3n de ventas y gesti\u00f3n de pedidos podr\u00edan tener una menor abstracci\u00f3n, ya que cambian con m\u00e1s frecuencia y est\u00e1n m\u00e1s ligados a los detalles de implementaci\u00f3n.</p> </li> <li> <p>Refinar la abstracci\u00f3n: Si en el futuro se realizan cambios en el sistema y se identifica que el m\u00f3dulo de gesti\u00f3n de inventarios se vuelve m\u00e1s estable, se podr\u00eda aumentar su abstracci\u00f3n para hacerlo m\u00e1s reutilizable en otros contextos.</p> </li> </ol> <p>Para implementar esto en un proyecto de Java, podr\u00edamos organizar nuestros paquetes y clases de la siguiente manera:</p> <ul> <li>com.tienda.gestionproductos<ul> <li>Producto.java</li> <li>GestionProductosService.java</li> <li>GestionProductosRepository.java</li> </ul> </li> <li>com.tienda.gestionclientes<ul> <li>Cliente.java</li> <li>GestionClientesService.java</li> <li>GestionClientesRepository.java</li> </ul> </li> <li>com.tienda.gestionventas<ul> <li>Venta.java</li> <li>Factura.java</li> <li>GestionVentasService.java</li> <li>GestionVentasRepository.java</li> </ul> </li> <li>com.tienda.gestioninventarios<ul> <li>Inventario.java</li> <li>GestionInventariosService.java</li> <li>GestionInventariosRepository.java</li> </ul> </li> <li>com.tienda.gestionpedidos<ul> <li>Pedido.java</li> <li>GestionPedidosService.java</li> <li>GestionPedidosRepository.java</li> </ul> </li> </ul> <p>En este ejemplo, los m\u00f3dulos de gesti\u00f3n de productos y gesti\u00f3n de clientes est\u00e1n en paquetes separados y tienen sus propias interfaces p\u00fablicas, lo que permite su reutilizaci\u00f3n en diferentes contextos. Los m\u00f3dulos de gesti\u00f3n de ventas, gesti\u00f3n de inventarios y gesti\u00f3n de pedidos est\u00e1n en paquetes separados y tienen una menor abstracci\u00f3n, ya que est\u00e1n m\u00e1s ligados a los detalles de implementaci\u00f3n y cambian con m\u00e1s frecuencia.</p>"},{"location":"clean_arch/stable_abstractions/#ejemplo","title":"Ejemplo","text":"<p><pre><code>graph TD;\n    A[UI]--&gt;B[Application Layer];\n    B --&gt; C[Domain Layer];\n    C --&gt; D[Infrastructure Layer];\n    D --&gt; E[External Services];</code></pre> En esta representaci\u00f3n, se muestra que la capa de la interfaz de usuario (UI) depende de la capa de aplicaci\u00f3n, que a su vez depende de la capa de dominio, y as\u00ed sucesivamente. Se observa que las capas m\u00e1s internas (de dominio e infraestructura) tienen una mayor estabilidad en comparaci\u00f3n con las capas externas (UI y servicios externos), lo que se traduce en una mayor independencia y capacidad de reutilizaci\u00f3n. Esto es consistente con el principio de Stable Abstractions, que busca que las capas m\u00e1s estables de la aplicaci\u00f3n sean las que contengan las abstracciones m\u00e1s importantes y de mayor valor para el negocio.</p>"},{"location":"clean_arch/stable_dependencies/","title":"Stable Dependencies","text":"<p>Este principio se refiere a la idea de que los m\u00f3dulos de un sistema de software deben depender de m\u00f3dulos que sean m\u00e1s estables que ellos mismos.</p> <p>La estabilidad de un m\u00f3dulo se define en funci\u00f3n de la cantidad de cambios que ha sufrido en el pasado. Si un m\u00f3dulo ha sufrido pocos cambios, se considera que es m\u00e1s estable que otro m\u00f3dulo que ha sufrido muchos cambios. Por otro lado, la estabilidad de un m\u00f3dulo tambi\u00e9n se ve afectada por la cantidad de m\u00f3dulos que dependen de \u00e9l. Si un m\u00f3dulo es dependido por muchos otros m\u00f3dulos, se considera que es menos estable que otro m\u00f3dulo que es dependido por pocos m\u00f3dulos.</p> <p>El principio de \"Stable Dependencies\" sugiere que los m\u00f3dulos m\u00e1s estables deben ser independientes de los m\u00f3dulos menos estables. De esta manera, se evita que los cambios en los m\u00f3dulos menos estables afecten a los m\u00f3dulos m\u00e1s estables. Por otro lado, los m\u00f3dulos menos estables deben depender de los m\u00f3dulos m\u00e1s estables. De esta manera, se asegura que los m\u00f3dulos m\u00e1s estables sean menos propensos a cambiar, lo que puede mejorar la estabilidad del sistema en su conjunto.</p> <p>En resumen, el principio de \"Stable Dependencies\" se refiere a la idea de que los m\u00f3dulos de un sistema de software deben depender de m\u00f3dulos que sean m\u00e1s estables que ellos mismos. Esto puede mejorar la estabilidad del sistema y reducir el impacto de los cambios en los m\u00f3dulos menos estables.</p>"},{"location":"clean_arch/stable_dependencies/#recomendaciones","title":"Recomendaciones","text":"<p>Para aplicar el principio de \"Stable Dependencies\" en el dise\u00f1o de un sistema de software, se deben seguir las siguientes recomendaciones:</p> <ol> <li> <p>Identificar los m\u00f3dulos cr\u00edticos: En primer lugar, es importante identificar los m\u00f3dulos cr\u00edticos o de alta importancia en el sistema. Estos m\u00f3dulos deben ser estables y no depender de otros m\u00f3dulos menos estables.</p> </li> <li> <p>Establecer dependencias en funci\u00f3n de la estabilidad: Una vez que se han identificado los m\u00f3dulos cr\u00edticos, se deben establecer dependencias con otros m\u00f3dulos en funci\u00f3n de su estabilidad. Los m\u00f3dulos m\u00e1s estables deben ser independientes de los m\u00f3dulos menos estables, mientras que los m\u00f3dulos menos estables deben depender de los m\u00f3dulos m\u00e1s estables.</p> </li> <li> <p>Reducir el acoplamiento: Es importante reducir el acoplamiento entre los m\u00f3dulos del sistema. Esto se puede lograr mediante la identificaci\u00f3n de las dependencias entre los m\u00f3dulos y la eliminaci\u00f3n de aquellas que no son necesarias.</p> </li> <li> <p>Refactorizar el c\u00f3digo: Si se identifican dependencias ciclicas o una gran cantidad de dependencias, puede ser necesario refactorizar el c\u00f3digo para lograr una mejor organizaci\u00f3n y cumplir con el principio de \"Stable Dependencies\".</p> </li> <li> <p>Monitorear y ajustar: Es importante monitorear la estabilidad de los m\u00f3dulos a lo largo del tiempo y ajustar las dependencias si es necesario. Esto garantiza que los m\u00f3dulos m\u00e1s estables sigan siendo independientes y que los m\u00f3dulos menos estables sigan dependiendo de los m\u00e1s estables.</p> </li> </ol> <p>En resumen, para aplicar el principio de \"Stable Dependencies\" es necesario identificar los m\u00f3dulos cr\u00edticos y establecer dependencias en funci\u00f3n de su estabilidad, reducir el acoplamiento, refactorizar el c\u00f3digo si es necesario, y monitorear y ajustar las dependencias a lo largo del tiempo.</p>"},{"location":"clean_arch/stable_dependencies/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Para ilustrar el principio de \"Stable Dependencies\" en Java y Maven, supongamos que tenemos una aplicaci\u00f3n de comercio electr\u00f3nico que consta de varios m\u00f3dulos, incluyendo un m\u00f3dulo de pedidos, un m\u00f3dulo de inventario y un m\u00f3dulo de facturaci\u00f3n. Asumimos que el m\u00f3dulo de pedidos es el m\u00e1s cr\u00edtico para el negocio y, por lo tanto, debe ser el m\u00e1s estable.</p> <p>Para aplicar el principio de \"Stable Dependencies\", debemos dise\u00f1ar los m\u00f3dulos de manera que los m\u00f3dulos menos estables dependan de los m\u00f3dulos m\u00e1s estables. Por lo tanto, el m\u00f3dulo de inventario y el m\u00f3dulo de facturaci\u00f3n deben depender del m\u00f3dulo de pedidos.</p> <p>A continuaci\u00f3n, se muestra una representaci\u00f3n en c\u00f3digo de c\u00f3mo se puede aplicar el principio de \"Stable Dependencies\" en Java y Maven: <pre><code>// En el archivo pom.xml del m\u00f3dulo de inventario\n&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;pedidos&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n// En el archivo pom.xml del m\u00f3dulo de facturaci\u00f3n\n&lt;dependencies&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;com.example&lt;/groupId&gt;\n    &lt;artifactId&gt;pedidos&lt;/artifactId&gt;\n    &lt;version&gt;1.0.0&lt;/version&gt;\n  &lt;/dependency&gt;\n&lt;/dependencies&gt;\n\n// En el archivo pom.xml del m\u00f3dulo de pedidos\n&lt;dependencies&gt;\n  // Dependencias del m\u00f3dulo de pedidos\n&lt;/dependencies&gt;\n</code></pre> Como se puede observar, los m\u00f3dulos de inventario y facturaci\u00f3n dependen del m\u00f3dulo de pedidos, que es el m\u00e1s estable. De esta manera, se garantiza que los m\u00f3dulos menos estables dependan de los m\u00f3dulos m\u00e1s estables y se cumple con el principio de \"Stable Dependencies\". Adem\u00e1s, en caso de que se realicen cambios en el m\u00f3dulo de pedidos, se minimiza el impacto en los otros m\u00f3dulos que dependen de \u00e9l.</p>"},{"location":"clean_arch/stable_dependencies/#ejemplo","title":"Ejemplo","text":"<p>A continuaci\u00f3n, se presenta una ilustraci\u00f3n en Mermaid del principio \"Stable Dependencies\": <pre><code>graph TD;\n  A[Pedidos]--&gt;|Depends on| B((Inventario));\n  A--&gt;|Depends on| C((Facturaci\u00f3n));</code></pre> En la ilustraci\u00f3n, el m\u00f3dulo de Pedidos (A) es el m\u00e1s estable y los m\u00f3dulos de Inventario (B) y Facturaci\u00f3n (C) dependen de \u00e9l. Esto se representa mediante las flechas que van desde el m\u00f3dulo de Pedidos hacia los m\u00f3dulos de Inventario y Facturaci\u00f3n. La direcci\u00f3n de las flechas representa la dependencia y se cumple con el principio de \"Stable Dependencies\".</p>"},{"location":"clean_arch/workshop/","title":"Taller/Practica","text":""},{"location":"clean_arch/workshop/#ejercicio-practico-para-el-principio-de-the-reuserelease-equivalence","title":"Ejercicio pr\u00e1ctico para el principio de \"The Reuse/Release Equivalence\":","text":"<p>Supongamos que estamos desarrollando una aplicaci\u00f3n en Java que tiene una funcionalidad para crear y enviar correos electr\u00f3nicos. Queremos asegurarnos de que la funcionalidad de env\u00edo de correos electr\u00f3nicos sea f\u00e1cilmente reutilizable en otros proyectos. Para aplicar el principio de \"The Reuse/Release Equivalence\", debemos crear un paquete independiente para la funcionalidad de env\u00edo de correos electr\u00f3nicos, con una API clara y bien definida. Luego, podemos publicar este paquete como una biblioteca independiente, que otros proyectos pueden utilizar f\u00e1cilmente.</p> <p>Para implementar este ejercicio en Java y Maven, podemos seguir los siguientes pasos:</p> <ol> <li> <p>Crear un nuevo proyecto de Maven para nuestra funcionalidad de env\u00edo de correos electr\u00f3nicos:</p> <pre><code>mvn archetype:generate -DgroupId=com.example.email -DartifactId=email-sender -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\n</code></pre> </li> <li> <p>Definir la API p\u00fablica para nuestra funcionalidad de env\u00edo de correos electr\u00f3nicos en un paquete separado:</p> <pre><code>package com.example.email.sender;\npublic interface EmailSender {\nvoid send(String to, String subject, String body);\n}\n</code></pre> </li> <li> <p>Implementar la funcionalidad de env\u00edo de correos electr\u00f3nicos en una clase separada:     <pre><code>package com.example.email.sender.impl;\nimport com.example.email.sender.EmailSender;\npublic class EmailSenderImpl implements EmailSender {\n@Override\npublic void send(String to, String subject, String body) {\n// implementaci\u00f3n de la funcionalidad de env\u00edo de correos electr\u00f3nicos\n}\n}\n</code></pre></p> </li> <li> <p>Empaquetar nuestra funcionalidad de env\u00edo de correos electr\u00f3nicos en un JAR independiente:     <pre><code>mvn package\n</code></pre></p> </li> <li> <p>Instalar el JAR en nuestro repositorio local de Maven:     <pre><code>mvn install\n</code></pre></p> </li> <li> <p>Ahora, otros proyectos pueden utilizar nuestra funcionalidad de env\u00edo de correos electr\u00f3nicos simplemente agregando la dependencia en su archivo pom.xml:     <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.example.email&lt;/groupId&gt;\n&lt;artifactId&gt;email-sender&lt;/artifactId&gt;\n&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></p> </li> </ol>"},{"location":"clean_arch/workshop/#ejercicio-practico-para-el-principio-de-common-closure","title":"Ejercicio pr\u00e1ctico para el principio de \"Common Closure\":","text":"<p>Supongamos que estamos desarrollando una aplicaci\u00f3n que permite a los usuarios registrarse y acceder a una plataforma para comprar productos. Queremos aplicar el principio de Common Closure para asegurarnos de que cada m\u00f3dulo de nuestro proyecto tenga responsabilidades coherentes y est\u00e9n enfocados en funcionalidades similares.</p> <p>Para ello, podemos crear dos m\u00f3dulos: uno para la autenticaci\u00f3n y registro de usuarios, y otro para la gesti\u00f3n de compras. Estos dos m\u00f3dulos tendr\u00e1n responsabilidades claramente definidas y no se mezclar\u00e1n las funcionalidades.</p> <p>A continuaci\u00f3n, te muestro c\u00f3mo estructurar\u00edamos nuestro proyecto usando este principio:</p> <pre><code>- my-project\n  - pom.xml\n  - authentication-registration-module\n    - pom.xml\n    - src\n      - main\n        - java\n          - com.myproject.auth\n            - AuthenticationService.java\n            - RegistrationService.java\n  - purchase-management-module\n    - pom.xml\n    - src\n      - main\n        - java\n          - com.myproject.purchase\n            - PurchaseService.java\n            - Product.java\n</code></pre> <p>En este ejemplo, cada m\u00f3dulo tiene su propio pom.xml y su propia estructura de paquetes. El m\u00f3dulo de autenticaci\u00f3n y registro tiene sus clases en el paquete \"com.myproject.auth\", mientras que el m\u00f3dulo de gesti\u00f3n de compras tiene sus clases en el paquete \"com.myproject.purchase\". De esta manera, cada m\u00f3dulo tiene una responsabilidad claramente definida.</p> <p>Para asegurarnos de que estos m\u00f3dulos no est\u00e9n acoplados, podemos definir interfaces para cada uno de ellos y hacer que se comuniquen a trav\u00e9s de estas interfaces. Por ejemplo, podemos definir una interfaz \"UserRepository\" en el m\u00f3dulo de autenticaci\u00f3n y registro, y hacer que el m\u00f3dulo de gesti\u00f3n de compras use esta interfaz para acceder a los datos del usuario.</p> <pre><code>- my-project\n  - pom.xml\n  - authentication-registration-module\n    - pom.xml\n    - src\n      - main\n        - java\n          - com.myproject.auth\n            - AuthenticationService.java\n            - RegistrationService.java\n            - UserRepository.java (interfaz)\n- purchase-management-module\n    - pom.xml\n    - src\n      - main\n        - java\n          - com.myproject.purchase\n            - PurchaseService.java\n            - Product.java\n            - UserRepository.java (interfaz)\n</code></pre> <p>De esta manera, estamos aplicando el principio de Common Closure para asegurarnos de que cada m\u00f3dulo tenga una responsabilidad coherente y que est\u00e9 enfocado en funcionalidades similares. Tambi\u00e9n estamos aplicando el principio de Dependency Inversion para reducir el acoplamiento entre m\u00f3dulos y aumentar la reutilizaci\u00f3n de c\u00f3digo.</p>"},{"location":"clean_arch/workshop/#ejercicio-practico-para-el-principio-de-common-reuse","title":"Ejercicio pr\u00e1ctico para el principio de \"Common Reuse\":","text":"<p>En este ejercicio, se aplicar\u00e1 el principio de Common Reuse de la Arquitectura Limpia en un proyecto Java usando Maven. El objetivo es crear una estructura de proyecto que permita reutilizar el c\u00f3digo en diferentes proyectos.</p> <ol> <li> <p>Crear un proyecto Java b\u00e1sico usando Maven: <pre><code>mvn archetype:generate -DgroupId=com.example.commonreuse -DartifactId=myproject -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\n</code></pre></p> </li> <li> <p>En el archivo pom.xml, agregar las siguientes dependencias de Apache Commons: <pre><code>&lt;dependencies&gt;\n&lt;!-- Apache Commons Lang --&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;\n&lt;version&gt;3.12.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!-- Apache Commons Math --&gt;\n&lt;dependency&gt;\n&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;\n&lt;artifactId&gt;commons-math3&lt;/artifactId&gt;\n&lt;version&gt;3.6.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre></p> </li> <li>Crear una clase de utilidad en el paquete com.example.commonreuse.util: <pre><code>package com.example.commonreuse.util;\nimport org.apache.commons.lang3.StringUtils;\npublic class StringUtil {\npublic static boolean isEmpty(String str) {\nreturn StringUtils.isEmpty(str);\n}\npublic static boolean isNotEmpty(String str) {\nreturn StringUtils.isNotEmpty(str);\n}\n}\n</code></pre></li> <li> <p>Crear una clase de c\u00e1lculo en el paquete com.example.commonreuse.math: <pre><code>package com.example.commonreuse.math;\nimport org.apache.commons.math3.stat.StatUtils;\npublic class MathUtil {\npublic static double[] calculateStatistics(double[] values) {\ndouble mean = StatUtils.mean(values);\ndouble variance = StatUtils.variance(values, mean);\ndouble stdDev = Math.sqrt(variance);\nreturn new double[]{mean, stdDev};\n}\n}\n</code></pre></p> </li> <li> <p>Empaquetar el proyecto en un archivo JAR usando Maven: <pre><code>mvn package\n</code></pre></p> </li> <li> <p>Crear un nuevo proyecto Java que use el c\u00f3digo de utilidad y de c\u00e1lculo creados anteriormente. Para hacerlo, agregar la siguiente dependencia en el archivo pom.xml: <pre><code>&lt;dependency&gt;\n&lt;groupId&gt;com.example.commonreuse&lt;/groupId&gt;\n&lt;artifactId&gt;myproject&lt;/artifactId&gt;\n&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></p> </li> <li> <p>Crear una nueva clase en el nuevo proyecto que use el c\u00f3digo de utilidad y de c\u00e1lculo: <pre><code>package com.example.commonreuse.app;\nimport com.example.commonreuse.math.MathUtil;\nimport com.example.commonreuse.util.StringUtil;\npublic class App {\npublic static void main(String[] args) {\ndouble[] values = {1, 2, 3, 4, 5};\ndouble[] stats = MathUtil.calculateStatistics(values);\nSystem.out.println(\"Mean: \" + stats[0]);\nSystem.out.println(\"Std dev: \" + stats[1]);\nString str = \"   \";\nSystem.out.println(\"Is empty: \" + StringUtil.isEmpty(str));\n}\n}\n</code></pre></p> </li> <li> <p>Empaquetar el proyecto en un archivo JAR usando Maven: <pre><code>mvn package\n</code></pre></p> </li> </ol> <p>Con esto, se ha creado una estructura de proyecto que permite reutilizar el c\u00f3digo de utilidad y de c\u00e1lculo en diferentes proyectos. Esto se logra mediante el uso del principio Common Reuse</p>"},{"location":"clean_arch/workshop/#ejercicio-practico-para-el-principio-de-stable-abstractions","title":"Ejercicio pr\u00e1ctico para el principio de \"Stable Abstractions\":","text":"<p>Para aplicar el principio Stable Abstractions en un proyecto Java con Maven, se pueden seguir los siguientes pasos:</p> <ol> <li> <p>Crear una estructura de paquetes que refleje la arquitectura del sistema y que permita separar las capas o m\u00f3dulos de la aplicaci\u00f3n.</p> </li> <li> <p>Definir interfaces y abstracciones que permitan desacoplar las capas o m\u00f3dulos de la aplicaci\u00f3n y que se puedan usar para establecer contratos entre ellos.</p> </li> <li> <p>Definir clases concretas que implementen las interfaces y abstracciones definidas en el paso anterior, y que se encarguen de realizar las operaciones espec\u00edficas de cada capa o m\u00f3dulo.</p> </li> <li> <p>Organizar los paquetes de tal forma que los paquetes de nivel superior dependan \u00fanicamente de los paquetes de nivel inferior, y no al rev\u00e9s. De esta forma, se garantiza que los paquetes m\u00e1s estables (de nivel inferior) no dependan de los menos estables (de nivel superior).</p> </li> <li> <p>Aplicar el principio de inversi\u00f3n de dependencias para que los paquetes de nivel superior dependan solo de las abstracciones e interfaces, y no de las clases concretas.</p> </li> </ol> <p>A continuaci\u00f3n, se presenta un ejemplo de c\u00f3mo aplicar el principio Stable Abstractions en un proyecto Java con Maven:</p> <p>Supongamos que se tiene una aplicaci\u00f3n de gesti\u00f3n de ventas que consta de tres capas: una capa de presentaci\u00f3n, una capa de l\u00f3gica de negocio y una capa de acceso a datos. Para aplicar el principio Stable Abstractions en esta aplicaci\u00f3n, se pueden seguir los siguientes pasos:</p> <ol> <li>Crear una estructura de paquetes que refleje la arquitectura del sistema:     <pre><code>com.example.ventas\n\u251c\u2500\u2500 presentation\n\u251c\u2500\u2500 business\n\u2514\u2500\u2500 dataaccess\n</code></pre></li> <li>Definir interfaces y abstracciones:     <pre><code>// En el paquete business\npublic interface VentasService {\nList&lt;Venta&gt; listarVentas();\nvoid registrarVenta(Venta venta);\n}\n// En el paquete dataaccess\npublic interface VentasRepository {\nList&lt;Venta&gt; listarVentas();\nvoid registrarVenta(Venta venta);\n}\n</code></pre></li> <li> <p>Definir clases concretas:     <pre><code>// En el paquete business\npublic class VentasServiceImpl implements VentasService {\nprivate VentasRepository ventasRepository;\npublic VentasServiceImpl(VentasRepository ventasRepository) {\nthis.ventasRepository = ventasRepository;\n}\npublic List&lt;Venta&gt; listarVentas() {\nreturn ventasRepository.listarVentas();\n}\npublic void registrarVenta(Venta venta) {\nventasRepository.registrarVenta(venta);\n}\n}\n// En el paquete dataaccess\npublic class VentasRepositoryImpl implements VentasRepository {\npublic List&lt;Venta&gt; listarVentas() {\n// Implementaci\u00f3n espec\u00edfica de acceso a datos\n}\npublic void registrarVenta(Venta venta) {\n// Implementaci\u00f3n espec\u00edfica de acceso a datos\n}\n}\n</code></pre></p> </li> <li> <p>Organizar los paquetes de tal forma que los paquetes de nivel superior dependan \u00fanicamente de los paquetes de nivel inferior:</p> <pre><code>com.example.ventas\n\u251c\u2500\u2500 presentation\n\u2502   \u2514\u2500\u2500 business\n\u251c\u2500\u2500 business\n\u2502   \u2514\u2500\u2500 dataaccess\n\u2514\u2500\u2500 dataaccess\n</code></pre> </li> <li> <p>Aplicar el principio de inversi\u00f3n de dependencias para que los paquetes de nivel superior dependan solo de las abstracciones e interfaces para registrar las ventas. </p> <pre><code>Venta venta = new Venta(/* informaci\u00f3n de la venta */);\nventasService.registrarVenta(venta);\n</code></pre> </li> </ol>"},{"location":"clean_arch/workshop/#preguntas-de-repaso","title":"Preguntas de Repaso","text":"<ol> <li>\u00bfCu\u00e1les son los principios de arquitectura limpia?</li> <li>\u00bfQu\u00e9 es el principio de Common Closure? \u00bfC\u00f3mo se aplica en la arquitectura de software?</li> <li>\u00bfQu\u00e9 es el principio de Common Reuse? \u00bfC\u00f3mo se aplica en la arquitectura de software?</li> <li>\u00bfEn qu\u00e9 consiste el principio de Release/Reuse Equivalence?</li> <li>\u00bfQu\u00e9 es el principio de Acyclic Dependencies? \u00bfC\u00f3mo se aplica en la arquitectura de software?</li> <li>\u00bfEn qu\u00e9 consiste el principio de Stable Dependencies? \u00bfC\u00f3mo se aplica en la arquitectura de software?</li> <li>\u00bfQu\u00e9 es el principio de Stable Abstractions? \u00bfC\u00f3mo se aplica en la arquitectura de software?</li> <li>\u00bfC\u00f3mo se relacionan los principios de arquitectura limpia con el dise\u00f1o de software orientado a objetos?</li> <li>\u00bfPor qu\u00e9 es importante seguir los principios de arquitectura limpia en el desarrollo de software?</li> <li>\u00bfQu\u00e9 herramientas o t\u00e9cnicas se pueden utilizar para aplicar los principios de arquitectura limpia en el desarrollo de software?</li> </ol>"},{"location":"cloud/automate_environment/","title":"Automate Your Environment","text":"<p>El principio \"Automate Your Environment\" se refiere a la automatizaci\u00f3n de tareas y procesos en el entorno de desarrollo, implementaci\u00f3n y operaciones de sistemas de software. El objetivo es minimizar el trabajo manual repetitivo y propenso a errores, y maximizar la eficiencia y la consistencia en todas las etapas del ciclo de vida de un sistema.</p> <p>Automatizar el entorno tiene varios beneficios, entre ellos:</p> <ol> <li> <p>Eficiencia y productividad: La automatizaci\u00f3n reduce la necesidad de realizar tareas manuales, lo que ahorra tiempo y esfuerzo. Las tareas que sol\u00edan llevar horas o d\u00edas pueden completarse en minutos o segundos, lo que permite una entrega m\u00e1s r\u00e1pida y una mayor capacidad de respuesta a los cambios.</p> </li> <li> <p>Consistencia: La automatizaci\u00f3n garantiza que los procesos se realicen de manera coherente y estandarizada en todo el entorno. Esto reduce los errores humanos y mejora la calidad y fiabilidad del sistema.</p> </li> <li> <p>Reproducibilidad: Al automatizar el entorno, se puede capturar y documentar el proceso en forma de c\u00f3digo o scripts. Esto permite reproducir el entorno de manera exacta en diferentes etapas, como desarrollo, pruebas o producci\u00f3n, lo que facilita la colaboraci\u00f3n y la soluci\u00f3n de problemas.</p> </li> <li> <p>Escalabilidad: La automatizaci\u00f3n facilita la escalabilidad al permitir la gesti\u00f3n eficiente de recursos, como la creaci\u00f3n y configuraci\u00f3n automatizada de m\u00e1quinas virtuales o contenedores. Esto es especialmente importante en entornos en la nube, donde los recursos se pueden escalar horizontal o verticalmente seg\u00fan sea necesario.</p> </li> <li> <p>Seguridad y cumplimiento: La automatizaci\u00f3n puede ayudar a aplicar pol\u00edticas de seguridad y cumplimiento de manera consistente en todo el entorno. Por ejemplo, se pueden implementar escaneos de seguridad automatizados, configuraciones de red seguras y aplicar parches de software de manera oportuna.</p> </li> </ol> <p>Para aplicar el principio \"Automate Your Environment\", aqu\u00ed hay algunas recomendaciones:</p> <ol> <li> <p>Utiliza herramientas de automatizaci\u00f3n: Existen numerosas herramientas y frameworks que permiten la automatizaci\u00f3n de tareas y procesos, como Ansible, Puppet, Chef, Docker, Kubernetes, Jenkins, entre otros. Investiga y elige las herramientas m\u00e1s adecuadas para tu entorno y requisitos espec\u00edficos.</p> </li> <li> <p>Automatiza la infraestructura: Utiliza herramientas de infraestructura como c\u00f3digo (IaC) para describir y aprovisionar la infraestructura en forma de c\u00f3digo. Esto te permite crear y gestionar tu infraestructura de manera program\u00e1tica, evitando configuraciones manuales propensas a errores.</p> </li> <li> <p>Implementa la integraci\u00f3n y entrega continua (CI/CD): Automatiza el proceso de construcci\u00f3n, pruebas y despliegue de software utilizando pipelines de CI/CD. Esto te permite realizar entregas r\u00e1pidas y frecuentes, manteniendo una alta calidad y minimizando los errores.</p> </li> <li> <p>Automatiza las pruebas: Implementa pruebas automatizadas, como pruebas unitarias, pruebas de integraci\u00f3n y pruebas de rendimiento. Esto te ayuda a identificar problemas de manera temprana y asegurar la calidad del software de manera continua.</p> </li> <li> <p>Monitoriza y gestiona de forma automatizada: Utiliza herramientas de monitoreo y gesti\u00f3n automatizada para supervisar el rendimiento del sistema, detectar anomal\u00edas y aplicar ajustes autom\u00e1ticos cuando sea necesario.</p> </li> <li> <p>Documenta y comparte: Aseg\u00farate de documentar y compartir los procesos y scripts de automatizaci\u00f3n. Esto facilita la colaboraci\u00f3n, el mantenimiento y la transferencia de conocimiento dentro del equipo.</p> </li> </ol> <p>Recuerda que la automatizaci\u00f3n no se limita solo al entorno de desarrollo, sino que puede aplicarse a otras \u00e1reas, como la configuraci\u00f3n de redes, el aprovisionamiento de recursos en la nube, la gesti\u00f3n de bases de datos, la seguridad, entre otros. La clave es identificar las tareas repetitivas y propensas a errores y buscar oportunidades para automatizarlas, mejorando as\u00ed la eficiencia y la confiabilidad de tu entorno.</p>"},{"location":"cloud/automate_environment/#recomendaciones","title":"Recomendaciones","text":"<p>Aqu\u00ed tienes algunas recomendaciones para aplicar el principio \"Automate Your Environment\" de manera efectiva:</p> <ol> <li> <p>Identifica las tareas adecuadas para la automatizaci\u00f3n: Analiza las tareas repetitivas, propensas a errores o que consumen mucho tiempo en tu entorno. Estas tareas son buenos candidatos para la automatizaci\u00f3n. Esto puede incluir la configuraci\u00f3n de infraestructura, la implementaci\u00f3n de software, la gesti\u00f3n de configuraciones, las pruebas, el monitoreo, entre otros.</p> </li> <li> <p>Establece objetivos claros: Define los objetivos espec\u00edficos que deseas lograr con la automatizaci\u00f3n. Estos pueden incluir aumentar la eficiencia, reducir los errores, mejorar la velocidad de entrega, garantizar la consistencia, mejorar la escalabilidad, entre otros. Establecer objetivos claros te ayudar\u00e1 a enfocar tus esfuerzos y evaluar el \u00e9xito de la automatizaci\u00f3n.</p> </li> <li> <p>Selecciona las herramientas adecuadas: Investiga y selecciona las herramientas de automatizaci\u00f3n m\u00e1s adecuadas para tus necesidades. Hay una amplia gama de herramientas disponibles para diferentes \u00e1reas, como infraestructura, gesti\u00f3n de configuraciones, integraci\u00f3n y entrega continua, pruebas, monitoreo, etc. Aseg\u00farate de elegir las herramientas que se integren bien con tu entorno y que sean f\u00e1ciles de usar y mantener.</p> </li> <li> <p>Dise\u00f1a procesos claros y bien definidos: Antes de automatizar una tarea, aseg\u00farate de comprender completamente el proceso manual y documentarlo de manera clara. Identifica los pasos, las dependencias y los requisitos. Esto te ayudar\u00e1 a desarrollar una automatizaci\u00f3n efectiva y evitar\u00e1 problemas en el futuro.</p> </li> <li> <p>Utiliza pr\u00e1cticas de infraestructura como c\u00f3digo (IaC): Adopta el enfoque de infraestructura como c\u00f3digo para automatizar la creaci\u00f3n y configuraci\u00f3n de la infraestructura. Utiliza herramientas como Terraform, CloudFormation o Ansible para describir tu infraestructura en archivos de c\u00f3digo que se puedan gestionar y versionar.</p> </li> <li> <p>Implementa pipelines de integraci\u00f3n y entrega continua (CI/CD): Automatiza el proceso de construcci\u00f3n, pruebas y despliegue de tu software utilizando pipelines de CI/CD. Esto te permite entregar cambios de manera r\u00e1pida y confiable, al tiempo que garantiza la calidad y la consistencia.</p> </li> <li> <p>Documenta y comparte el conocimiento: Aseg\u00farate de documentar los procesos automatizados, los scripts y las configuraciones. Mant\u00e9n una documentaci\u00f3n actualizada que explique c\u00f3mo funcionan las automatizaciones, c\u00f3mo se utilizan las herramientas y cualquier configuraci\u00f3n espec\u00edfica. Esto facilitar\u00e1 la colaboraci\u00f3n y el mantenimiento a largo plazo.</p> </li> <li> <p>Realiza pruebas y validaciones regulares: Aseg\u00farate de probar y validar las automatizaciones de manera regular. Esto incluye realizar pruebas de integraci\u00f3n, pruebas de extremo a extremo y pruebas de rendimiento para garantizar que las automatizaciones funcionen seg\u00fan lo esperado y sigan siendo efectivas a medida que evoluciona tu entorno.</p> </li> </ol> <p>Recuerda que la automatizaci\u00f3n es un proceso continuo. Debes estar dispuesto a iterar y mejorar constantemente tus automatizaciones a medida que evoluciona tu entorno y surgen nuevas necesidades.</p>"},{"location":"cloud/automate_environment/#ejemplo","title":"Ejemplo","text":"<p>Ejemplo de diagrama para ilustrar la automatizaci\u00f3n de un proceso de implementaci\u00f3n continua (CI/CD):</p> <pre><code>graph TD\n\nsubgraph \"Entorno de Desarrollo\"\n  A[Repositorio de C\u00f3digo] --&gt; B[Pruebas Unitarias]\n  B --&gt; C[Construcci\u00f3n]\nend\n\nsubgraph \"Entorno de Pruebas\"\n  C --&gt; D[Despliegue a Entorno de Pruebas]\n  D --&gt; E[Pruebas de Integraci\u00f3n]\n  E --&gt; F[Pruebas de Regresi\u00f3n]\nend\n\nsubgraph \"Entorno de Producci\u00f3n\"\n  F --&gt; G[Despliegue a Entorno de Producci\u00f3n]\nend\n\nsubgraph \"Herramientas de Automatizaci\u00f3n\"\n  H[Servidor de Integraci\u00f3n Continua] --&gt; A\n  H --&gt; C\n  H --&gt; D\n  H --&gt; E\n  H --&gt; F\n  H --&gt; G\nend\n</code></pre> <p>En este ejemplo, el proceso de implementaci\u00f3n continua (CI/CD) se automatiza utilizando diferentes herramientas y entornos. Aqu\u00ed hay una descripci\u00f3n de cada componente:</p> <ul> <li>El \"Repositorio de C\u00f3digo\" almacena el c\u00f3digo fuente de la aplicaci\u00f3n.</li> <li>Las \"Pruebas Unitarias\" se ejecutan en el entorno de desarrollo para verificar la funcionalidad de componentes individuales.</li> <li>La \"Construcci\u00f3n\" del software se realiza en el entorno de desarrollo, donde se generan los artefactos de implementaci\u00f3n.</li> <li>Los artefactos se despliegan en el \"Entorno de Pruebas\" para realizar \"Pruebas de Integraci\u00f3n\" y \"Pruebas de Regresi\u00f3n\" que validan el comportamiento y la interoperabilidad del sistema.</li> <li>Finalmente, si todas las pruebas son exitosas, los artefactos se despliegan en el \"Entorno de Producci\u00f3n\" para su uso en producci\u00f3n.</li> </ul> <p>La automatizaci\u00f3n de este proceso se logra mediante el uso de un \"Servidor de Integraci\u00f3n Continua\" que se encarga de coordinar y ejecutar las diferentes etapas del CI/CD. Este servidor est\u00e1 conectado a cada etapa del proceso, desde la construcci\u00f3n hasta las pruebas y el despliegue, permitiendo la automatizaci\u00f3n y orquestaci\u00f3n de todo el flujo de trabajo.</p> <p>Este es solo un ejemplo b\u00e1sico de c\u00f3mo se puede utilizar Mermaid para representar visualmente la automatizaci\u00f3n de un proceso de CI/CD. Recuerda que puedes personalizar y ampliar este diagrama para adaptarlo a tus propias herramientas y flujos de trabajo de automatizaci\u00f3n.</p>"},{"location":"cloud/avoid_point_failure/","title":"Avoid Single Point Of Failure","text":"<p>El principio \"Avoid Single Point of Failure\" se refiere a dise\u00f1ar y configurar sistemas de manera que no exista un solo punto de fallo que pueda provocar una interrupci\u00f3n total del servicio. Se busca garantizar la disponibilidad y la tolerancia a fallos del sistema, asegurando que la ca\u00edda de un componente o recurso no afecte la funcionalidad general del sistema.</p> <p>Al evitar los puntos de fallo \u00fanicos, se logra mejorar la resiliencia y la confiabilidad del sistema en general. Aqu\u00ed hay algunas consideraciones y recomendaciones para aplicar este principio:</p> <ol> <li> <p>Arquitectura de alta disponibilidad: Dise\u00f1a la arquitectura del sistema de manera que haya redundancia en los componentes cr\u00edticos. Esto implica la utilizaci\u00f3n de m\u00faltiples instancias, servidores, servicios o componentes que puedan asumir la carga y funcionar como respaldo en caso de falla.</p> </li> <li> <p>Distribuci\u00f3n geogr\u00e1fica: Si es posible, distribuye tus recursos y servicios en diferentes ubicaciones geogr\u00e1ficas. Esto proporciona una mayor resistencia ante eventos adversos locales, como fallas de energ\u00eda, desastres naturales o interrupciones en una regi\u00f3n espec\u00edfica.</p> </li> <li> <p>Balanceo de carga: Utiliza un equilibrador de carga para distribuir el tr\u00e1fico de manera uniforme entre m\u00faltiples instancias o servidores. Esto asegura que ning\u00fan componente est\u00e9 sobrecargado y ayuda a evitar un \u00fanico punto de fallo debido a la saturaci\u00f3n de recursos.</p> </li> <li> <p>Replicaci\u00f3n de datos: Implementa la replicaci\u00f3n de datos en tiempo real para garantizar la disponibilidad y la integridad de la informaci\u00f3n. Al replicar los datos en m\u00faltiples ubicaciones, se evita que la p\u00e9rdida de un \u00fanico servidor o ubicaci\u00f3n cause la p\u00e9rdida completa de los datos.</p> </li> <li> <p>Monitoreo y gesti\u00f3n proactiva: Establece un sistema de monitoreo y alertas para detectar y responder r\u00e1pidamente a posibles puntos de fallo. Esto permite tomar medidas preventivas y realizar intervenciones tempranas antes de que los problemas se conviertan en fallas cr\u00edticas.</p> </li> <li> <p>Pruebas de tolerancia a fallos: Realiza pruebas y simulaciones para evaluar la capacidad del sistema para resistir fallos y recuperarse de ellos. Esto puede incluir pruebas de conmutaci\u00f3n por error, pruebas de recuperaci\u00f3n ante desastres y pruebas de carga extrema para evaluar los l\u00edmites y la estabilidad del sistema.</p> </li> <li> <p>Implementa sistemas de respaldo y recuperaci\u00f3n: Establece mecanismos de respaldo y recuperaci\u00f3n para asegurar la continuidad del servicio en caso de fallo. Esto puede incluir la configuraci\u00f3n de copias de seguridad regulares, la implementaci\u00f3n de sistemas de recuperaci\u00f3n ante desastres y la planificaci\u00f3n de procesos de restauraci\u00f3n.</p> </li> </ol> <p>Al seguir estos principios y recomendaciones, puedes minimizar la posibilidad de que un \u00fanico punto de fallo cause interrupciones significativas en tu sistema. La arquitectura resistente y la planificaci\u00f3n adecuada ayudar\u00e1n a garantizar la disponibilidad y la continuidad del servicio incluso en situaciones adversas.</p>"},{"location":"cloud/avoid_point_failure/#recomendaciones","title":"Recomendaciones","text":"<p>Aqu\u00ed tienes algunas recomendaciones para aplicar el principio \"Avoid Single Point of Failure\" en tu arquitectura:</p> <ol> <li> <p>Identifica y analiza los puntos de fallo potenciales: Realiza un an\u00e1lisis exhaustivo de tu arquitectura y identifica los componentes cr\u00edticos que podr\u00edan convertirse en puntos de fallo. Estos podr\u00edan incluir servidores, servicios, redes, bases de datos u otros elementos clave.</p> </li> <li> <p>Dise\u00f1a una arquitectura resiliente: Busca dise\u00f1ar una arquitectura que incorpore redundancia en los componentes cr\u00edticos. Esto implica tener m\u00faltiples instancias o servidores que puedan asumir la carga y funcionar como respaldo en caso de fallo. Utiliza configuraciones de alta disponibilidad y enfoques de tolerancia a fallos, como cl\u00fasteres, r\u00e9plicas o zonas de disponibilidad.</p> </li> <li> <p>Establece pol\u00edticas de escalado autom\u00e1tico: Utiliza herramientas y servicios que permitan el escalado autom\u00e1tico de tus recursos seg\u00fan la demanda. Esto ayuda a distribuir la carga y evita la saturaci\u00f3n de un solo componente. Configura las pol\u00edticas de escalado para aumentar o reducir autom\u00e1ticamente la capacidad seg\u00fan los umbrales de uso predefinidos.</p> </li> <li> <p>Implementa balanceadores de carga: Utiliza un equilibrador de carga para distribuir el tr\u00e1fico de manera uniforme entre tus componentes o servidores. Esto evita que un \u00fanico componente se sobrecargue y se convierta en un punto de fallo. Los balanceadores de carga pueden detectar y redirigir el tr\u00e1fico a componentes sanos en caso de fallo.</p> </li> <li> <p>Utiliza almacenamiento y bases de datos redundantes: Implementa soluciones de almacenamiento y bases de datos que ofrezcan redundancia y replicaci\u00f3n de datos. Utiliza sistemas de almacenamiento distribuido, como sistemas de archivos distribuidos o sistemas de almacenamiento en la nube con replicaci\u00f3n autom\u00e1tica. Configura r\u00e9plicas de bases de datos para garantizar la disponibilidad de los datos incluso en caso de fallos.</p> </li> <li> <p>Establece procesos de monitorizaci\u00f3n y alertas: Implementa un sistema de monitorizaci\u00f3n proactivo que supervise constantemente el estado de tus componentes y servicios. Configura alertas para notificar cualquier anomal\u00eda o degradaci\u00f3n del sistema. Esto te permite identificar problemas potenciales antes de que se conviertan en fallos cr\u00edticos y tomar medidas correctivas de manera oportuna.</p> </li> <li> <p>Realiza pruebas y simulaciones de fallos: Realiza pruebas peri\u00f3dicas de tolerancia a fallos para evaluar la capacidad de tu arquitectura para resistir y recuperarse de fallos. Simula escenarios de fallos y eval\u00faa c\u00f3mo responde tu sistema. Ajusta y mejora tu arquitectura seg\u00fan los resultados de estas pruebas.</p> </li> <li> <p>Planifica la recuperaci\u00f3n ante desastres: Desarrolla un plan de recuperaci\u00f3n ante desastres que incluya procesos y procedimientos claros para restaurar y recuperar tus sistemas en caso de una interrupci\u00f3n grave. Realiza copias de seguridad regulares y prueba la recuperaci\u00f3n de los datos y la infraestructura.</p> </li> </ol> <p>Recuerda que la implementaci\u00f3n exitosa de este principio requiere un enfoque integral y una consideraci\u00f3n detallada de cada componente cr\u00edtico en tu arquitectura. El objetivo es eliminar los puntos de fallo \u00fanicos y asegurar la continuidad del servicio incluso en situaciones de fallo.</p>"},{"location":"cloud/avoid_point_failure/#ejemplo","title":"Ejemplo","text":"<p>\u00a1Claro! Aqu\u00ed tienes un ejemplo de diagrama utilizando la herramienta Mermaid para ilustrar un escenario en el que se aplica el principio \"Avoid Single Point of Failure\":</p> <pre><code>graph LR\n\nsubgraph \"Arquitectura Redundante\"\n    A[Servidor 1] --&gt; B[Balanceador de carga]\n    C[Servidor 2] --&gt; B\n    D[Servidor 3] --&gt; B\n    E[Base de datos 1] --&gt; F[Copia de seguridad de la base de datos]\n    G[Base de datos 2] --&gt; F\n    H[Base de datos 3] --&gt; F\nend\n\nsubgraph \"Monitorizaci\u00f3n y Alertas\"\n    I[Monitor de sistema] --&gt; A\n    I --&gt; C\n    I --&gt; D\n    J[Sistema de alertas] --&gt; I\nend\n</code></pre> <p>En este ejemplo, se muestra una arquitectura redundante y un sistema de monitorizaci\u00f3n y alertas para evitar un \u00fanico punto de fallo. Aqu\u00ed tienes una descripci\u00f3n de cada componente:</p> <ul> <li> <p>\"Arquitectura Redundante\" representa una arquitectura en la que se utilizan m\u00faltiples servidores (Servidor 1, Servidor 2 y Servidor 3) que est\u00e1n equilibrados por un balanceador de carga (Balanceador de carga). Esto permite distribuir el tr\u00e1fico y asegurar que si un servidor falla, otros servidores puedan asumir la carga sin interrupciones en el servicio.</p> </li> <li> <p>\"Base de datos 1, Base de datos 2 y Base de datos 3\" representan bases de datos que est\u00e1n replicadas y respaldadas por una copia de seguridad de la base de datos (Copia de seguridad de la base de datos). Si una base de datos falla, las otras bases de datos pueden continuar brindando el servicio, y la copia de seguridad de la base de datos se puede utilizar para restaurar r\u00e1pidamente la base de datos fallida.</p> </li> <li> <p>\"Monitor de sistema\" representa un sistema de monitorizaci\u00f3n que supervisa constantemente el estado de los servidores. Est\u00e1 conectado a los servidores (Servidor 1, Servidor 2 y Servidor 3) y puede detectar cualquier problema o fallo en ellos.</p> </li> <li> <p>\"Sistema de alertas\" representa un sistema que recibe las notificaciones del monitor de sistema y emite alertas en caso de detectar anomal\u00edas o fallos. Esto permite una respuesta r\u00e1pida y una intervenci\u00f3n oportuna para evitar que los problemas se conviertan en fallos cr\u00edticos.</p> </li> </ul> <p>Este diagrama muestra c\u00f3mo se puede dise\u00f1ar una arquitectura redundante y utilizar sistemas de monitorizaci\u00f3n y alertas para evitar un \u00fanico punto de fallo en los servidores y las bases de datos. Mermaid proporciona una representaci\u00f3n visual clara de este escenario, pero ten en cuenta que este es solo un ejemplo b\u00e1sico y puedes personalizar y expandir el diagrama seg\u00fan tus propias configuraciones y requisitos espec\u00edficos.</p>"},{"location":"cloud/caching/","title":"Use Caching","text":"<p>El principio \"Use Caching\" (Utiliza Cach\u00e9) es una gu\u00eda de dise\u00f1o que sugiere el uso de la cach\u00e9 como una estrategia para mejorar el rendimiento y la eficiencia de una aplicaci\u00f3n. La cach\u00e9 es una memoria temporal que almacena copias de datos que se acceden con frecuencia, de modo que se puedan recuperar r\u00e1pidamente sin tener que volver a obtenerlos de la fuente original.</p> <p>A continuaci\u00f3n, se presentan algunas recomendaciones para aplicar el principio \"Use Caching\":</p> <ol> <li> <p>Identificar datos frecuentemente accedidos: Analiza tu aplicaci\u00f3n y determina qu\u00e9 datos se acceden con mayor frecuencia y tienen un impacto significativo en el rendimiento. Estos datos son buenos candidatos para ser almacenados en cach\u00e9.</p> </li> <li> <p>Dise\u00f1ar una estrategia de cach\u00e9: Define una estrategia clara sobre qu\u00e9 datos se deben almacenar en cach\u00e9, c\u00f3mo se deben almacenar y durante cu\u00e1nto tiempo. Considera el equilibrio entre el costo de almacenamiento en cach\u00e9 y los beneficios de rendimiento que proporciona.</p> </li> <li> <p>Utilizar el almacenamiento en cach\u00e9 en capas: Puedes implementar m\u00faltiples capas de cach\u00e9, desde una cach\u00e9 local en memoria hasta una cach\u00e9 distribuida a nivel de red. Esto te permite aprovechar diferentes niveles de cach\u00e9 seg\u00fan las necesidades y la escala de tu aplicaci\u00f3n.</p> </li> <li> <p>Actualizar la cach\u00e9 de manera coherente: Cuando los datos originales cambien, aseg\u00farate de actualizar la cach\u00e9 correspondiente para reflejar los cambios. Utiliza t\u00e9cnicas como la invalidaci\u00f3n de cach\u00e9 o la actualizaci\u00f3n programada para mantener la coherencia de los datos.</p> </li> <li> <p>Configurar pol\u00edticas de expiraci\u00f3n y evicci\u00f3n: Establece tiempos de expiraci\u00f3n para los datos en cach\u00e9 y define pol\u00edticas de evicci\u00f3n para eliminar los datos menos utilizados cuando la cach\u00e9 alcanza su capacidad m\u00e1xima. Esto ayuda a garantizar que la cach\u00e9 contenga datos actualizados y relevantes.</p> </li> <li> <p>Considerar la consistencia de datos: Si los datos en tu aplicaci\u00f3n requieren una alta consistencia, aseg\u00farate de utilizar una cach\u00e9 coherente que actualice autom\u00e1ticamente los datos en cach\u00e9 cuando se realicen cambios.</p> </li> <li> <p>Realizar pruebas de rendimiento: Realiza pruebas exhaustivas para medir el impacto del uso de la cach\u00e9 en el rendimiento de tu aplicaci\u00f3n. Ajusta la configuraci\u00f3n de la cach\u00e9 y realiza optimizaciones seg\u00fan los resultados obtenidos.</p> </li> </ol> <p>El uso adecuado de la cach\u00e9 puede mejorar significativamente el rendimiento de una aplicaci\u00f3n al reducir la latencia de acceso a datos y disminuir la carga en los recursos de almacenamiento y procesamiento. Sin embargo, es importante tener en cuenta que la cach\u00e9 debe utilizarse de manera cuidadosa y coherente, y adaptarse a las necesidades y caracter\u00edsticas espec\u00edficas de tu aplicaci\u00f3n.</p>"},{"location":"cloud/caching/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Analiza y comprende tus patrones de acceso a datos: Identifica los datos que se acceden con mayor frecuencia y que pueden beneficiarse del almacenamiento en cach\u00e9. Examina los patrones de lectura y escritura de datos en tu aplicaci\u00f3n para determinar qu\u00e9 datos son adecuados para ser almacenados en cach\u00e9.</p> </li> <li> <p>Define una estrategia de cach\u00e9 adecuada: Determina qu\u00e9 tipo de cach\u00e9 es m\u00e1s apropiado para tu aplicaci\u00f3n. Puedes optar por una cach\u00e9 en memoria, una cach\u00e9 basada en disco o una cach\u00e9 distribuida seg\u00fan tus necesidades de rendimiento, escalabilidad y consistencia de datos.</p> </li> <li> <p>Establece pol\u00edticas de expiraci\u00f3n y actualizaci\u00f3n: Define tiempos de expiraci\u00f3n para los datos en cach\u00e9 para garantizar que se actualicen peri\u00f3dicamente desde la fuente original. Considera utilizar t\u00e9cnicas como la invalidaci\u00f3n de cach\u00e9 basada en tiempo, eventos o cambios en los datos subyacentes.</p> </li> <li> <p>Utiliza algoritmos de evicci\u00f3n eficientes: Si la capacidad de la cach\u00e9 se ve limitada, es importante contar con algoritmos de evicci\u00f3n adecuados para eliminar los datos menos utilizados y dar espacio a nuevos datos. Algunos algoritmos populares incluyen LRU (Least Recently Used), LFU (Least Frequently Used) o ARC (Adaptive Replacement Cache).</p> </li> <li> <p>Evita la sobreexposici\u00f3n de la cach\u00e9: Limita el acceso directo a la cach\u00e9 desde diferentes partes de tu aplicaci\u00f3n. En su lugar, utiliza una capa de abstracci\u00f3n o un componente de cach\u00e9 centralizado para controlar el acceso y la gesti\u00f3n de la cach\u00e9 de manera coherente.</p> </li> <li> <p>Monitorea y mide el rendimiento de la cach\u00e9: Implementa m\u00e9tricas y herramientas de monitoreo para evaluar el impacto del almacenamiento en cach\u00e9 en el rendimiento de tu aplicaci\u00f3n. Realiza pruebas de carga y realiza ajustes en la configuraci\u00f3n de la cach\u00e9 seg\u00fan sea necesario.</p> </li> <li> <p>Considera la consistencia y coherencia de los datos: Eval\u00faa las necesidades de consistencia de tus datos y selecciona la estrategia de cach\u00e9 adecuada. Si la coherencia de los datos es cr\u00edtica, considera utilizar t\u00e9cnicas como cach\u00e9s coherentes distribuidas (como Redis) o invalidaci\u00f3n de cach\u00e9 basada en eventos.</p> </li> <li> <p>Realiza pruebas exhaustivas: Antes de implementar el almacenamiento en cach\u00e9 en un entorno de producci\u00f3n, realiza pruebas exhaustivas para asegurarte de que la cach\u00e9 funcione correctamente y mejore el rendimiento de tu aplicaci\u00f3n. Realiza pruebas de estr\u00e9s y pruebas de carga para evaluar el comportamiento de la cach\u00e9 en situaciones de alto tr\u00e1fico.</p> </li> </ol> <p>Recuerda que el uso de la cach\u00e9 no es una soluci\u00f3n universal y debe aplicarse de manera cuidadosa y considerando las caracter\u00edsticas espec\u00edficas de tu aplicaci\u00f3n. Eval\u00faa regularmente el rendimiento de la cach\u00e9 y realiza ajustes seg\u00fan sea necesario para mantener un equilibrio \u00f3ptimo entre el rendimiento y la consistencia de datos.</p>"},{"location":"cloud/caching/#ejemplo","title":"Ejemplo","text":"<pre><code>sequenceDiagram\n    participant Cliente\n    participant Aplicaci\u00f3n\n    participant Cach\u00e9\n    participant BaseDeDatos\n\n    Cliente -&gt;&gt; Aplicaci\u00f3n: Realizar solicitud\n    Aplicaci\u00f3n -&gt;&gt; Cach\u00e9: Consultar cach\u00e9\n    Cach\u00e9 --&gt;&gt; Aplicaci\u00f3n: Datos de la cach\u00e9 o null\n    alt Datos encontrados en la cach\u00e9\n        Aplicaci\u00f3n -&gt;&gt; Cliente: Devolver datos de la cach\u00e9\n    else\n        Aplicaci\u00f3n -&gt;&gt; BaseDeDatos: Consultar base de datos\n        BaseDeDatos --&gt;&gt; Aplicaci\u00f3n: Datos de la base de datos\n        Aplicaci\u00f3n -&gt;&gt; Cach\u00e9: Almacenar datos en la cach\u00e9\n        Aplicaci\u00f3n -&gt;&gt; Cliente: Devolver datos de la base de datos\n    end</code></pre> <p>En este diagrama de secuencia, se muestra la interacci\u00f3n entre el cliente, la aplicaci\u00f3n, la cach\u00e9 y la base de datos. </p> <ol> <li>El cliente realiza una solicitud a la aplicaci\u00f3n.</li> <li>La aplicaci\u00f3n consulta la cach\u00e9 para verificar si los datos solicitados est\u00e1n almacenados en ella.</li> <li>Si los datos se encuentran en la cach\u00e9, se devuelven a la aplicaci\u00f3n y luego al cliente.</li> <li>Si los datos no est\u00e1n en la cach\u00e9, la aplicaci\u00f3n realiza una consulta a la base de datos.</li> <li>La base de datos responde con los datos solicitados.</li> <li>La aplicaci\u00f3n almacena los datos en la cach\u00e9 para su uso futuro.</li> <li>Finalmente, la aplicaci\u00f3n devuelve los datos al cliente.</li> </ol> <p>Este diagrama de secuencia ilustra c\u00f3mo se utiliza la cach\u00e9 para evitar consultas innecesarias a la base de datos y mejorar el rendimiento de la aplicaci\u00f3n.</p>"},{"location":"cloud/choose_databse/","title":"Choose The Rigth Databse Solutions","text":"<p>El principio \"Choose The Right Database Solutions\" (Elige las soluciones de bases de datos adecuadas) se refiere a la importancia de seleccionar la tecnolog\u00eda de base de datos adecuada para satisfacer los requisitos espec\u00edficos de una aplicaci\u00f3n o sistema.</p> <p>Cada proyecto tiene diferentes necesidades y caracter\u00edsticas, por lo tanto, no existe una \u00fanica soluci\u00f3n de base de datos que sea la mejor para todos los casos. Al elegir la soluci\u00f3n de base de datos correcta, se deben tener en cuenta varios factores, como la escalabilidad, el rendimiento, la disponibilidad, la consistencia, la capacidad de consulta, la estructura de datos, el modelo de datos, los requisitos de almacenamiento y las limitaciones t\u00e9cnicas.</p> <p>Aqu\u00ed hay algunos puntos clave a considerar al aplicar el principio \"Choose The Right Database Solutions\":</p> <ol> <li> <p>Requisitos del proyecto: Comprende los requisitos funcionales y no funcionales del proyecto, incluyendo la cantidad de datos a manejar, la velocidad de lectura y escritura necesaria, los patrones de acceso a los datos y las consultas requeridas. Estos requisitos ayudar\u00e1n a determinar qu\u00e9 caracter\u00edsticas son importantes para la elecci\u00f3n de la base de datos.</p> </li> <li> <p>Modelo de datos: Eval\u00faa el modelo de datos necesario para tu aplicaci\u00f3n. Algunos proyectos se adaptan mejor a bases de datos relacionales, mientras que otros pueden requerir bases de datos NoSQL que permitan una mayor flexibilidad en la estructura de datos.</p> </li> <li> <p>Escalabilidad: Considera la capacidad de escalar horizontal o verticalmente la base de datos para manejar el crecimiento futuro de la aplicaci\u00f3n. Algunas soluciones de bases de datos est\u00e1n dise\u00f1adas espec\u00edficamente para escalabilidad masiva, mientras que otras pueden ser m\u00e1s adecuadas para proyectos m\u00e1s peque\u00f1os.</p> </li> <li> <p>Rendimiento: Eval\u00faa el rendimiento de la base de datos en t\u00e9rminos de velocidad de lectura y escritura, capacidad de respuesta y latencia. Dependiendo de las necesidades de tu aplicaci\u00f3n, algunas bases de datos pueden proporcionar un rendimiento mejorado en comparaci\u00f3n con otras.</p> </li> <li> <p>Consistencia y disponibilidad: Determina si tu aplicaci\u00f3n requiere una base de datos que garantice la consistencia fuerte y la disponibilidad continua. Algunas bases de datos NoSQL pueden ofrecer una mayor disponibilidad, pero a costa de una posible consistencia eventual.</p> </li> <li> <p>Experiencia y soporte: Eval\u00faa la experiencia y el soporte disponibles para la base de datos seleccionada. Es importante considerar la comunidad de usuarios, la documentaci\u00f3n, las actualizaciones y las capacidades de soporte para garantizar un desarrollo y mantenimiento efectivos.</p> </li> <li> <p>Costo: Ten en cuenta los costos asociados con la implementaci\u00f3n y el mantenimiento de la base de datos. Algunas soluciones de bases de datos pueden ser m\u00e1s costosas que otras en t\u00e9rminos de licencias, infraestructura requerida y recursos humanos necesarios para administrar y operar la base de datos.</p> </li> </ol> <p>En resumen, el principio \"Choose The Right Database Solutions\" implica realizar una evaluaci\u00f3n exhaustiva de las necesidades del proyecto y seleccionar la tecnolog\u00eda de base de datos que mejor se adapte a esos requisitos espec\u00edficos. Al tomar decisiones informadas y considerar los factores mencionados anteriormente, puedes asegurarte de tener una base de datos adecuada y optimizada para tu aplicaci\u00f3n o sistema.</p>"},{"location":"cloud/choose_databse/#recomendaciones","title":"Recomendaciones","text":"<p>Recomendaciones para la implementaci\u00f3n de la elecci\u00f3n de la soluci\u00f3n de base de datos adecuada:</p> <ol> <li> <p>Realiza un an\u00e1lisis exhaustivo de requisitos: Antes de elegir una soluci\u00f3n de base de datos, aseg\u00farate de comprender completamente los requisitos funcionales y no funcionales de tu aplicaci\u00f3n. Esto incluye el volumen de datos, la velocidad de acceso, la escalabilidad, la seguridad y cualquier otro requisito espec\u00edfico.</p> </li> <li> <p>Eval\u00faa diferentes opciones: Investiga y eval\u00faa diferentes soluciones de base de datos disponibles en el mercado. Considera tanto las bases de datos relacionales como las NoSQL, y determina cu\u00e1l se ajusta mejor a tus necesidades. Ten en cuenta factores como el modelo de datos, el rendimiento, la escalabilidad y la disponibilidad.</p> </li> <li> <p>Considera la comunidad y el soporte: Opta por una soluci\u00f3n de base de datos con una comunidad activa de usuarios y un buen soporte. Esto garantiza que puedas obtener ayuda y asistencia en caso de enfrentar desaf\u00edos o problemas durante la implementaci\u00f3n y el mantenimiento.</p> </li> <li> <p>Prueba la soluci\u00f3n de base de datos: Antes de comprometerte por completo con una soluci\u00f3n de base de datos, realiza pruebas de concepto y prototipos para evaluar su rendimiento y compatibilidad con tu aplicaci\u00f3n. Esto te ayudar\u00e1 a identificar posibles problemas y asegurarte de que la soluci\u00f3n seleccionada sea la adecuada para tu caso de uso.</p> </li> <li> <p>Considera la escalabilidad: Si prev\u00e9s que tu aplicaci\u00f3n experimentar\u00e1 un crecimiento significativo en el futuro, elige una soluci\u00f3n de base de datos que ofrezca opciones de escalabilidad. Esto te permitir\u00e1 manejar el aumento de carga y garantizar un rendimiento \u00f3ptimo a medida que crece tu aplicaci\u00f3n.</p> </li> <li> <p>Dise\u00f1a una estructura de datos eficiente: Independientemente de la soluci\u00f3n de base de datos que elijas, es importante dise\u00f1ar una estructura de datos eficiente y optimizada. Esto implica definir correctamente los \u00edndices, establecer relaciones adecuadas entre las entidades y utilizar consultas eficientes para acceder y manipular los datos.</p> </li> <li> <p>Mant\u00e9n la seguridad en mente: La seguridad de los datos es de suma importancia en cualquier aplicaci\u00f3n. Aseg\u00farate de que la soluci\u00f3n de base de datos seleccionada ofrezca mecanismos de seguridad robustos, como encriptaci\u00f3n de datos, autenticaci\u00f3n y control de acceso. Adem\u00e1s, sigue las mejores pr\u00e1cticas de seguridad al configurar y administrar la base de datos.</p> </li> <li> <p>Realiza copias de seguridad y planifica la recuperaci\u00f3n de desastres: Implementa un plan s\u00f3lido de copias de seguridad y recuperaci\u00f3n de desastres para proteger tus datos. Aseg\u00farate de realizar copias de seguridad peri\u00f3dicas de la base de datos y prueba la capacidad de recuperaci\u00f3n en caso de fallas o p\u00e9rdidas de datos.</p> </li> <li> <p>Mantente actualizado: Mant\u00e9n tu soluci\u00f3n de base de datos actualizada con las \u00faltimas versiones y parches de seguridad. Esto te ayudar\u00e1 a aprovechar las mejoras y correcciones de errores, as\u00ed como a mantener tu sistema protegido contra vulnerabilidades conocidas.</p> </li> <li> <p>Monitorea y ajusta el rendimiento: Realiza un monitoreo constante del rendimiento de tu base de datos y realiza ajustes seg\u00fan sea necesario. Esto implica identificar cuellos de botella, optimizar consultas, ajustar la configuraci\u00f3n y realizar ajustes en la infraestructura para garantizar un rendimiento \u00f3ptimo.</p> </li> </ol> <p>Recuerda que la elecci\u00f3n de la soluci\u00f3n de base de datos correcta es crucial para el \u00e9xito de tu aplicaci\u00f3n. T\u00f3mate el tiempo necesario para investigar y evaluar tus opciones, y considera consultar con expertos en bases de datos si es necesario.</p>"},{"location":"cloud/disposable/","title":"Use Disposable Resources","text":"<p>El principio \"Use Disposable Resources\" se refiere al enfoque de utilizar recursos desechables en la arquitectura de la nube. Consiste en dise\u00f1ar y construir sistemas de manera que los recursos, como instancias de servidores, contenedores, bases de datos, entre otros, puedan ser f\u00e1cilmente creados, destruidos y reemplazados seg\u00fan sea necesario.</p> <p>El uso de recursos desechables proporciona una serie de beneficios en la arquitectura de la nube:</p> <ol> <li> <p>Eficiencia en costos: Los recursos desechables permiten aprovechar la escalabilidad horizontal y vertical, lo que significa que puedes aumentar o reducir la capacidad seg\u00fan la demanda. Al utilizar recursos solo cuando son necesarios y eliminarlos cuando ya no se necesitan, se evita incurrir en costos innecesarios.</p> </li> <li> <p>Agilidad y flexibilidad: Al poder crear y destruir recursos de manera r\u00e1pida y sencilla, se obtiene una mayor agilidad en la implementaci\u00f3n y adaptaci\u00f3n del sistema. Esto permite responder r\u00e1pidamente a cambios en los requisitos o en la carga de trabajo, y facilita la realizaci\u00f3n de pruebas, experimentos y despliegues frecuentes.</p> </li> <li> <p>Facilidad en la gesti\u00f3n y mantenimiento: Al utilizar recursos desechables, se minimiza la complejidad de la administraci\u00f3n y el mantenimiento a largo plazo. Los recursos pueden ser creados a partir de plantillas predefinidas y configuraciones automatizadas, lo que garantiza una mayor consistencia y reduce el esfuerzo requerido para la administraci\u00f3n.</p> </li> <li> <p>Tolerancia a fallos: Al utilizar recursos desechables, el sistema se vuelve m\u00e1s tolerante a fallos. Si un recurso falla, puede ser reemplazado r\u00e1pidamente por uno nuevo sin afectar significativamente la disponibilidad del sistema. Esto permite una mayor resiliencia y capacidad de recuperaci\u00f3n.</p> </li> </ol> <p>Para aplicar el principio \"Use Disposable Resources\" en la arquitectura de la nube, aqu\u00ed tienes algunas recomendaciones:</p> <ol> <li> <p>Utiliza herramientas de aprovisionamiento y gesti\u00f3n de recursos: Utiliza herramientas como Terraform, Ansible o CloudFormation para definir y aprovisionar recursos de manera program\u00e1tica. Esto permite crear y configurar recursos de forma automatizada y reproducible.</p> </li> <li> <p>Utiliza contenedores: Los contenedores, como Docker, proporcionan un medio eficiente y port\u00e1til para empaquetar aplicaciones y sus dependencias. Los contenedores son f\u00e1cilmente desplegables y pueden ser creados y destruidos r\u00e1pidamente seg\u00fan sea necesario.</p> </li> <li> <p>Implementa la automatizaci\u00f3n del ciclo de vida de los recursos: Utiliza pipelines de CI/CD y scripts de automatizaci\u00f3n para crear, configurar y destruir recursos de manera controlada. Esto asegura que los recursos sean desplegados de manera consistente y que se puedan eliminar de forma segura cuando ya no sean necesarios.</p> </li> <li> <p>Utiliza servicios gestionados: Aprovecha los servicios gestionados ofrecidos por los proveedores de la nube. Estos servicios, como bases de datos gestionadas o servicios de mensajer\u00eda, permiten utilizar recursos desechables sin tener que preocuparte por la administraci\u00f3n y el mantenimiento a nivel de infraestructura.</p> </li> <li> <p>Dise\u00f1a la arquitectura para la resiliencia: Considera la posibilidad de fallos en tus recursos y dise\u00f1a la arquitectura de tu sistema de manera que sea capaz de recuperarse de forma autom</p> </li> </ol> <p>\u00e1tica y r\u00e1pida. Esto puede incluir la utilizaci\u00f3n de grupos de escalado autom\u00e1tico o la replicaci\u00f3n de recursos.</p> <p>Recuerda que el uso de recursos desechables implica un enfoque diferente en comparaci\u00f3n con la gesti\u00f3n tradicional de recursos. Es importante comprender y tener en cuenta los costos asociados con la creaci\u00f3n y destrucci\u00f3n de recursos, as\u00ed como garantizar una correcta gesti\u00f3n y configuraci\u00f3n para evitar fugas de recursos o ineficiencias.</p>"},{"location":"cloud/disposable/#recomendaciones","title":"Recomendaciones","text":"<p>Si est\u00e1s utilizando Kubernetes como plataforma de orquestaci\u00f3n de contenedores en la nube, aqu\u00ed tienes algunas recomendaciones para aplicar el principio \"Use Disposable Resources\" espec\u00edficamente en este contexto:</p> <ol> <li> <p>Utiliza implementaciones declarativas: En lugar de realizar cambios directamente en los recursos en ejecuci\u00f3n, utiliza archivos de configuraci\u00f3n YAML o JSON para describir el estado deseado de tus recursos de Kubernetes, como pods, servicios y despliegues. Esto permite que los recursos sean f\u00e1cilmente reemplazables y replicables.</p> </li> <li> <p>Implementa despliegues y r\u00e9plicas: Utiliza el objeto Deployment de Kubernetes para administrar tus aplicaciones. Los despliegues permiten definir el estado deseado y Kubernetes se encarga de crear y destruir r\u00e9plicas autom\u00e1ticamente para mantener ese estado. Esto facilita la escalabilidad y la recuperaci\u00f3n ante fallos.</p> </li> <li> <p>Utiliza vol\u00famenes y almacenamiento persistente: Para almacenar datos persistentes, utiliza vol\u00famenes y almacenamiento persistente en Kubernetes. Al separar los datos del ciclo de vida de los contenedores, puedes eliminar y recrear los contenedores sin perder los datos almacenados. Esto permite una mayor flexibilidad y agilidad en el manejo de recursos.</p> </li> <li> <p>Aprovecha los servicios de escalado autom\u00e1tico: Kubernetes proporciona la funcionalidad de escalado autom\u00e1tico horizontal, lo que significa que puede ajustar autom\u00e1ticamente el n\u00famero de r\u00e9plicas de tus aplicaciones en funci\u00f3n de la demanda. Aprovecha esta funcionalidad para escalar hacia arriba o hacia abajo seg\u00fan sea necesario, utilizando recursos desechables.</p> </li> <li> <p>Utiliza pol\u00edticas de reinicio y tolerancia a fallos: Configura las pol\u00edticas de reinicio y tolerancia a fallos en Kubernetes para garantizar la disponibilidad continua de tus aplicaciones. Puedes establecer pol\u00edticas de reinicio para que Kubernetes vuelva a intentar iniciar un contenedor si falla, o configurar tolerancia a fallos para que Kubernetes reemplace autom\u00e1ticamente los contenedores que fallan.</p> </li> <li> <p>Implementa pipelines de CI/CD para despliegue automatizado: Utiliza pipelines de integraci\u00f3n y entrega continua (CI/CD) para automatizar el proceso de construcci\u00f3n, prueba y despliegue de tus aplicaciones en Kubernetes. Esto te permite crear y destruir recursos desechables de manera controlada durante el ciclo de vida de tu aplicaci\u00f3n.</p> </li> <li> <p>Realiza pruebas y validaciones regulares: Aseg\u00farate de realizar pruebas y validaciones regulares de tus aplicaciones en Kubernetes. Esto incluye pruebas unitarias, pruebas de integraci\u00f3n y pruebas de estr\u00e9s para asegurarte de que tus recursos desechables funcionen correctamente y cumplan con los requisitos de tu aplicaci\u00f3n.</p> </li> </ol> <p>Recuerda monitorear y gestionar adecuadamente los recursos en Kubernetes para evitar posibles fugas o ineficiencias que puedan afectar el rendimiento y los costos. Mantener un equilibrio entre la escalabilidad y la eficiencia de los recursos desechables es fundamental para aprovechar al m\u00e1ximo Kubernetes y el principio \"Use Disposable Resources\".</p>"},{"location":"cloud/disposable/#ejemplo","title":"Ejemplo","text":"<p>Ejemplo de diagrama para ilustrar un escenario en Kubernetes aplicando el principio \"Use Disposable Resources\":</p> <pre><code>graph LR\n\nsubgraph \"Entorno de Kubernetes\"\n    A[Despliegue 1] --&gt; B[Pod 1.1]\n    A --&gt; C[Pod 1.2]\n    A --&gt; D[Servicio 1]\n    B --&gt; E[Volumen 1]\n    C --&gt; F[Volumen 2]\n    D --&gt; G\nend\n\nsubgraph \"Herramientas de Automatizaci\u00f3n\"\n    H[Pipeline CI/CD] --&gt; A\nend\n\nsubgraph \"Recursos Desechables\"\n    I[Despliegue 2] --&gt; J[Pod 2.1]\n    I --&gt; K[Pod 2.2]\n    I --&gt; L[Servicio 2]\n    J --&gt; M[Volumen 3]\n    K --&gt; N[Volumen 4]\n    L --&gt; O\nend\n</code></pre> <p>En este ejemplo, se muestra un entorno de Kubernetes donde se aplican recursos desechables y automatizaci\u00f3n mediante un pipeline de CI/CD. Aqu\u00ed tienes una descripci\u00f3n de cada componente:</p> <ul> <li>El \"Entorno de Kubernetes\" representa un cl\u00faster de Kubernetes donde se despliegan las aplicaciones.</li> <li>\"Despliegue 1\" es un despliegue inicial con dos pods (Pod 1.1 y Pod 1.2) y un servicio (Servicio 1). Tambi\u00e9n se incluyen vol\u00famenes (Volumen 1 y Volumen 2) para almacenamiento persistente si es necesario.</li> <li>\"Herramientas de Automatizaci\u00f3n\" representa un pipeline de CI/CD que se encarga de implementar y gestionar los recursos en Kubernetes.</li> <li>\"Recursos Desechables\" muestra otro despliegue (Despliegue 2) con dos pods (Pod 2.1 y Pod 2.2) y un servicio (Servicio 2). Tambi\u00e9n se incluyen vol\u00famenes (Volumen 3 y Volumen 4) para almacenamiento persistente si es necesario.</li> </ul> <p>En este escenario, el pipeline de CI/CD (representado por \"Herramientas de Automatizaci\u00f3n\") es responsable de crear y gestionar los despliegues y los recursos en Kubernetes. Permite la f\u00e1cil creaci\u00f3n, actualizaci\u00f3n y eliminaci\u00f3n de recursos desechables, como pods y servicios.</p> <p>Ten en cuenta que este es solo un ejemplo b\u00e1sico y que puedes personalizar y ampliar el diagrama seg\u00fan tus necesidades y configuraciones espec\u00edficas en Kubernetes.</p> <p>Recuerda que Mermaid es una herramienta flexible para la creaci\u00f3n de diagramas y puedes explorar m\u00e1s opciones y elementos para representar de manera efectiva tu arquitectura de Kubernetes y el principio \"Use Disposable Resources\".</p>"},{"location":"cloud/enable_scalability/","title":"Enable Scalability","text":"<p>El principio de arquitectura \"Enable Scalability\" se refiere a la capacidad de una arquitectura en la nube para escalar de manera eficiente y flexible para satisfacer las demandas cambiantes de recursos. La escalabilidad es esencial en los entornos de computaci\u00f3n en la nube, ya que permite que los sistemas se adapten a cargas de trabajo variables, desde picos de tr\u00e1fico hasta aumentos en la demanda de recursos.</p> <p>Hay dos tipos principales de escalabilidad: escalabilidad vertical y escalabilidad horizontal.</p> <p>La escalabilidad vertical implica aumentar los recursos de hardware dentro de una sola instancia o servidor, como agregar m\u00e1s potencia de procesamiento, memoria o capacidad de almacenamiento. Esto puede lograrse a trav\u00e9s de la actualizaci\u00f3n o el reemplazo de componentes f\u00edsicos en el servidor.</p> <p>Por otro lado, la escalabilidad horizontal implica agregar m\u00e1s instancias o servidores a la arquitectura para distribuir la carga de trabajo. Esto se logra mediante la adici\u00f3n de m\u00e1s nodos a un cl\u00faster o mediante la duplicaci\u00f3n de instancias de servidores virtuales.</p> <p>La arquitectura en la nube debe ser dise\u00f1ada de manera que permita una f\u00e1cil escalabilidad, lo que implica considerar varios aspectos:</p> <ol> <li> <p>Dise\u00f1o modular: La arquitectura debe estar compuesta por m\u00f3dulos independientes y desacoplados, lo que permite que cada componente se pueda escalar de forma independiente seg\u00fan sea necesario.</p> </li> <li> <p>Autoescalado: Se deben implementar pol\u00edticas de autoescalado que monitoreen las m\u00e9tricas de rendimiento, como la carga de CPU o la utilizaci\u00f3n de la memoria, y agreguen o eliminen autom\u00e1ticamente recursos seg\u00fan los umbrales predefinidos.</p> </li> <li> <p>Balanceo de carga: La distribuci\u00f3n equitativa de la carga de trabajo entre las instancias escalables es esencial para garantizar un rendimiento \u00f3ptimo. El balanceo de carga se puede lograr mediante el uso de enrutadores o controladores de carga que distribuyen las solicitudes de manera eficiente.</p> </li> <li> <p>Elasticidad: La capacidad de agregar o eliminar recursos de manera din\u00e1mica y autom\u00e1tica en funci\u00f3n de la demanda. Esto permite que la arquitectura se expanda o contraiga seg\u00fan sea necesario para mantener un rendimiento \u00f3ptimo sin intervenci\u00f3n manual.</p> </li> <li> <p>Servicios gestionados: El uso de servicios gestionados de la nube, como bases de datos o sistemas de almacenamiento, puede simplificar la escalabilidad al permitir que los proveedores de la nube administren la infraestructura subyacente y realicen las tareas de escalado de forma transparente.</p> </li> </ol> <p>En resumen, el principio de arquitectura \"Enable Scalability\" se centra en dise\u00f1ar y desarrollar arquitecturas en la nube que puedan escalar de manera eficiente y flexible para adaptarse a las demandas cambiantes de recursos. Esto se logra a trav\u00e9s del dise\u00f1o modular, el autoescalado, el balanceo de carga, la elasticidad y el uso de servicios gestionados. Al habilitar la escalabilidad, las aplicaciones y servicios en la nube pueden adaptarse a cargas de trabajo variables y mantener un rendimiento \u00f3ptimo en todo momento.</p>"},{"location":"cloud/enable_scalability/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Dise\u00f1o modular y desacoplado: Divide tu arquitectura en componentes independientes y desacoplados. Utiliza servicios y microservicios para encapsular la funcionalidad espec\u00edfica y permitir que cada componente se pueda escalar de forma independiente seg\u00fan sea necesario.</p> </li> <li> <p>Utiliza servicios gestionados: Aprovecha los servicios gestionados de la nube, como bases de datos, colas de mensajes y sistemas de almacenamiento. Estos servicios se encargan de la administraci\u00f3n y escalado subyacente, lo que te permite centrarte en el desarrollo de tu aplicaci\u00f3n sin preocuparte por la infraestructura.</p> </li> <li> <p>Implementa pol\u00edticas de autoescalado: Configura pol\u00edticas de autoescalado para monitorear las m\u00e9tricas relevantes, como la carga de CPU, la utilizaci\u00f3n de memoria o el tr\u00e1fico de red. Define umbrales de escalado para agregar o eliminar autom\u00e1ticamente instancias o recursos seg\u00fan la demanda.</p> </li> <li> <p>Dise\u00f1a para la resiliencia: Aseg\u00farate de que tu arquitectura pueda manejar fallas y recuperarse de manera autom\u00e1tica. Utiliza t\u00e9cnicas como la replicaci\u00f3n de instancias y la distribuci\u00f3n de carga para garantizar que los fallos no afecten negativamente el rendimiento y la disponibilidad del sistema.</p> </li> <li> <p>Aplica el principio de \"Infrastructure as Code\" (Infraestructura como C\u00f3digo): Utiliza herramientas de administraci\u00f3n de configuraci\u00f3n y orquestaci\u00f3n, como Terraform o Ansible, para describir tu infraestructura como c\u00f3digo. Esto facilita la creaci\u00f3n y configuraci\u00f3n de recursos escalables y reproducebles de manera consistente.</p> </li> <li> <p>Implementa balanceo de carga: Utiliza balanceadores de carga para distribuir la carga de trabajo entre las instancias escalables. Esto garantiza que los recursos se utilicen de manera eficiente y que los usuarios experimenten un rendimiento \u00f3ptimo.</p> </li> <li> <p>Monitorea y ajusta constantemente: Realiza un seguimiento de las m\u00e9tricas clave de rendimiento y capacidad de tu arquitectura en la nube. Utiliza herramientas de monitoreo y registros para identificar cuellos de botella y realizar ajustes seg\u00fan sea necesario.</p> </li> <li> <p>Prueba el escalado: Realiza pruebas de carga y estr\u00e9s para validar que tu arquitectura puede escalar correctamente y manejar cargas de trabajo intensivas. Esto te permitir\u00e1 identificar posibles problemas de rendimiento o configuraci\u00f3n antes de implementar en producci\u00f3n.</p> </li> </ol> <p>Recuerda que cada arquitectura y aplicaci\u00f3n en la nube es \u00fanica, por lo que es importante adaptar estas recomendaciones a tus necesidades y requisitos espec\u00edficos. Adem\u00e1s, mantente actualizado con las mejores pr\u00e1cticas y las \u00faltimas tecnolog\u00edas en la nube, ya que el campo de la computaci\u00f3n en la nube est\u00e1 en constante evoluci\u00f3n.</p>"},{"location":"cloud/enable_scalability/#ejemplo","title":"Ejemplo","text":"<p>A continuaci\u00f3n te presento un ejemplo de un diagrama para ilustrar un dise\u00f1o de arquitectura en la nube escalable:</p> <pre><code>graph LR\n\nsubgraph \"Arquitectura en la nube\"\n  subgraph \"Capa de Aplicaci\u00f3n\"\n    A[Aplicaci\u00f3n] --&gt; B[Servidor 1]\n    A[Aplicaci\u00f3n] --&gt; C[Servidor 2]\n    A[Aplicaci\u00f3n] --&gt; D[Servidor 3]\n  end\n\n  subgraph \"Capa de Balanceo de Carga\"\n    E[Balanceador de Carga]\n  end\n\n  subgraph \"Capa de Escalabilidad Autom\u00e1tica\"\n    F[Grupo de Autoescalado]\n  end\n\n  subgraph \"Capa de Almacenamiento\"\n    G[Base de Datos]\n  end\nend\n\nsubgraph \"Tr\u00e1fico de Usuarios\"\n  U[Usuarios]\nend\n\nB --&gt; E\nC --&gt; E\nD --&gt; E\nE --&gt; F\nF --&gt; G\nU --&gt; E</code></pre> <p>En este ejemplo, tenemos una arquitectura en la nube compuesta por una capa de aplicaci\u00f3n que consta de tres servidores (Servidor 1, Servidor 2 y Servidor 3) que alojan la aplicaci\u00f3n. Estos servidores est\u00e1n conectados a un balanceador de carga (Balanceador de Carga) que distribuye la carga de trabajo de manera equitativa entre ellos.</p> <p>La capa de escalabilidad autom\u00e1tica (Grupo de Autoescalado) supervisa las m\u00e9tricas de rendimiento y ajusta autom\u00e1ticamente la cantidad de servidores seg\u00fan la demanda. Si la carga aumenta, se agregar\u00e1n instancias adicionales para manejarla, y si la carga disminuye, se reducir\u00e1 el n\u00famero de instancias.</p> <p>Por \u00faltimo, la capa de almacenamiento est\u00e1 representada por una base de datos (Base de Datos) que se encuentra conectada al grupo de autoescalado. Esto asegura que las instancias adicionales de la aplicaci\u00f3n tengan acceso a la misma base de datos y puedan mantener la coherencia de los datos.</p> <p>El tr\u00e1fico de usuarios (Usuarios) se dirige al balanceador de carga, que luego distribuye las solicitudes a los servidores disponibles en funci\u00f3n de la carga y la configuraci\u00f3n del balanceo de carga.</p> <p>Este ejemplo ilustra c\u00f3mo se puede implementar la escalabilidad en una arquitectura en la nube utilizando Mermaid para representar el dise\u00f1o.</p>"},{"location":"cloud/loosely_couple/","title":"Loosely Couple Your Component","text":"<p>El principio \"Loosely Couple Your Components\" (Acoplar los componentes de forma flexible) es un principio de dise\u00f1o de software que promueve la independencia y la baja interdependencia entre los componentes de un sistema. Este principio busca reducir la interacci\u00f3n directa y la dependencia entre los componentes, lo cual mejora la flexibilidad, la mantenibilidad y la escalabilidad del sistema.</p> <p>Al aplicar este principio, los componentes del sistema deben comunicarse entre s\u00ed a trav\u00e9s de interfaces bien definidas y desacopladas. Algunas recomendaciones para lograr un acoplamiento flexible son:</p> <ol> <li> <p>Definir interfaces claras: Los componentes deben comunicarse a trav\u00e9s de interfaces bien definidas y documentadas. Estas interfaces deben ser estables y no deben cambiar con frecuencia para evitar romper la compatibilidad con otros componentes.</p> </li> <li> <p>Evitar dependencias directas: Los componentes deben depender de abstracciones en lugar de implementaciones concretas. Esto se logra utilizando patrones como la inversi\u00f3n de control (IoC) y la inyecci\u00f3n de dependencias (DI), que permiten desacoplar los componentes al pasar las dependencias a trav\u00e9s de interfaces en lugar de crearlas directamente dentro del componente.</p> </li> <li> <p>Minimizar el acoplamiento temporal: El acoplamiento temporal se refiere a la dependencia entre componentes en relaci\u00f3n con el tiempo de ejecuci\u00f3n. Es importante evitar situaciones en las que un componente dependa del estado o el comportamiento de otro componente en un momento espec\u00edfico. En su lugar, se debe utilizar la comunicaci\u00f3n a trav\u00e9s de mensajes o eventos para lograr una comunicaci\u00f3n asincr\u00f3nica y evitar dependencias temporales.</p> </li> <li> <p>Utilizar est\u00e1ndares y protocolos abiertos: Al utilizar est\u00e1ndares y protocolos abiertos, se facilita la interoperabilidad entre los componentes. Esto permite que diferentes componentes desarrollados por diferentes equipos o proveedores se comuniquen de manera eficiente y sin problemas.</p> </li> <li> <p>Aplicar el principio de responsabilidad \u00fanica: Cada componente debe tener una responsabilidad clara y estar enfocado en realizar una tarea espec\u00edfica. Esto ayuda a evitar la mezcla de l\u00f3gica y funcionalidad en un \u00fanico componente, lo que facilita su reutilizaci\u00f3n y evita la propagaci\u00f3n de cambios en todo el sistema.</p> </li> </ol> <p>Al aplicar el principio \"Loosely Couple Your Components\", se logra un sistema m\u00e1s flexible, mantenible y escalable. Los componentes pueden ser modificados, reemplazados o actualizados sin afectar a otros componentes, lo que facilita la evoluci\u00f3n y la adaptaci\u00f3n del sistema a medida que cambian los requisitos y las necesidades del negocio.</p>"},{"location":"cloud/loosely_couple/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Definir interfaces claras y estables: Es fundamental establecer interfaces bien definidas entre los componentes. Estas interfaces deben ser estables y no sufrir cambios frecuentes, de manera que los componentes que dependen de ellas no se vean afectados. Adem\u00e1s, las interfaces deben ser documentadas de manera clara y accesible para todos los equipos involucrados.</p> </li> <li> <p>Utilizar la inversi\u00f3n de control (IoC) y la inyecci\u00f3n de dependencias (DI): Estos patrones de dise\u00f1o permiten desacoplar los componentes, ya que las dependencias se proporcionan a trav\u00e9s de interfaces en lugar de ser creadas directamente dentro de los componentes. Esto facilita la modificaci\u00f3n y el reemplazo de las dependencias, as\u00ed como la prueba unitaria de los componentes de forma aislada.</p> </li> <li> <p>Minimizar las dependencias directas: Es recomendable evitar las dependencias directas entre los componentes. En su lugar, se deben utilizar abstracciones y capas intermedias que act\u00faen como interfaces entre los componentes. Esto permite que los componentes dependan de interfaces y no de implementaciones concretas, lo cual facilita la sustituci\u00f3n de componentes y promueve la modularidad.</p> </li> <li> <p>Utilizar comunicaci\u00f3n asincr\u00f3nica: En lugar de tener una comunicaci\u00f3n directa y sincr\u00f3nica entre componentes, se recomienda utilizar comunicaci\u00f3n asincr\u00f3nica a trav\u00e9s de mensajes o eventos. Esto permite que los componentes act\u00faen de forma independiente y se acoplen de manera flexible. Adem\u00e1s, facilita la escalabilidad y la tolerancia a fallos, ya que los componentes pueden procesar mensajes en paralelo y recuperarse de errores de manera m\u00e1s eficiente.</p> </li> <li> <p>Aplicar el principio de responsabilidad \u00fanica: Cada componente debe tener una responsabilidad clara y estar enfocado en realizar una tarea espec\u00edfica. Esto evita la mezcla de l\u00f3gica y funcionalidad en un solo componente, lo cual facilita su comprensi\u00f3n, reutilizaci\u00f3n y mantenibilidad. Adem\u00e1s, al tener componentes con responsabilidades \u00fanicas, se evita la propagaci\u00f3n de cambios y se mejora la modularidad del sistema.</p> </li> <li> <p>Utilizar est\u00e1ndares y protocolos abiertos: El uso de est\u00e1ndares y protocolos abiertos favorece la interoperabilidad entre componentes y sistemas. Esto permite que diferentes componentes desarrollados por diferentes equipos o proveedores se comuniquen de manera eficiente y sin problemas. Adem\u00e1s, el uso de est\u00e1ndares abiertos promueve la reutilizaci\u00f3n de componentes y la integraci\u00f3n con otras soluciones.</p> </li> </ol> <p>Al seguir estas recomendaciones, se logra un acoplamiento flexible entre los componentes del sistema, lo cual mejora la modularidad, la mantenibilidad y la escalabilidad del sistema. Adem\u00e1s, se facilita la evoluci\u00f3n y la adaptaci\u00f3n del sistema a medida que cambian los requisitos y las necesidades del negocio.</p>"},{"location":"cloud/loosely_couple/#ejemplo","title":"Ejemplo","text":"<p>El principio \"Loosely Couple Your Components\" (Acoplar los componentes de forma flexible) se puede representar visualmente utilizando la herramienta Mermaid. A continuaci\u00f3n, se muestra un diagrama de flujo que ilustra la idea principal del principio:</p> <pre><code>graph LR\nA(Componente A)\nB(Componente B)\nC(Componente C)\nD(Componente D)\n\nA --&gt;|Dependencia| B\nA --&gt;|Dependencia| C\nB --&gt;|Dependencia| D\nC --&gt;|Dependencia| D</code></pre> <p>En este diagrama, los componentes A, B, C y D est\u00e1n representados como nodos, y las flechas indican las dependencias entre ellos. Cada flecha representa una dependencia directa entre dos componentes.</p> <p>El principio de acoplar los componentes de forma flexible se refleja en la estructura del diagrama. En lugar de tener un acoplamiento fuerte, donde los componentes dependen directamente unos de otros, se busca un acoplamiento d\u00e9bil mediante la introducci\u00f3n de dependencias indirectas y mecanismos de comunicaci\u00f3n flexibles.</p> <p>Por ejemplo, en el diagrama, el componente A depende de los componentes B y C, pero en lugar de depender directamente de ellos, se establece una dependencia indirecta a trav\u00e9s de las flechas. Esto permite que el componente A sea independiente de las implementaciones concretas de B y C, y facilita la sustituci\u00f3n y modificaci\u00f3n de los componentes sin afectar a los dem\u00e1s.</p> <p>Del mismo modo, el componente D es dependiente de B y C, pero nuevamente se establecen dependencias indirectas en lugar de acoplamientos directos. Esto permite que D funcione de manera flexible con diferentes implementaciones de B y C, y facilita la modularidad y la evoluci\u00f3n del sistema.</p> <p>En resumen, el diagrama de flujo representa visualmente el principio de acoplar los componentes de forma flexible, mostrando las dependencias indirectas y promoviendo un acoplamiento d\u00e9bil y una comunicaci\u00f3n flexible entre los componentes del sistema.</p>"},{"location":"cloud/no_servers/","title":"Design Services, No Servers","text":"<p>El principio \"Design Services, No Servers\" (Dise\u00f1ar servicios, no servidores) es un enfoque de arquitectura en el desarrollo de aplicaciones que se basa en la creaci\u00f3n de servicios independientes y desacoplados en lugar de depender de servidores monol\u00edticos. Este enfoque se alinea con la arquitectura de microservicios, donde una aplicaci\u00f3n se descompone en componentes m\u00e1s peque\u00f1os y aut\u00f3nomos que se comunican entre s\u00ed a trav\u00e9s de interfaces bien definidas.</p> <p>Aqu\u00ed hay algunas caracter\u00edsticas clave y beneficios asociados con este principio:</p> <ol> <li> <p>Desacoplamiento: Al dise\u00f1ar servicios en lugar de servidores, se logra un alto nivel de desacoplamiento entre los diferentes componentes de una aplicaci\u00f3n. Cada servicio se puede desarrollar, implementar y escalar de forma independiente, lo que permite cambios y actualizaciones m\u00e1s r\u00e1pidas sin afectar a otros servicios.</p> </li> <li> <p>Escalabilidad y rendimiento: Los servicios pueden escalar de manera independiente seg\u00fan sea necesario para satisfacer las demandas cambiantes de la aplicaci\u00f3n. Esto permite un mejor rendimiento y una capacidad de respuesta mejorada, ya que cada servicio puede adaptarse a su carga de trabajo espec\u00edfica.</p> </li> <li> <p>Mantenibilidad: Al separar la l\u00f3gica y la funcionalidad en servicios individuales, el mantenimiento y la depuraci\u00f3n se vuelven m\u00e1s manejables. Los problemas o actualizaciones en un servicio no tienen un impacto directo en otros servicios, lo que facilita la identificaci\u00f3n y resoluci\u00f3n de problemas.</p> </li> <li> <p>Flexibilidad tecnol\u00f3gica: Al dise\u00f1ar servicios independientes, tienes la libertad de utilizar diferentes tecnolog\u00edas y lenguajes de programaci\u00f3n que mejor se adapten a las necesidades espec\u00edficas de cada servicio. Esto te permite aprovechar las fortalezas de cada tecnolog\u00eda sin estar limitado a una \u00fanica pila tecnol\u00f3gica para toda la aplicaci\u00f3n.</p> </li> <li> <p>Reutilizaci\u00f3n: Los servicios pueden ser dise\u00f1ados de manera que sean reutilizables en diferentes aplicaciones o contextos. Esto promueve la modularidad y facilita la integraci\u00f3n con otras aplicaciones o sistemas, lo que lleva a un desarrollo m\u00e1s r\u00e1pido y eficiente.</p> </li> <li> <p>Tolerancia a fallos: Al dise\u00f1ar servicios que se comunican a trav\u00e9s de interfaces, se puede implementar una mayor tolerancia a fallos. Si un servicio falla, otros servicios a\u00fan pueden funcionar y proporcionar funcionalidad b\u00e1sica, evitando la interrupci\u00f3n completa de la aplicaci\u00f3n.</p> </li> </ol> <p>En resumen, el principio \"Design Services, No Servers\" se basa en la idea de construir aplicaciones como un conjunto de servicios independientes en lugar de depender de servidores monol\u00edticos. Este enfoque ofrece beneficios como desacoplamiento, escalabilidad, mantenibilidad y flexibilidad tecnol\u00f3gica, lo que resulta en aplicaciones m\u00e1s robustas y adaptables a medida que evolucionan las necesidades del negocio.</p>"},{"location":"cloud/no_servers/#recomendaciones","title":"Recomendaciones","text":"<p>Al aplicar el principio \"Design Services, No Servers\" en el desarrollo de aplicaciones, aqu\u00ed tienes algunas recomendaciones para tener en cuenta:</p> <ol> <li> <p>Identificar l\u00edmites de dominio y responsabilidades: Analiza y divide la l\u00f3gica de negocio en servicios basados en los l\u00edmites de dominio y las responsabilidades de cada componente. Esto ayuda a definir claramente las funciones y las interacciones entre los servicios.</p> </li> <li> <p>Dise\u00f1ar interfaces claras: Define interfaces bien definidas y claras para cada servicio. Esto incluye el uso de contratos y protocolos de comunicaci\u00f3n est\u00e1ndar, como APIs RESTful o eventos basados en mensajes. Las interfaces deben ser consistentes y f\u00e1ciles de entender para facilitar la interoperabilidad entre los servicios.</p> </li> <li> <p>Desarrollar servicios independientes: Cada servicio debe ser aut\u00f3nomo y desarrollado de manera independiente. Esto significa que cada servicio debe tener su propio c\u00f3digo fuente, repositorio y ciclo de vida de desarrollo. Evita compartir bases de c\u00f3digo o dependencias innecesarias entre los servicios.</p> </li> <li> <p>Utilizar contenedores y orquestadores: Considera el uso de contenedores, como Docker, para empaquetar y distribuir los servicios de manera independiente. Adem\u00e1s, utiliza orquestadores como Kubernetes para administrar y escalar los servicios de manera eficiente.</p> </li> <li> <p>Aplicar principios de dise\u00f1o s\u00f3lidos: Utiliza principios de dise\u00f1o de software como la cohesi\u00f3n, el acoplamiento m\u00ednimo y la responsabilidad \u00fanica al desarrollar los servicios. Esto promueve la modularidad y facilita el mantenimiento y la evoluci\u00f3n de los servicios.</p> </li> <li> <p>Establecer pol\u00edticas de gesti\u00f3n de errores y fallas: Define pol\u00edticas claras para la gesti\u00f3n de errores y fallas en los servicios. Esto incluye estrategias de manejo de excepciones, monitoreo de salud de los servicios y mecanismos de recuperaci\u00f3n ante fallas.</p> </li> <li> <p>Implementar pruebas automatizadas: Aplica pruebas unitarias, pruebas de integraci\u00f3n y pruebas de aceptaci\u00f3n automatizadas para garantizar la calidad de los servicios y la interoperabilidad entre ellos. Esto ayuda a detectar problemas tempranos y asegurar la estabilidad del sistema.</p> </li> <li> <p>Considerar la seguridad: Aseg\u00farate de implementar medidas de seguridad adecuadas en cada servicio, como autenticaci\u00f3n y autorizaci\u00f3n, cifrado de datos y protecci\u00f3n contra ataques comunes.</p> </li> <li> <p>Documentar y comunicar: Documenta claramente la arquitectura y el dise\u00f1o de los servicios, incluyendo las interfaces, las dependencias y las pol\u00edticas de comunicaci\u00f3n. Comunica estas decisiones a todo el equipo de desarrollo y a otros stakeholders relevantes.</p> </li> <li> <p>Evaluar el rendimiento y la escalabilidad: Realiza pruebas de rendimiento y escalabilidad para identificar cuellos de botella y asegurarte de que los servicios pueden manejar la carga esperada. Ajusta y optimiza los servicios seg\u00fan sea necesario.</p> </li> </ol> <p>Recuerda que la implementaci\u00f3n exitosa del principio \"Design Services, No Servers\" requiere un enfoque cuidadoso y una planificaci\u00f3n adecuada. Es importante comprender las necesidades espec\u00edficas del proyecto y adaptar estas recomendaciones seg\u00fan el contexto y los requisitos t\u00e9cnicos.</p>"},{"location":"cloud/no_servers/#ejemplo","title":"Ejemplo","text":"<pre><code>graph TD\n  A[Servicio 1] --&gt;|API RESTful| B[Servicio 2]\n  A[Servicio 1] --&gt;|Eventos| C[Servicio 3]\n  A[Servicio 1] --&gt;|API RESTful| D[Servicio 4]\n  B[Servicio 2] --&gt;|API RESTful| E[Servicio 5]\n  B[Servicio 2] --&gt;|Eventos| F[Servicio 6]\n  C[Servicio 3] --&gt;|Eventos| F[Servicio 6]\n  D[Servicio 4] --&gt;|API RESTful| G[Servicio 7]\n  E[Servicio 5] --&gt;|API RESTful| G[Servicio 7]\n  F[Servicio 6] --&gt;|API RESTful| G[Servicio 7]\n  G[Servicio 7] --&gt;|API RESTful| H[Cliente]\n</code></pre> <p>En este diagrama, cada caja representa un servicio independiente. Las flechas indican la comunicaci\u00f3n entre los servicios a trav\u00e9s de API RESTful o eventos. El servicio final se comunica con un cliente externo.</p> <p>Este diagrama ilustra c\u00f3mo los servicios se comunican entre s\u00ed utilizando interfaces bien definidas en lugar de depender de un servidor centralizado. Cada servicio tiene su propia responsabilidad y se comunica con otros servicios a trav\u00e9s de interfaces claras y est\u00e1ndar.</p> <p>Recuerda que esta es una representaci\u00f3n conceptual y que la implementaci\u00f3n real puede variar dependiendo del contexto y las tecnolog\u00edas utilizadas.</p>"},{"location":"cloud/optimize_cost/","title":"Optimize For Cost Caching","text":"<p>El principio \"Optimize For Cost Caching\" se refiere a la optimizaci\u00f3n del uso de la cach\u00e9 considerando los costos asociados. El objetivo es utilizar la cach\u00e9 de manera eficiente para minimizar los costos de recursos, como el almacenamiento y el tiempo de procesamiento.</p> <p>Aqu\u00ed hay algunas recomendaciones para aplicar este principio:</p> <ol> <li> <p>Identificar los datos adecuados para almacenar en cach\u00e9: No todos los datos son candidatos ideales para la cach\u00e9. Debes analizar qu\u00e9 datos son m\u00e1s utilizados y tienen un impacto significativo en el rendimiento de la aplicaci\u00f3n. Almacenar en cach\u00e9 solo los datos relevantes ayuda a optimizar el uso de recursos.</p> </li> <li> <p>Establecer pol\u00edticas de expiraci\u00f3n: Configura un mecanismo para establecer la expiraci\u00f3n de los datos en la cach\u00e9. Esto garantiza que los datos obsoletos no se mantengan en la cach\u00e9 y ocupen espacio innecesario. Al definir pol\u00edticas de expiraci\u00f3n adecuadas, puedes equilibrar el rendimiento y los costos de almacenamiento.</p> </li> <li> <p>Implementar estrategias de invalidaci\u00f3n de cach\u00e9: Cuando los datos cambian en la fuente de origen, es importante invalidar la cach\u00e9 correspondiente para evitar la entrega de informaci\u00f3n desactualizada. Implementa estrategias de invalidaci\u00f3n de cach\u00e9, como la invalidaci\u00f3n basada en tiempo o eventos, para mantener la integridad de los datos almacenados en cach\u00e9.</p> </li> <li> <p>Utilizar t\u00e9cnicas de compresi\u00f3n de datos: Si los datos almacenados en cach\u00e9 son grandes, considera la posibilidad de aplicar t\u00e9cnicas de compresi\u00f3n para reducir el espacio de almacenamiento requerido. Esto puede ayudar a minimizar los costos asociados con el almacenamiento en la cach\u00e9.</p> </li> <li> <p>Monitorear y ajustar el tama\u00f1o de la cach\u00e9: Realiza un seguimiento del uso de la cach\u00e9 y analiza su efectividad. Si observas que la cach\u00e9 est\u00e1 ocupando demasiado espacio sin un impacto significativo en el rendimiento, puedes ajustar su tama\u00f1o para optimizar los costos. Por otro lado, si la cach\u00e9 se queda constantemente sin espacio y no cumple su prop\u00f3sito, considera aumentar su tama\u00f1o.</p> </li> <li> <p>Evaluar el rendimiento y los costos: Realiza evaluaciones peri\u00f3dicas del rendimiento y los costos asociados con la cach\u00e9. Analiza si los beneficios obtenidos de la cach\u00e9 justifican los recursos y costos involucrados. En algunos casos, es posible que debas reevaluar y ajustar la estrategia de cach\u00e9 para optimizar a\u00fan m\u00e1s los costos.</p> </li> </ol> <p>Al seguir estas recomendaciones, puedes aplicar el principio \"Optimize For Cost Caching\" de manera efectiva, maximizando los beneficios de la cach\u00e9 mientras se minimizan los costos asociados.</p>"},{"location":"cloud/optimize_cost/#recomendaciones","title":"Recomendaciones","text":"<p>Para implementar el principio \"Optimize For Cost Caching\" de manera efectiva, aqu\u00ed tienes algunas recomendaciones:</p> <ol> <li> <p>Realiza un an\u00e1lisis de costos: Antes de implementar la cach\u00e9, realiza un an\u00e1lisis exhaustivo de los costos asociados. Considera el costo de almacenamiento, el costo de procesamiento y cualquier otro costo relacionado con la implementaci\u00f3n y el mantenimiento de la cach\u00e9. Esto te ayudar\u00e1 a tener una idea clara de los beneficios que esperas obtener y a tomar decisiones informadas.</p> </li> <li> <p>Identifica los datos adecuados para almacenar en cach\u00e9: No todos los datos deben ser almacenados en cach\u00e9. Identifica los datos que se acceden con frecuencia y tienen un impacto significativo en el rendimiento de la aplicaci\u00f3n. Estos son los datos que brindar\u00e1n el mayor beneficio al ser almacenados en cach\u00e9.</p> </li> <li> <p>Establece pol\u00edticas de expiraci\u00f3n y refresco: Configura pol\u00edticas de expiraci\u00f3n para los datos en cach\u00e9. Esto asegurar\u00e1 que los datos obsoletos no se mantengan en la cach\u00e9 y ocupen recursos innecesarios. Adem\u00e1s, considera implementar mecanismos de refresco para actualizar los datos en cach\u00e9 de forma peri\u00f3dica o cuando haya cambios en la fuente de datos.</p> </li> <li> <p>Utiliza t\u00e9cnicas de compresi\u00f3n: Si los datos en cach\u00e9 ocupan mucho espacio, considera aplicar t\u00e9cnicas de compresi\u00f3n para reducir los requerimientos de almacenamiento. La compresi\u00f3n puede ayudar a optimizar los costos al reducir el espacio necesario para almacenar los datos en cach\u00e9.</p> </li> <li> <p>Monitorea y ajusta el tama\u00f1o de la cach\u00e9: Realiza un monitoreo regular del rendimiento de la cach\u00e9 y el uso de recursos. Si la cach\u00e9 est\u00e1 ocupando demasiado espacio sin proporcionar un beneficio significativo, considera ajustar su tama\u00f1o para optimizar los costos. Por otro lado, si la cach\u00e9 se queda constantemente sin espacio, puedes aumentar su tama\u00f1o para mejorar el rendimiento.</p> </li> <li> <p>Eval\u00faa y optimiza el rendimiento: Realiza evaluaciones peri\u00f3dicas del rendimiento de la cach\u00e9 y su impacto en los costos. Analiza si los beneficios obtenidos justifican los recursos y costos asociados. Si encuentras \u00e1reas de mejora, considera ajustar la estrategia de cach\u00e9 o explorar otras alternativas para optimizar a\u00fan m\u00e1s los costos.</p> </li> <li> <p>Considera servicios de cach\u00e9 administrados: En lugar de implementar y administrar tu propia soluci\u00f3n de cach\u00e9, considera utilizar servicios de cach\u00e9 administrados en la nube. Estos servicios suelen ofrecer opciones de configuraci\u00f3n flexibles y te liberan de la carga de administrar la infraestructura subyacente, lo que puede resultar en una optimizaci\u00f3n de costos.</p> </li> </ol> <p>Recuerda que la implementaci\u00f3n de la cach\u00e9 debe ser espec\u00edfica para cada caso de uso y depende de las caracter\u00edsticas y requerimientos de tu aplicaci\u00f3n. Es importante realizar pruebas exhaustivas y ajustes iterativos para lograr un equilibrio adecuado entre el rendimiento y los costos.</p>"},{"location":"cloud/secure_infrastructure/","title":"Secure Your Infrastructure Everywhere","text":"<p>El principio \"Secure Your Infrastructure Everywhere\" se refiere a la importancia de implementar medidas de seguridad en todos los niveles de tu infraestructura, desde la red hasta las aplicaciones, para garantizar la protecci\u00f3n de los datos y la prevenci\u00f3n de ataques cibern\u00e9ticos. El objetivo es asegurar que tu infraestructura sea resistente a amenazas y cumpla con los requisitos de seguridad.</p> <p>Aqu\u00ed tienes algunos aspectos clave y recomendaciones para aplicar este principio:</p> <ol> <li> <p>Seguridad en la red: Implementa medidas de seguridad en la capa de red para proteger tu infraestructura contra amenazas externas. Esto puede incluir firewalls, sistemas de detecci\u00f3n y prevenci\u00f3n de intrusiones (IDS/IPS), segmentaci\u00f3n de red, configuraci\u00f3n de acceso seguro y encriptaci\u00f3n de comunicaciones.</p> </li> <li> <p>Gesti\u00f3n de identidad y acceso: Establece un sistema de gesti\u00f3n de identidad y acceso robusto. Utiliza autenticaci\u00f3n de m\u00faltiples factores (MFA), pol\u00edticas de contrase\u00f1as seguras, control de acceso basado en roles (RBAC) y aseg\u00farate de revocar los privilegios de acceso de usuarios que ya no los necesitan.</p> </li> <li> <p>Protecci\u00f3n de datos: Implementa mecanismos de protecci\u00f3n de datos para garantizar la confidencialidad y la integridad de la informaci\u00f3n sensible. Esto puede incluir encriptaci\u00f3n de datos en reposo y en tr\u00e1nsito, t\u00e9cnicas de ofuscaci\u00f3n, control de acceso granular a los datos y copias de seguridad regulares.</p> </li> <li> <p>Seguridad en las aplicaciones: Aseg\u00farate de que tus aplicaciones est\u00e9n protegidas contra vulnerabilidades y ataques comunes. Realiza pruebas de seguridad, como pruebas de penetraci\u00f3n, para identificar posibles puntos d\u00e9biles. Utiliza soluciones de seguridad de aplicaciones, como firewalls de aplicaciones web (WAF) y escaneo de c\u00f3digo fuente, para mitigar riesgos.</p> </li> <li> <p>Monitoreo y detecci\u00f3n de amenazas: Implementa sistemas de monitoreo de seguridad para detectar y responder r\u00e1pidamente a posibles amenazas y ataques. Utiliza herramientas de an\u00e1lisis de registros y eventos, as\u00ed como soluciones de detecci\u00f3n de intrusiones, para identificar patrones de comportamiento malicioso y anomal\u00edas en tiempo real.</p> </li> <li> <p>Actualizaciones y parches: Mant\u00e9n tu infraestructura y tus aplicaciones actualizadas con los \u00faltimos parches de seguridad. Las actualizaciones y los parches suelen solucionar vulnerabilidades conocidas y mejoran la seguridad general del sistema.</p> </li> <li> <p>Educaci\u00f3n y concienciaci\u00f3n: Fomenta una cultura de seguridad entre tu equipo y los usuarios de tu infraestructura. Capacita a tu personal en pr\u00e1cticas de seguridad cibern\u00e9tica, como la prevenci\u00f3n de ataques de phishing, la gesti\u00f3n de contrase\u00f1as seguras y la identificaci\u00f3n de amenazas potenciales.</p> </li> <li> <p>Cumplimiento normativo: Aseg\u00farate de cumplir con los requisitos legales y normativos en materia de seguridad cibern\u00e9tica que apliquen a tu industria. Esto puede incluir el cumplimiento de est\u00e1ndares como el Reglamento General de Protecci\u00f3n de Datos (RGPD) o normas espec\u00edficas de la industria, como la Norma de Seguridad de Datos para la Industria de Tarjetas de Pago (PCI DSS).</p> </li> </ol> <p>Al aplicar estas recomendaciones, estar\u00e1s fortaleciendo la seguridad de tu infra</p> <p>estructura en todos los niveles y reduciendo la probabilidad de violaciones de seguridad. La seguridad debe ser un aspecto integral de tu infraestructura en todos los aspectos, desde el dise\u00f1o hasta la implementaci\u00f3n y el mantenimiento continuo.</p>"},{"location":"cloud/secure_infrastructure/#recomendaciones","title":"Recomendaciones","text":"<p>Aqu\u00ed tienes algunas recomendaciones para aplicar el principio \"Secure Your Infrastructure Everywhere\":</p> <ol> <li> <p>Evaluaci\u00f3n de riesgos: Realiza una evaluaci\u00f3n exhaustiva de los riesgos de seguridad en tu infraestructura. Identifica posibles vulnerabilidades y amenazas, y prior\u00edzalas seg\u00fan su impacto y probabilidad.</p> </li> <li> <p>Pol\u00edticas y est\u00e1ndares de seguridad: Establece pol\u00edticas y est\u00e1ndares de seguridad claros que aborden los requisitos de seguridad en todos los niveles de tu infraestructura. Define reglas para el acceso seguro, el uso de contrase\u00f1as fuertes, la configuraci\u00f3n segura de servidores y servicios, y otras pr\u00e1cticas recomendadas.</p> </li> <li> <p>Seguridad en la red: Implementa firewalls, sistemas de detecci\u00f3n y prevenci\u00f3n de intrusiones (IDS/IPS) y otras medidas de seguridad en tu red. Configura reglas de firewall para permitir solo el tr\u00e1fico necesario y cifra las comunicaciones sensibles.</p> </li> <li> <p>Gesti\u00f3n de identidad y acceso: Utiliza una soluci\u00f3n de gesti\u00f3n de identidad y acceso robusta para administrar y controlar los privilegios de los usuarios. Implementa autenticaci\u00f3n de m\u00faltiples factores (MFA) y aseg\u00farate de que se sigan las mejores pr\u00e1cticas de seguridad al establecer contrase\u00f1as.</p> </li> <li> <p>Protecci\u00f3n de datos: Implementa encriptaci\u00f3n de datos tanto en reposo como en tr\u00e1nsito. Utiliza t\u00e9cnicas de ofuscaci\u00f3n de datos cuando sea necesario. Aseg\u00farate de que los datos se respalden regularmente y que los procedimientos de recuperaci\u00f3n ante desastres est\u00e9n en su lugar.</p> </li> <li> <p>Pruebas de seguridad: Realiza pruebas de seguridad regulares, como pruebas de penetraci\u00f3n y escaneos de vulnerabilidades, para identificar y abordar posibles vulnerabilidades en tu infraestructura. Realiza pruebas antes de implementar nuevas aplicaciones o realizar cambios importantes.</p> </li> <li> <p>Monitoreo y detecci\u00f3n de amenazas: Implementa sistemas de monitoreo y detecci\u00f3n de amenazas para identificar actividades sospechosas y responder r\u00e1pidamente a incidentes de seguridad. Utiliza herramientas de an\u00e1lisis de registros y eventos para detectar anomal\u00edas y establece alertas para notificar eventos de seguridad cr\u00edticos.</p> </li> <li> <p>Educaci\u00f3n y concienciaci\u00f3n: Proporciona capacitaci\u00f3n regular sobre seguridad cibern\u00e9tica a tu personal y promueve una cultura de seguridad. Educa a los usuarios sobre las mejores pr\u00e1cticas de seguridad, como evitar el phishing y el uso seguro de contrase\u00f1as.</p> </li> <li> <p>Mantenerse actualizado: Mantente al tanto de las \u00faltimas vulnerabilidades y amenazas de seguridad. Mant\u00e9n tu infraestructura y tus aplicaciones actualizadas con los \u00faltimos parches de seguridad y actualizaciones.</p> </li> <li> <p>Auditor\u00edas de seguridad: Realiza auditor\u00edas de seguridad peri\u00f3dicas para evaluar la efectividad de tus medidas de seguridad y identificar \u00e1reas de mejora. Realiza revisiones regulares de tu infraestructura para asegurarte de que se cumplan los est\u00e1ndares de seguridad.</p> </li> </ol> <p>Recuerda que la seguridad es un proceso continuo y din\u00e1mico. Debes estar preparado para adaptarte a las nuevas amenazas y actualizar tus medidas de seguridad en consecuencia.</p>"},{"location":"cloud/secure_infrastructure/#ejemplo","title":"Ejemplo","text":"<p>Ejemplo de diagrama  para ilustrar un escenario en el que se aplica el principio \"Secure Your Infrastructure Everywhere\":</p> <pre><code>graph LR\n\nsubgraph \"Red\"\n    A[Firewall] --&gt; B[Balanceador de carga]\n    B --&gt; C[Servidor de Aplicaciones]\n    B --&gt; D[Servidor de Bases de Datos]\n    B --&gt; E[Sistema de Monitoreo]\nend\n\nsubgraph \"Gesti\u00f3n de Identidad y Acceso\"\n    F[Gesti\u00f3n de Identidad y Acceso]\n    F --&gt; C\n    F --&gt; D\nend\n\nsubgraph \"Protecci\u00f3n de Datos\"\n    G[Encriptaci\u00f3n de Datos]\n    G --&gt; D\n    G --&gt; E\nend\n\nsubgraph \"Pruebas de Seguridad\"\n    H[Pruebas de Penetraci\u00f3n]\n    H --&gt; C\n    H --&gt; D\n    H --&gt; E\nend\n\nsubgraph \"Monitoreo y Detecci\u00f3n de Amenazas\"\n    I[Sistema de Monitoreo de Seguridad]\n    I --&gt; E\n    I --&gt; F\nend\n\nsubgraph \"Educaci\u00f3n y Concienciaci\u00f3n\"\n    J[Capacitaci\u00f3n en Seguridad]\n    J --&gt; F\nend\n</code></pre> <p>En este ejemplo, se muestra una infraestructura de TI con varios componentes de seguridad aplicados en diferentes niveles. Aqu\u00ed tienes una descripci\u00f3n de cada componente:</p> <ul> <li> <p>\"Red\" representa la infraestructura de red que incluye un firewall para proteger el tr\u00e1fico entrante, un balanceador de carga para distribuir la carga entre los servidores y servidores de aplicaciones y bases de datos.</p> </li> <li> <p>\"Gesti\u00f3n de Identidad y Acceso\" se encarga de gestionar y controlar los privilegios de acceso de los usuarios. Garantiza que solo los usuarios autorizados puedan acceder a los servidores de aplicaciones y bases de datos.</p> </li> <li> <p>\"Protecci\u00f3n de Datos\" muestra la encriptaci\u00f3n de datos en los servidores de bases de datos y en el sistema de monitoreo. Esto asegura que los datos sensibles est\u00e9n protegidos tanto en reposo como en tr\u00e1nsito.</p> </li> <li> <p>\"Pruebas de Seguridad\" representa las pruebas de penetraci\u00f3n realizadas en los servidores de aplicaciones, bases de datos y el sistema de monitoreo. Estas pruebas ayudan a identificar vulnerabilidades y fortalecer la seguridad de la infraestructura.</p> </li> <li> <p>\"Monitoreo y Detecci\u00f3n de Amenazas\" muestra el sistema de monitoreo de seguridad que supervisa el estado de la infraestructura y detecta posibles amenazas y actividades sospechosas. Tambi\u00e9n est\u00e1 conectado a la gesti\u00f3n de identidad y acceso para detectar intentos de acceso no autorizados.</p> </li> <li> <p>\"Educaci\u00f3n y Concienciaci\u00f3n\" representa la capacitaci\u00f3n en seguridad cibern\u00e9tica que se proporciona a los usuarios y el personal. Esto promueve una cultura de seguridad y conciencia sobre las mejores pr\u00e1cticas de seguridad.</p> </li> </ul> <p>Este diagrama ilustra c\u00f3mo se pueden aplicar medidas de seguridad en diferentes niveles de la infraestructura para garantizar la protecci\u00f3n en todas partes. Recuerda que este es solo un ejemplo b\u00e1sico y puedes personalizar y expandir el diagrama seg\u00fan tus propias configuraciones y requisitos espec\u00edficos.</p>"},{"location":"frontend/automated_tests/","title":"Writing automated tests","text":"<p>El principio \"Writing automated tests\" (Escribir pruebas automatizadas) es una pr\u00e1ctica fundamental en el desarrollo de software, incluyendo el desarrollo frontend. Consiste en escribir y ejecutar pruebas automatizadas para asegurar que el c\u00f3digo de la aplicaci\u00f3n se comporte como se espera y detectar errores antes de que se presenten en producci\u00f3n.</p> <p>En frontend, las pruebas automatizadas se enfocan en verificar el comportamiento de los componentes de la interfaz de usuario, incluyendo su apariencia, interacci\u00f3n y funcionalidad. Algunas herramientas populares para escribir pruebas automatizadas en frontend incluyen Jest, Cypress y Selenium.</p> <p>Escribir pruebas automatizadas en frontend puede ofrecer varios beneficios. Por ejemplo:</p> <ul> <li> <p>Ayuda a detectar errores y problemas de rendimiento en una etapa temprana del desarrollo, lo que puede ahorrar tiempo y costos a largo plazo.</p> </li> <li> <p>Mejora la calidad del c\u00f3digo al requerir que el desarrollador tenga una mejor comprensi\u00f3n del comportamiento esperado de los componentes de la interfaz de usuario.</p> </li> <li> <p>Facilita la colaboraci\u00f3n en el equipo, ya que las pruebas automatizadas pueden ser compartidas y ejecutadas por cualquier miembro del equipo.</p> </li> <li> <p>Permite realizar cambios en el c\u00f3digo de manera m\u00e1s segura, ya que se pueden ejecutar pruebas automatizadas para asegurar que el cambio no rompa ninguna funcionalidad existente.</p> </li> </ul> <p>En resumen, el principio \"Writing automated tests\" es importante en frontend para garantizar la calidad del c\u00f3digo, detectar errores tempranamente y mejorar la colaboraci\u00f3n en el equipo.</p>"},{"location":"frontend/automated_tests/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Supongamos que tenemos un componente React llamado Counter que muestra un n\u00famero y tiene dos botones para aumentar o disminuir ese n\u00famero en uno. Aqu\u00ed est\u00e1 el c\u00f3digo del componente:</p> <pre><code>import React, { useState } from \"react\";\nfunction Counter() {\nconst [count, setCount] = useState(0);\nconst handleIncrement = () =&gt; {\nsetCount(count + 1);\n};\nconst handleDecrement = () =&gt; {\nsetCount(count - 1);\n};\nreturn (\n&lt;div&gt;\n&lt;p&gt;Count: {count}&lt;/p&gt;\n&lt;button onClick={handleIncrement}&gt;Increment&lt;/button&gt;\n&lt;button onClick={handleDecrement}&gt;Decrement&lt;/button&gt;\n&lt;/div&gt;\n);\n}\nexport default Counter;\n</code></pre> <p>Para escribir pruebas automatizadas para este componente con Jest, podemos crear un archivo Counter.test.js en el mismo directorio que el componente con el siguiente c\u00f3digo:</p> <pre><code>import React from \"react\";\nimport { render, fireEvent } from \"@testing-library/react\";\nimport Counter from \"./Counter\";\ntest(\"Counter increments and decrements correctly\", () =&gt; {\nconst { getByText } = render(&lt;Counter /&gt;);\nconst countElement = getByText(/count/i);\nconst incrementButton = getByText(/increment/i);\nconst decrementButton = getByText(/decrement/i);\nexpect(countElement).toHaveTextContent(\"0\");\nfireEvent.click(incrementButton);\nexpect(countElement).toHaveTextContent(\"1\");\nfireEvent.click(decrementButton);\nexpect(countElement).toHaveTextContent(\"0\");\n});\n</code></pre> <p>En este ejemplo, estamos importando las funciones render y fireEvent de @testing-library/react para renderizar el componente y simular eventos de clic en los botones. Luego, utilizamos la funci\u00f3n getByText para obtener los elementos de la interfaz de usuario que necesitamos (el elemento de texto que muestra el conteo y los botones de incremento y decremento). Finalmente, estamos utilizando las funciones expect y toHaveTextContent para asegurarnos de que el conteo se est\u00e9 incrementando y disminuyendo correctamente despu\u00e9s de hacer clic en los botones.</p> <p>Ejecutando esta prueba con Jest, deber\u00eda producir una salida similar a esta: <pre><code> PASS  ./Counter.test.js\n  \u2713 Counter increments and decrements correctly (20 ms)\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\n</code></pre></p>"},{"location":"frontend/avoiding_global_styles/","title":"Avoiding global styles","text":"<p>El principio de \"Avoiding global styles\" hace referencia a evitar el uso de estilos globales en el desarrollo de aplicaciones web, ya que esto puede generar problemas de mantenimiento, escalabilidad y coherencia en el dise\u00f1o.</p> <p>En lugar de utilizar estilos globales, se recomienda utilizar estilos modulares y espec\u00edficos para cada componente o secci\u00f3n de la aplicaci\u00f3n. De esta manera, se pueden evitar conflictos entre estilos y asegurar que cada componente tenga un aspecto coherente y predecible.</p> <p>Adem\u00e1s, esta pr\u00e1ctica puede mejorar la legibilidad del c\u00f3digo y facilitar la identificaci\u00f3n de problemas en el dise\u00f1o o en la aplicaci\u00f3n de estilos.</p> <p>En resumen, el principio de \"Avoiding global styles\" promueve el uso de estilos modulares y espec\u00edficos para cada componente o secci\u00f3n de la aplicaci\u00f3n, lo que puede mejorar la escalabilidad, el mantenimiento y la coherencia del dise\u00f1o en el desarrollo de aplicaciones web.</p>"},{"location":"frontend/avoiding_global_styles/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Utilizar estilos modulares y espec\u00edficos para cada componente o secci\u00f3n de la aplicaci\u00f3n: en lugar de definir estilos globales, se recomienda utilizar estilos espec\u00edficos para cada componente o secci\u00f3n de la aplicaci\u00f3n, lo que puede evitar conflictos entre estilos y mejorar la coherencia del dise\u00f1o.</p> </li> <li> <p>Utilizar preprocesadores CSS: los preprocesadores CSS, como Sass o Less, permiten utilizar variables y mixins para definir estilos modulares y reutilizables, lo que puede facilitar la aplicaci\u00f3n del principio de \"Avoiding global styles\".</p> </li> <li> <p>Utilizar frameworks de componentes: los frameworks de componentes, como React o Vue, proporcionan una forma de definir componentes con estilos espec\u00edficos y encapsulados, lo que puede simplificar la aplicaci\u00f3n del principio de \"Avoiding global styles\".</p> </li> <li> <p>Utilizar nombres de clases espec\u00edficos: al definir clases para los estilos de los componentes, se recomienda utilizar nombres espec\u00edficos y descriptivos, en lugar de utilizar nombres gen\u00e9ricos o globales, lo que puede evitar conflictos entre estilos y mejorar la legibilidad del c\u00f3digo.</p> </li> </ol> <p>En resumen, para aplicar el principio de \"Avoiding global styles\" en el desarrollo de aplicaciones web, se recomienda utilizar estilos modulares y espec\u00edficos para cada componente o secci\u00f3n de la aplicaci\u00f3n, utilizar preprocesadores CSS y frameworks de componentes, y utilizar nombres de clases espec\u00edficos y descriptivos.</p>"},{"location":"frontend/avoiding_global_styles/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Supongamos que tenemos una aplicaci\u00f3n ReactJS con tres componentes: Header, Main y Footer. En lugar de definir estilos globales para todos los componentes, se pueden utilizar estilos espec\u00edficos para cada componente mediante el uso de archivos de estilo separados y m\u00f3dulos de estilo CSS.</p> <p>Por ejemplo, podemos definir los estilos para el componente Header en un archivo de estilo Header.module.css:</p> <p><pre><code>.header {\nbackground-color: #F7F7F7;\nborder-bottom: 1px solid #EAEAEA;\npadding: 20px;\nfont-size: 1.2rem;\n}\n.logo {\nfont-size: 1.5rem;\nfont-weight: bold;\n}\n</code></pre> De esta manera, los estilos definidos en este archivo solo se aplicar\u00e1n al componente Header.</p> <p>Luego, podemos importar los estilos en el componente Header de la siguiente manera:</p> <p><pre><code>import styles from './Header.module.css';\nfunction Header() {\nreturn (\n&lt;div className={styles.header}&gt;\n&lt;h1 className={styles.logo}&gt;My App&lt;/h1&gt;\n&lt;/div&gt;\n);\n}\n</code></pre> De esta forma, los estilos definidos en el archivo Header.module.css se aplicar\u00e1n \u00fanicamente al componente Header.</p> <p>Este mismo enfoque se puede aplicar a los otros componentes (Main y Footer), definiendo estilos espec\u00edficos para cada uno en archivos de estilo separados.</p> <p>En conclusi\u00f3n, al utilizar archivos de estilo separados y m\u00f3dulos de estilo CSS para cada componente en lugar de definir estilos globales, se puede aplicar el principio de \"Avoiding global styles\" en un proyecto ReactJS. Esto permite tener estilos espec\u00edficos para cada componente, lo que puede mejorar la coherencia del dise\u00f1o y evitar conflictos entre estilos.</p>"},{"location":"frontend/dev_components/","title":"Developing components, not screens","text":"<p>El principio \"Developing components, not screens\" se refiere a una pr\u00e1ctica de desarrollo de software que se enfoca en crear componentes reutilizables en lugar de crear soluciones  orientadas a una sola pantalla o vista.</p> <p>Este principio se basa en la idea de que, al crear componentes independientes y modulares, es posible crear una arquitectura de software m\u00e1s flexible y escalable, que permite una mayor reutilizaci\u00f3n del c\u00f3digo y una mayor facilidad para realizar cambios y actualizaciones en el sistema.</p> <p>Al desarrollar componentes en lugar de soluciones orientadas a la pantalla, se pueden crear m\u00f3dulos que sean independientes del contexto en el que se utilicen, lo que permite que puedan ser reutilizados en diferentes partes del sistema sin necesidad de realizar cambios significativos en el c\u00f3digo.</p> <p>Este enfoque tambi\u00e9n permite una mayor separaci\u00f3n de preocupaciones y una mayor cohesi\u00f3n entre los diferentes componentes del sistema, lo que mejora la mantenibilidad del c\u00f3digo y reduce la complejidad general del sistema.</p> <p>En resumen, el principio \"Developing components, not screens\" promueve una arquitectura de software modular y reutilizable que se enfoca en la creaci\u00f3n de componentes independientes en lugar de soluciones monol\u00edticas orientadas a una sola pantalla o vista.</p>"},{"location":"frontend/dev_components/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>A continuaci\u00f3n, se presenta un ejemplo para ilustrar este principio:</p> <pre><code>graph TD\nA[MainApp] --&gt; B[Header]\nA --&gt; C[MainContent]\nA --&gt; D[Footer]\nC --&gt; E[ArticleList]\nC --&gt; F[SideBar]\nE --&gt; G[ArticleCard]\nF --&gt; H[SearchBar]</code></pre> <p>En este ejemplo, se muestra una estructura b\u00e1sica de una aplicaci\u00f3n con un encabezado, contenido principal y un pie de p\u00e1gina. El contenido principal se divide en una lista de art\u00edculos y una barra lateral. Tanto la lista de art\u00edculos como la barra lateral se construyen como componentes reutilizables, donde la lista de art\u00edculos se compone de una serie de tarjetas de art\u00edculos y la barra lateral incluye un componente de barra de b\u00fasqueda.</p> <p>De esta manera, el enfoque est\u00e1 en la creaci\u00f3n de componentes reutilizables y modulares que se pueden utilizar en diferentes partes de la aplicaci\u00f3n en lugar de construir pantallas monol\u00edticas que sean dif\u00edciles de mantener y extender.</p>"},{"location":"frontend/input_strategy/","title":"Having a common user input strategy","text":"<p>El principio de Having a common user input strategy se refiere a la necesidad de mantener una estrategia de entrada de datos coherente en toda la aplicaci\u00f3n. Esto significa que los usuarios deben ser capaces de introducir informaci\u00f3n de la misma manera en todas las secciones de la aplicaci\u00f3n, lo que facilita la interacci\u00f3n y la usabilidad de la misma.</p> <p>Un ejemplo de una estrategia com\u00fan de entrada de datos podr\u00eda ser el uso de formularios en toda la aplicaci\u00f3n. Los formularios permiten a los usuarios introducir informaci\u00f3n de manera estructurada y coherente, y tambi\u00e9n ofrecen una serie de caracter\u00edsticas \u00fatiles, como validaci\u00f3n de datos, sugerencias de autocompletado, entre otros.</p> <p>Adem\u00e1s de los formularios, existen otras formas de mantener una estrategia com\u00fan de entrada de datos en toda la aplicaci\u00f3n. Por ejemplo, el uso de controles de entrada de datos est\u00e1ndar, como casillas de verificaci\u00f3n, botones de opci\u00f3n y men\u00fas desplegables, puede ayudar a los usuarios a sentirse m\u00e1s c\u00f3modos y confiados al interactuar con la aplicaci\u00f3n.</p> <p>Al mantener una estrategia com\u00fan de entrada de datos en toda la aplicaci\u00f3n, se pueden mejorar la usabilidad y la experiencia del usuario, lo que a su vez puede conducir a una mayor satisfacci\u00f3n del usuario y una mayor retenci\u00f3n. Adem\u00e1s, tambi\u00e9n puede ayudar a los desarrolladores a mantener un c\u00f3digo m\u00e1s limpio y organizado, ya que se puede utilizar una biblioteca com\u00fan de componentes de entrada de datos en toda la aplicaci\u00f3n.</p>"},{"location":"frontend/input_strategy/#ux-y-sistema-de-diseno","title":"UX y Sistema de Dise\u00f1o","text":"<p>Tener una estrategia com\u00fan para la entrada de datos puede mejorar la experiencia de usuario en una aplicaci\u00f3n al proporcionar una forma consistente y f\u00e1cil de entender los componetes visuales teniendo asi una linea base grafica com\u00fan. Adem\u00e1s, esto puede reducir el tiempo y el esfuerzo necesarios para desarrollar y mantener la aplicaci\u00f3n, permitiendo que los desarrolladores se centren en mejorar la experiencia del usuario y la funcionalidad de la aplicaci\u00f3n de una manera centrada.</p> <p>Un sistema de dise\u00f1o puede ayudar a establecer y mantener una estrategia com\u00fan de entrada de usuario mediante la definici\u00f3n de patrones de dise\u00f1o estandarizados para elementos de entrada comunes, como campos de texto, botones, men\u00fas desplegables, etc. Estos patrones de dise\u00f1o pueden incluir la ubicaci\u00f3n, el estilo, el tama\u00f1o y la interacci\u00f3n de los elementos de entrada.</p> <p>Al seguir una estrategia com\u00fan de entrada de usuario, se puede mejorar la coherencia de la experiencia del usuario en toda la aplicaci\u00f3n. Los usuarios pueden entender y utilizar m\u00e1s f\u00e1cilmente los diferentes componentes de la interfaz de usuario, lo que puede mejorar la satisfacci\u00f3n del usuario y la usabilidad de la aplicaci\u00f3n. Adem\u00e1s, seguir una estrategia com\u00fan de entrada de usuario puede simplificar el proceso de desarrollo, ya que se puede reutilizar c\u00f3digo y patrones de dise\u00f1o existentes en lugar de tener que crearlos desde cero para cada componente de la interfaz de usuario.</p>"},{"location":"frontend/input_strategy/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<pre><code>graph LR\nA[app] --&gt;|UI library| B[design-system]\nA[app] --&gt;|logic components| C[components]\nC[components] --&gt; D[component-1.js]\nC[components] --&gt; E[component-2.js]\nB[design-system] --&gt; F[forms.js]\nB[design-system] --&gt; G[validations.js]\n</code></pre> <p>En este diagrama, se muestra c\u00f3mo la aplicaci\u00f3n se divide en dos paquetes principales: design-system y components. El paquete design-system contiene la biblioteca de interfaz de usuario (UI) y se utiliza para estandarizar la apariencia y la interacci\u00f3n en toda la aplicaci\u00f3n. El paquete components contiene los componentes l\u00f3gicos de la aplicaci\u00f3n, que se construyen utilizando la biblioteca de interfaz de usuario.</p> <p>La aplicaci\u00f3n app est\u00e1 conectada a ambos paquetes, y cada paquete est\u00e1 conectado a los componentes que lo utilizan. Por ejemplo, el componente-1.js utiliza la biblioteca de botones en design-system para estandarizar la apariencia de los botones en la aplicaci\u00f3n.</p> <p>Este enfoque de separaci\u00f3n de responsabilidades permite una mayor modularidad y reutilizaci\u00f3n de componentes en la aplicaci\u00f3n, lo que puede mejorar la calidad del c\u00f3digo y reducir el tiempo de desarrollo.</p>"},{"location":"frontend/keeping_changelog/","title":"Keeping a changelog","text":"<p>El principio \"Keeping a changelog\" se refiere a la pr\u00e1ctica de mantener un registro detallado y actualizado de los cambios que se realizan en un proyecto. Este registro se conoce como \"changelog\" y sirve como una herramienta importante para la comunicaci\u00f3n y el seguimiento de los cambios a lo largo del tiempo.</p> <p>Un changelog t\u00edpicamente incluye informaci\u00f3n como la fecha de la actualizaci\u00f3n, una descripci\u00f3n breve y clara de los cambios realizados, y cualquier otra informaci\u00f3n relevante para el equipo de desarrollo y los usuarios finales.</p> <p>Mantener un changelog ayuda a garantizar que todos los miembros del equipo est\u00e9n al tanto de los cambios realizados en el proyecto, lo que puede ayudar a evitar conflictos y errores en el futuro. Adem\u00e1s, un changelog claro y detallado puede ayudar a los usuarios a comprender mejor las nuevas funcionalidades y a encontrar soluciones r\u00e1pidas a los problemas.</p> <p>En general, mantener un changelog es una buena pr\u00e1ctica en cualquier proyecto de software, independientemente de si se trata de un proyecto frontend o backend.</p>"},{"location":"frontend/keeping_changelog/#recomendaciones","title":"Recomendaciones","text":"<p>En un proyecto frontend, el principio de mantener un changelog se puede aplicar siguiendo los siguientes pasos:</p> <ol> <li> <p>Establecer una convenci\u00f3n para nombrar las versiones: Es importante establecer una convenci\u00f3n clara para nombrar las diferentes versiones del proyecto. Por ejemplo, se puede utilizar el formato \"vX.Y.Z\", donde \"X\" representa una versi\u00f3n mayor, \"Y\" representa una versi\u00f3n menor y \"Z\" representa una revisi\u00f3n.</p> </li> <li> <p>Crear un archivo para el changelog: El changelog se puede mantener en un archivo separado en el repositorio del proyecto. Es recomendable utilizar un formato claro y estructurado, como Markdown o plain text, para que sea f\u00e1cil de leer y actualizar.</p> </li> <li> <p>Registrar los cambios de forma regular: Cada vez que se realice una actualizaci\u00f3n o se agregue una nueva funcionalidad al proyecto, es importante registrarla en el changelog. Es recomendable incluir la fecha de la actualizaci\u00f3n, una descripci\u00f3n breve y clara de los cambios realizados, y cualquier otra informaci\u00f3n relevante para el equipo de desarrollo y los usuarios finales.</p> </li> <li> <p>Comunicar los cambios a los usuarios: Es importante comunicar los cambios a los usuarios del proyecto. Esto se puede hacer a trav\u00e9s de notas de lanzamiento, actualizaciones en redes sociales o en la documentaci\u00f3n del proyecto.</p> </li> <li> <p>Mantener el changelog actualizado: Es importante mantener el changelog actualizado a medida que se realizan cambios en el proyecto. Esto ayuda a garantizar que todos los miembros del equipo est\u00e9n al tanto de los cambios realizados en el proyecto y que los usuarios finales puedan comprender mejor las nuevas funcionalidades y solucionar r\u00e1pidamente los problemas.</p> </li> </ol> <p>En resumen, mantener un changelog en un proyecto frontend es una buena pr\u00e1ctica que ayuda a mantener un registro detallado y actualizado de los cambios realizados en el proyecto, lo que puede ayudar a evitar conflictos y errores en el futuro y permitir una comunicaci\u00f3n clara y transparente entre los miembros del equipo y los usuarios finales.</p>"},{"location":"frontend/keeping_changelog/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>El principio de \"Keeping a changelog\" se trata de mantener un registro de todos los cambios y actualizaciones que se realizan en el proyecto. Esto permite a los desarrolladores y usuarios tener una mejor comprensi\u00f3n de los cambios que se han realizado, lo que se ha solucionado y las mejoras agregadas.</p> <p>Un ejemplo de c\u00f3mo se podr\u00eda aplicar este principio en un proyecto frontend ser\u00eda:</p> <p>Supongamos que estamos trabajando en un proyecto de desarrollo de una aplicaci\u00f3n web y se ha realizado una nueva actualizaci\u00f3n. Para mantener un registro de los cambios realizados, se podr\u00eda crear un archivo de registro de cambios (changelog) en el directorio ra\u00edz del proyecto.</p> <p>El archivo podr\u00eda tener una estructura similar a esta:</p> <pre><code>## [2.0.0] - 2023-04-01\n### Added\n- Nuevo componente de b\u00fasqueda.\n\n### Changed\n- Mejoras en el rendimiento del componente de inicio.\n\n### Fixed\n- Soluci\u00f3n de errores menores en el componente de perfil.\n\n## [1.0.0] - 2023-03-01\n### Added\n- Componentes de inicio, perfil y registro.\n- Integraci\u00f3n con la API RESTful.\n</code></pre> <p>En este ejemplo, se puede ver que se han registrado todos los cambios realizados desde la versi\u00f3n 1.0.0 hasta la versi\u00f3n 2.0.0 del proyecto, incluyendo la fecha de la actualizaci\u00f3n y las modificaciones realizadas en el c\u00f3digo.</p> <p>Con esta informaci\u00f3n, tanto los desarrolladores como los usuarios pueden comprender r\u00e1pidamente qu\u00e9 cambios se han realizado y cu\u00e1ndo se han implementado. Esto ayuda a mantener el proyecto organizado y facilita la comunicaci\u00f3n y colaboraci\u00f3n entre los miembros del equipo de desarrollo.</p>"},{"location":"frontend/keeping_changelog/#usar-los-logs-de-git","title":"Usar los logs de Git","text":"<p>Una forma com\u00fan de aplicar este principio en un proyecto de frontend es mediante el uso de los logs de git. En git, es posible crear un registro de los cambios realizados en el repositorio del proyecto utilizando el comando git log. Este comando muestra una lista de los commits realizados en orden cronol\u00f3gico inverso, es decir, los cambios m\u00e1s recientes aparecen primero.</p> <p>Para mantener un changelog adecuado en git, es recomendable seguir ciertas convenciones en el mensaje de cada commit. Una forma com\u00fan de hacerlo es utilizando el formato \"tipo: mensaje\". El tipo puede ser una de las siguientes opciones:</p> <ul> <li>feat: Nueva funcionalidad</li> <li>fix: Correcci\u00f3n de un error</li> <li>docs: Cambios en la documentaci\u00f3n</li> <li>style: Cambios en el estilo de c\u00f3digo (sin cambios en la funcionalidad)</li> <li>refactor: Cambios en el c\u00f3digo que no afectan la funcionalidad</li> <li>test: Agregado o modificaci\u00f3n de pruebas</li> <li>chore: Cambios en el proceso de construcci\u00f3n o en herramientas auxiliares</li> </ul> <p>Por ejemplo, un mensaje de commit adecuado podr\u00eda ser: <pre><code>feat: Agregada nueva funcionalidad de b\u00fasqueda\n</code></pre></p> <p>Tambi\u00e9n es recomendable incluir m\u00e1s detalles en el mensaje del commit, como la raz\u00f3n detr\u00e1s de los cambios realizados y cualquier impacto que puedan tener en el proyecto.</p> <p>Al mantener un changelog adecuado utilizando los logs de git, los desarrolladores pueden f\u00e1cilmente revisar los cambios realizados en el proyecto y mantener a los colaboradores y usuarios informados sobre las actualizaciones y mejoras.</p> <p>Para obtener los registros (logs) de Git necesarios para crear un changelog, se puede utilizar el comando git log. Este comando muestra el historial de confirmaciones en un repositorio de Git. Aqu\u00ed hay algunos ejemplos de c\u00f3mo utilizar este comando para obtener los registros necesarios:</p> <ul> <li> <p>Para ver las confirmaciones entre dos etiquetas (tags) en particular:     <pre><code>git log &lt;tag1&gt;...&lt;tag2&gt; --pretty=format:\"%h %s\"\n</code></pre>     Este comando muestra las confirmaciones entre  y  y se muestra en el formato hash commit mensaje. <li> <p>Para ver las confirmaciones en una rama espec\u00edfica:     <pre><code>git log &lt;branch&gt; --pretty=format:\"%h %s\"\n</code></pre>     Este comando muestra las confirmaciones en la rama especificada y se muestra en el formato hash commit mensaje.</p> </li> <li> <p>Para ver las confirmaciones entre dos fechas espec\u00edficas:     <pre><code>git log --after=\"&lt;fecha1&gt;\" --before=\"&lt;fecha2&gt;\" --pretty=format:\"%h %s\"\n</code></pre>     Este comando muestra las confirmaciones entre  y  y se muestra en el formato hash commit mensaje. <p>Despu\u00e9s de obtener los registros de Git necesarios, se puede crear un archivo de changelog utilizando esta informaci\u00f3n y formatearla de una manera f\u00e1cil de leer y entender para los usuarios finales. Por lo general, los archivos de changelog incluyen informaci\u00f3n sobre las caracter\u00edsticas nuevas, mejoras y correcciones de errores implementadas en cada versi\u00f3n del software.</p>"},{"location":"frontend/linters_formatters/","title":"Using linters and formatters","text":"<p>El principio \"Using linters and formatters\" se refiere al uso de herramientas de software que ayudan a garantizar que el c\u00f3digo est\u00e9 escrito de manera consistente y siga las convenciones de estilo definidas. Un linter es una herramienta que analiza el c\u00f3digo para detectar errores de sintaxis y estilo, mientras que un formatter es una herramienta que formatea autom\u00e1ticamente el c\u00f3digo seg\u00fan un conjunto de reglas predefinidas.</p> <p>Al utilizar linters y formatters, se puede mejorar la calidad del c\u00f3digo, hacer que sea m\u00e1s f\u00e1cil de leer y mantener, y evitar errores comunes de programaci\u00f3n. Adem\u00e1s, se puede garantizar que el c\u00f3digo siga las convenciones de estilo definidas por el equipo de desarrollo, lo que puede ayudar a mantener la coherencia y la claridad en todo el c\u00f3digo base.</p> <p>En general, el uso de linters y formatters es una buena pr\u00e1ctica de desarrollo de software en todos los lenguajes de programaci\u00f3n, incluyendo el frontend. Las herramientas de linter y formatter m\u00e1s populares en el mundo frontend incluyen ESLint y Prettier para JavaScript y TypeScript, Stylelint para CSS y SCSS, y TSLint para TypeScript.</p> <p>Es importante destacar que, aunque estas herramientas son \u00fatiles, no deben ser utilizadas como una soluci\u00f3n m\u00e1gica para garantizar la calidad del c\u00f3digo. Todav\u00eda es necesario que los desarrolladores revisen el c\u00f3digo y realicen pruebas para detectar errores y garantizar que el c\u00f3digo est\u00e9 funcionando correctamente.</p>"},{"location":"frontend/linters_formatters/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Seleccionar una herramienta de linter y formatter adecuada para el lenguaje y el framework utilizado en el proyecto. Algunas de las herramientas mencionadas anteriormente, como ESLint y Prettier, son compatibles con m\u00faltiples lenguajes y frameworks.</p> </li> <li> <p>Configurar las reglas de linter y formatter seg\u00fan las convenciones de estilo y buenas pr\u00e1cticas definidas por el equipo de desarrollo. Estas reglas pueden incluir la longitud m\u00e1xima de l\u00ednea, la indentaci\u00f3n, la presencia de espacios en blanco y otros aspectos de estilo.</p> </li> <li> <p>Integrar la herramienta de linter y formatter en el flujo de trabajo de desarrollo, preferiblemente utilizando herramientas de automatizaci\u00f3n de tareas como Gulp o Grunt. Esto permitir\u00e1 que el c\u00f3digo sea analizado y formateado autom\u00e1ticamente durante el proceso de construcci\u00f3n.</p> </li> <li> <p>Realizar pruebas en el c\u00f3digo para detectar y corregir errores de sintaxis y estilo, utilizando la herramienta de linter y formatter como gu\u00eda.</p> </li> <li> <p>Realizar revisiones de c\u00f3digo y discutir las reglas y convenciones de estilo con otros miembros del equipo de desarrollo para mantener la coherencia y la calidad en todo el c\u00f3digo base.</p> </li> </ol> <p>Al seguir estos pasos, el uso de linters y formatters puede ayudar a mejorar la calidad y la consistencia del c\u00f3digo en el proyecto de frontend.</p>"},{"location":"frontend/linters_formatters/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Para utilizar linters y formatters en un proyecto de ReactJS, podemos seguir los siguientes pasos:</p> <ol> <li>Instalar las herramientas ESLint y Prettier como dependencias de desarrollo en nuestro proyecto:     <pre><code>npm install eslint prettier --save-dev\n</code></pre></li> <li> <p>Crear los archivos de configuraci\u00f3n para cada herramienta. Por ejemplo, podemos crear un archivo .eslintrc.json con las reglas de ESLint:</p> <p><pre><code>{\n\"extends\": [\"eslint:recommended\", \"plugin:react/recommended\"],\n\"parserOptions\": {\n\"ecmaVersion\": 2018,\n\"sourceType\": \"module\",\n\"ecmaFeatures\": {\n\"jsx\": true\n}\n},\n\"plugins\": [\"react\"],\n\"rules\": {\n\"react/prop-types\": \"off\"\n}\n}\n</code></pre> Y un archivo .prettierrc.json con las reglas de Prettier:</p> <pre><code>{\n\"singleQuote\": true,\n\"trailingComma\": \"es5\"\n}\n</code></pre> </li> <li> <p>Configurar nuestro editor de c\u00f3digo para que utilice estas herramientas. Por ejemplo, podemos instalar una extensi\u00f3n de ESLint y configurarla para que utilice nuestro archivo .eslintrc.json. Y tambi\u00e9n podemos instalar una extensi\u00f3n de Prettier y configurarla para que utilice nuestro archivo .prettierrc.json.</p> </li> <li> <p>Ejecutar las herramientas en nuestro c\u00f3digo para detectar errores y corregirlos. Por ejemplo, podemos utilizar el siguiente comando para ejecutar ESLint:     <pre><code>npx eslint src\n</code></pre>     Y utilizar el siguiente comando para ejecutar Prettier:     <pre><code>npx prettier --write src\n</code></pre></p> </li> <li> <p>Configurar nuestro proyecto para que las herramientas se ejecuten autom\u00e1ticamente en el c\u00f3digo al guardar o al realizar un commit. Por ejemplo, podemos utilizar una herramienta como Husky para configurar un pre-commit hook que ejecute ESLint y Prettier.</p> </li> </ol>"},{"location":"frontend/responsive_design/","title":"Responsive Design","text":"<p>El principio de dise\u00f1o responsivo (Responsive Design) se refiere a la habilidad de un sitio web o aplicaci\u00f3n para adaptarse y responder al tama\u00f1o de pantalla y al dispositivo en el que se est\u00e1 visualizando.</p> <p>En la actualidad, existen una gran cantidad de dispositivos diferentes con diferentes tama\u00f1os de pantalla, como computadoras de escritorio, laptops, tablets, smartphones, televisores inteligentes, entre otros. Por lo tanto, el dise\u00f1o responsivo busca garantizar que la experiencia de usuario sea \u00f3ptima independientemente del dispositivo que se est\u00e9 utilizando.</p> <p>Para aplicar este principio en el desarrollo de aplicaciones web o m\u00f3viles, se utilizan t\u00e9cnicas como el dise\u00f1o fluido, las media queries, el uso de im\u00e1genes y fuentes flexibles, entre otros. Todo esto se hace para que el contenido se ajuste al tama\u00f1o de la pantalla del dispositivo, se visualice correctamente y no se pierda informaci\u00f3n importante.</p> <p>El dise\u00f1o responsivo no solo mejora la experiencia del usuario, sino que tambi\u00e9n es importante para el SEO (Search Engine Optimization) ya que los motores de b\u00fasqueda, como Google, dan preferencia a los sitios web que est\u00e1n optimizados para dispositivos m\u00f3viles.</p> <p>En resumen, el dise\u00f1o responsivo es un principio fundamental en el desarrollo frontend y es importante que los desarrolladores tengan en cuenta este principio al dise\u00f1ar y desarrollar aplicaciones web o m\u00f3viles para garantizar una experiencia de usuario \u00f3ptima y mejorar el posicionamiento de sus sitios en los motores de b\u00fasqueda.</p>"},{"location":"frontend/responsive_design/#recomendaciones","title":"Recomendaciones","text":"<ul> <li> <p>Utilizar un dise\u00f1o fluido: en lugar de establecer anchos fijos para los elementos de la p\u00e1gina, se deben utilizar porcentajes o medidas relativas para que el dise\u00f1o se adapte a diferentes tama\u00f1os de pantalla.</p> </li> <li> <p>Emplear media queries: las media queries permiten cambiar el estilo de la p\u00e1gina seg\u00fan el tama\u00f1o de la pantalla. Por ejemplo, se pueden definir estilos espec\u00edficos para dispositivos m\u00f3viles, tablets y computadoras de escritorio.</p> </li> <li> <p>Dise\u00f1ar para dispositivos m\u00f3viles primero: esto implica que el dise\u00f1o debe pensarse primero para pantallas peque\u00f1as, como las de los smartphones, y luego adaptarse a tama\u00f1os m\u00e1s grandes.</p> </li> <li> <p>*tilizar im\u00e1genes y fuentes flexibles: se deben utilizar im\u00e1genes y fuentes que se adapten al tama\u00f1o de la pantalla, evitando que se pierda informaci\u00f3n importante.</p> </li> <li> <p>Testear en diferentes dispositivos: es importante realizar pruebas en diferentes dispositivos para garantizar que la p\u00e1gina se visualiza correctamente en todos ellos.</p> </li> <li> <p>Utilizar herramientas de desarrollo responsivo: existen diversas herramientas que permiten simular diferentes tama\u00f1os de pantalla y comprobar c\u00f3mo se ver\u00e1 la p\u00e1gina en diferentes dispositivos.</p> </li> <li> <p>Siguiendo estas pr\u00e1cticas, se puede lograr un dise\u00f1o responsivo y adaptativo que garantice una buena experiencia de usuario en cualquier dispositivo y tama\u00f1o de pantalla.</p> </li> </ul>"},{"location":"frontend/responsive_design/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Supongamos que estamos desarrollando una p\u00e1gina web para una tienda de productos electr\u00f3nicos. Para aplicar el principio de dise\u00f1o responsivo, podemos seguir los siguientes pasos:</p> <ol> <li>Utilizar un dise\u00f1o fluido: en lugar de establecer anchos fijos para los elementos de la p\u00e1gina, se pueden utilizar porcentajes o medidas relativas para que el dise\u00f1o se adapte a diferentes tama\u00f1os de pantalla.</li> </ol> <p><pre><code>&lt;section class=\"product\"&gt;\n&lt;div class=\"product-image\"&gt;\n&lt;img src=\"product-image.png\" alt=\"Product Image\"&gt;\n&lt;/div&gt;\n&lt;div class=\"product-details\"&gt;\n&lt;h2 class=\"product-title\"&gt;Smartphone XYZ&lt;/h2&gt;\n&lt;p class=\"product-description\"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed aliquam, dolor eget eleifend bibendum, tellus lorem pulvinar purus, vel bibendum lectus felis vitae odio. &lt;/p&gt;\n&lt;p class=\"product-price\"&gt;$499.99&lt;/p&gt;\n&lt;button class=\"btn btn-primary\"&gt;Add to Cart&lt;/button&gt;\n&lt;/div&gt;\n&lt;/section&gt;\n/* Estilos CSS */\n.product {\ndisplay: flex;\nflex-wrap: wrap;\n}\n.product-image {\nwidth: 100%;\nmax-width: 50%;\nbox-sizing: border-box;\npadding: 0 20px;\n}\n.product-details {\nwidth: 100%;\nmax-width: 50%;\nbox-sizing: border-box;\npadding: 0 20px;\n}\n@media screen and (max-width: 767px) {\n.product {\nflex-direction: column;\n}\n.product-image,\n.product-details {\nmax-width: 100%;\npadding: 0;\n}\n}\n</code></pre> En este ejemplo, utilizamos flexbox para que el contenedor .product se adapte al ancho de la pantalla. Adem\u00e1s, utilizamos porcentajes y max-width para que los elementos .product-image y .product-details se distribuyan en un 50% del ancho del contenedor en pantallas grandes, y ocupen todo el ancho en pantallas peque\u00f1as (gracias a la media query).</p> <ol> <li> <p>Emplear media queries: las media queries permiten cambiar el estilo de la p\u00e1gina seg\u00fan el tama\u00f1o de la pantalla. Por ejemplo, se pueden definir estilos espec\u00edficos para dispositivos m\u00f3viles, tablets y computadoras de escritorio. En el ejemplo anterior, utilizamos una media query para aplicar estilos espec\u00edficos a pantallas peque\u00f1as (menores de 767px de ancho).</p> </li> <li> <p>Dise\u00f1ar para dispositivos m\u00f3viles primero: esto implica que el dise\u00f1o debe pensarse primero para pantallas peque\u00f1as, como las de los smartphones, y luego adaptarse a tama\u00f1os m\u00e1s grandes.  En nuestro ejemplo, empezamos por definir el dise\u00f1o para pantallas grandes y luego utilizamos la media query para ajustarlo a pantallas peque\u00f1as. Sin embargo, se recomienda empezar por dise\u00f1ar para pantallas peque\u00f1as y luego adaptar a pantallas grandes.</p> </li> <li> <p>Utilizar im\u00e1genes y fuentes flexibles: se deben utilizar im\u00e1genes y fuentes que se adapten al tama\u00f1o de la pantalla, evitando que se pierda informaci\u00f3n importante. Para este ejemplo, utilizamos la propiedad max-width para que la imagen del producto se ajuste al ancho del contenedor .product-image.</p> </li> <li> <p>Testear en diferentes dispositivos: es importante realizar pruebas en diferentes dispositivos para garantizar que la p\u00e1gina se visualiza correctamente en todos ellos. Es recomendable probar la p\u00e1gina en diferentes dispositivos, navegadores y sistemas oper</p> </li> </ol>"},{"location":"frontend/separating/","title":"Separating presentational and business/controller layer","text":"<p>El principio Separating presentational and business/controller layer (Separaci\u00f3n de la capa de presentaci\u00f3n y la capa de negocio/controlador) en frontend se refiere a la separaci\u00f3n clara de las responsabilidades entre la capa de presentaci\u00f3n y la capa de negocio o controlador en la aplicaci\u00f3n web o m\u00f3vil. En t\u00e9rminos simples, este principio sugiere que la l\u00f3gica empresarial y de controlador no debe mezclarse con la capa de presentaci\u00f3n, como HTML, CSS y JavaScript.</p> <p>La separaci\u00f3n de la capa de presentaci\u00f3n y la capa de negocio/controlador permite una mayor modularidad y reutilizaci\u00f3n del c\u00f3digo. Tambi\u00e9n facilita la tarea de realizar cambios y actualizaciones en la l\u00f3gica empresarial sin tener que modificar la capa de presentaci\u00f3n.</p> <p>En la pr\u00e1ctica, esto se logra utilizando patrones de dise\u00f1o como MVC (Modelo-Vista-Controlador) o MVVM (Modelo-Vista-Modelo de vista). En estos patrones, la capa de presentaci\u00f3n se encarga de mostrar los datos y eventos de usuario a la capa de controlador o modelo, que procesa y manipula los datos seg\u00fan la l\u00f3gica empresarial. Los cambios en los datos se reflejan en la vista a trav\u00e9s del modelo o del controlador.</p>"},{"location":"frontend/separating/#ejemplo","title":"Ejemplo","text":"<p>Para aplicar el principio de Separating presentational and business/controller layer en un SPA, se puede utilizar el patr\u00f3n de arquitectura de Componentes Container y Componentes Presentacionales.</p> <p>Los Componentes Presentacionales se encargan \u00fanicamente de la presentaci\u00f3n y la visualizaci\u00f3n de la informaci\u00f3n, mientras que los Componentes Container se encargan de la l\u00f3gica de negocio y la integraci\u00f3n con los servicios y API.</p> <p>A continuaci\u00f3n, se muestra un ejemplo de c\u00f3mo se podr\u00eda estructurar una aplicaci\u00f3n de ReactJS aplicando este principio:</p> <pre><code>graph LR\nA[App] --&gt; B[Container 1]\nB --&gt; C[Presentation Component 1]\nB --&gt; D[Presentation Component 2]\nB --&gt; E[API Service]\nA --&gt; F[Container 2]\nF --&gt; G[Presentation Component 3]\nF --&gt; H[Presentation Component 4]\nF --&gt; E[API Service]</code></pre> <p>En este ejemplo, la aplicaci\u00f3n se divide en dos Componentes Container principales (B y F), cada uno con sus propios Componentes Presentacionales (C, D, G y H) y utilizando un \u00fanico servicio de API compartido (E).</p> <p>Los Componentes Presentacionales se centran en la presentaci\u00f3n de datos y se pueden reutilizar en m\u00faltiples Componentes Container, mientras que los Componentes Container se centran en la l\u00f3gica de negocio y la integraci\u00f3n con los servicios externos.</p> <p>De esta manera, se logra una separaci\u00f3n clara entre la capa de presentaci\u00f3n y la capa de negocio/controlador, lo que permite una mayor flexibilidad y facilidad de mantenimiento a largo plazo.</p>"},{"location":"frontend/separating/#gestion-de-estados","title":"Gesti\u00f3n de estados","text":"<p>Los estados centralizados favorece el principio de Separating presentational and business/controller layer en frontend ya que promueve la separaci\u00f3n de la l\u00f3gica de presentaci\u00f3n y la l\u00f3gica de negocio mediante el uso de un store global para manejar el estado de la aplicaci\u00f3n.</p> <p>La l\u00f3gica de negocio se puede maneja en con reducers y acciones, mientras que la l\u00f3gica de presentaci\u00f3n se maneja con estados locales. Los componentes solo acceden al estado de la aplicaci\u00f3n a trav\u00e9s de argumentos o propiedades y disparan acciones para actualizar el estado.</p>"},{"location":"frontend/separating/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Aqu\u00ed te dejo un ejemplo de c\u00f3mo se podr\u00eda representar este principio de Separating presentational and business/controller layer:</p>"},{"location":"frontend/separating/#sincrono","title":"Sincrono","text":"<pre><code>graph LR;\n  A[Componente Presentacional] --&gt;|Eventos| B[Componente de Controlador]\n  B --&gt; |Actualiza| A\n  B --&gt; |Acciones| C(Logica/store global)\n  C --&gt; |Estados| B</code></pre>"},{"location":"frontend/separating/#asincrono","title":"Asincrono","text":"<pre><code>graph LR;\n  A[Componente Presentacional] --&gt;|Eventos| B[Componente de Controlador]\n  B --&gt; |Actualiza| A\n  C(Logica/store global) --&gt; |Estados| B\n  B --&gt; |Llamadas| D(Servicio de API)\n  D --&gt; |Acciones|C</code></pre> <p>En este caso particular, el componente de presentaci\u00f3n env\u00eda eventos al componente controlador, cuya funci\u00f3n es ejecutar acciones para actualizar el almacenamiento de estados que maneja la l\u00f3gica de negocio. La l\u00f3gica  devuelve nuevos estados que se actualizan en la presentaci\u00f3n seg\u00fan las decisiones del controlador. Adem\u00e1s, el controlador realiza llamadas a los servicios de API y espera su respuesta para luego ejecutar acciones hacia la l\u00f3gica o almacenamiento de estados, lo que permite actualizar los estados a nivel de representaci\u00f3n.</p> <p>De esta forma, se separa claramente la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio y se favorece el principio de Separating presentational and business/controller layer.</p>"},{"location":"frontend/standardized_fetching/","title":"Using a standardized way of fetching the data","text":"<p>El principio Using a standardized way of fetching the data hace referencia a la importancia de tener un enfoque consistente y estandarizado para la recuperaci\u00f3n de datos en una aplicaci\u00f3n web.</p> <p>En general, existen varias formas de obtener datos en una aplicaci\u00f3n web, como por ejemplo: haciendo peticiones HTTP a un servidor, usando APIs, o a trav\u00e9s de bases de datos. Es importante tener un enfoque estandarizado para la recuperaci\u00f3n de datos, ya que esto ayuda a mejorar la eficiencia y la confiabilidad de la aplicaci\u00f3n.</p> <p>Un enfoque estandarizado para la recuperaci\u00f3n de datos puede incluir la implementaci\u00f3n de patrones de dise\u00f1o como el patr\u00f3n de arquitectura MVC (Modelo-Vista-Controlador), que separa la l\u00f3gica de la aplicaci\u00f3n en capas diferentes y asigna responsabilidades espec\u00edficas a cada una de ellas. En este patr\u00f3n, la capa del modelo se encarga de manejar la recuperaci\u00f3n de datos, mientras que la capa del controlador se encarga de procesar y manipular esos datos.</p> <p>Adem\u00e1s, es com\u00fan utilizar frameworks o librer\u00edas que implementan este enfoque estandarizado de recuperaci\u00f3n de datos, como por ejemplo React, Vue o Angular, que utilizan la librer\u00eda Axios para manejar las peticiones HTTP y la recuperaci\u00f3n de datos.</p> <p>Al utilizar un enfoque estandarizado para la recuperaci\u00f3n de datos, se puede reducir la cantidad de c\u00f3digo redundante en la aplicaci\u00f3n, hacerla m\u00e1s f\u00e1cil de mantener y mejorar su escalabilidad. Tambi\u00e9n se puede mejorar la calidad del c\u00f3digo, ya que se sigue un patr\u00f3n com\u00fan y probado para manejar los datos en la aplicaci\u00f3n.</p>"},{"location":"frontend/standardized_fetching/#ejemplo","title":"Ejemplo","text":"<p>Supongamos que estamos construyendo una aplicaci\u00f3n web de comercio electr\u00f3nico que necesita mostrar una lista de productos a los usuarios. Para hacer esto, necesitamos recuperar los datos de los productos desde el servidor.</p> <p>En lugar de escribir c\u00f3digo para hacer peticiones HTTP a un servidor para recuperar los datos de los productos en cada componente de nuestra aplicaci\u00f3n, podr\u00edamos crear un m\u00f3dulo o una clase en JavaScript que se encargue de recuperar los datos de los productos de manera estandarizada.</p> <p>Por ejemplo, podr\u00edamos crear un archivo llamado \"productService.js\" que exporte una clase \"ProductService\" que se encargue de recuperar los datos de los productos desde el servidor utilizando una API RESTful. La clase podr\u00eda tener m\u00e9todos como \"getAllProducts\" para recuperar todos los productos, \"getProductById\" para recuperar un producto por su identificador y \"addProduct\" para agregar un nuevo producto al servidor.</p> <p>Aqu\u00ed hay un ejemplo de c\u00f3mo se podr\u00eda implementar la clase ProductService utilizando la librer\u00eda Axios para realizar peticiones HTTP:</p> <pre><code>import axios from 'axios';\nclass ProductService {\nasync getAllProducts() {\nconst response = await axios.get('/api/products');\nreturn response.data;\n}\nasync getProductById(productId) {\nconst response = await axios.get(`/api/products/${productId}`);\nreturn response.data;\n}\nasync addProduct(product) {\nconst response = await axios.post('/api/products', product);\nreturn response.data;\n}\n}\nexport default new ProductService();\n</code></pre> <p>Luego, en cualquier componente de nuestra aplicaci\u00f3n que necesite mostrar una lista de productos, simplemente tendr\u00edamos que importar el m\u00f3dulo ProductService y llamar al m\u00e9todo getAllProducts. Por ejemplo:</p> <pre><code>import React, { useState, useEffect } from 'react';\nimport ProductService from './productService';\nfunction ProductList() {\nconst [products, setProducts] = useState([]);\nuseEffect(() =&gt; {\nasync function fetchProducts() {\nconst products = await ProductService.getAllProducts();\nsetProducts(products);\n}\nfetchProducts();\n}, []);\nreturn (\n&lt;ul&gt;\n{products.map((product) =&gt; (\n&lt;li key={product.id}&gt;{product.name}&lt;/li&gt;\n))}\n&lt;/ul&gt;\n);\n}\nexport default ProductList;\n</code></pre> <p>En este ejemplo, estamos utilizando el m\u00e9todo getAllProducts de ProductService para recuperar los datos de los productos en el componente ProductList. Al hacerlo de esta manera, estamos utilizando un enfoque estandarizado y coherente para la recuperaci\u00f3n de datos en toda nuestra aplicaci\u00f3n, lo que ayuda a mejorar la eficiencia y la confiabilidad de la misma.</p>"},{"location":"frontend/standardized_fetching/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p><pre><code>graph TD;\n  A[Componente1] &lt;--&gt; |Petici\u00f3n|B[Servicio];\n  F[Componente2] &lt;--&gt; |Petici\u00f3n|B[Servicio];\n  B --&gt; |Request|C[API];\n  C --&gt; |Response|B;\n</code></pre> El componente hace uso del servicio para realizar una petici\u00f3n HTTP al servidor y recibir una respuesta HTTP que contiene los datos solicitados. Luego, el componente procesa los datos recibidos y actualiza la vista en la que se encuentra. Este es el enfoque est\u00e1ndar y recomendado para el uso de servicios en componentes de una aplicaciones web.</p>"},{"location":"frontend/workshop/","title":"Taller/Practica","text":""},{"location":"frontend/workshop/#objetivo","title":"Objetivo","text":"<p>Refactorizar y mejorar el c\u00f3digo del repositorio de GitHub https://github.com/Antonius123-bb/frontend aplicando los principios de desarrollo frontend mencionados.</p>"},{"location":"frontend/workshop/#pasos","title":"Pasos","text":"<ol> <li> <p>Desarrollo por componentes reutilizable: Revisar el c\u00f3digo del repositorio y buscar oportunidades para crear componentes reutilizables. Crear nuevos componentes y refactorizar el c\u00f3digo existente para hacerlo m\u00e1s modular y reutilizable.</p> </li> <li> <p>Separaci\u00f3n de presentaci\u00f3n y logica de negocio: Asegurarse de que los componentes est\u00e9n separados en presentaci\u00f3n y l\u00f3gica de negocio. Crear componentes de presentaci\u00f3n que solo se preocupen por la apariencia y el estilo, y componentes de l\u00f3gica de negocio que se encarguen de la funcionalidad.</p> </li> <li> <p>Estandarizaci\u00f3n del consumo de API: Establecer una estrategia para el manejo de las solicitudes HTTP. Asegurarse de que las solicitudes HTTP est\u00e9n estandarizadas y de que se utilicen los mismos m\u00e9todos y convenciones en todo el proyecto. Utilizar una librer\u00eda de manejo de solicitudes HTTP como axios o fetch para facilitar el proceso.</p> </li> <li> <p>Estrategia de entradas comunes: Definir una estrategia para el manejo de las entradas del usuario en todo el proyecto (formularios). Asegurarse de que se utilicen las mismas convenciones en todo el proyecto basado en una l\u00ednea gr\u00e1fica com\u00fan, como nombres de clases, atributos y estilos, para facilitar la modificaci\u00f3n y el mantenimiento.</p> </li> <li> <p>Automatizaci\u00f3n de pruebas: Crear pruebas automatizadas para los componentes y las funcionalidades del proyecto. Utilizar herramientas de prueba como Jest o Mocha para asegurar la calidad del c\u00f3digo y evitar errores.</p> </li> <li> <p>Dise\u00f1o responsivo: Asegurarse de que el proyecto sea responsive y se vea bien en diferentes tama\u00f1os de pantalla. Utilizar t\u00e9cnicas como media queries y flexbox para crear dise\u00f1os adaptables.</p> </li> <li> <p>Analizador y formateador de c\u00f3digo: Configurar una herramienta de an\u00e1lisis y formateo de c\u00f3digo como ESLint o Prettier para garantizar la consistencia en el c\u00f3digo. Asegurarse de que el c\u00f3digo cumpla con las reglas establecidas en el proyecto.</p> </li> <li> <p>Estilo en los componentes: Utilizar estilos en l\u00ednea o archivos CSS separados para estilizar los componentes. Asegurarse de que los estilos est\u00e9n organizados y sean f\u00e1ciles de mantener.</p> </li> <li> <p>Gesti\u00f3n de cambios adecuado (por git o por changelog): Utilizar Git para gestionar los cambios y las versiones del proyecto. Crear ramas separadas para nuevas funcionalidades o correcciones de errores y hacer solicitudes de extracci\u00f3n para fusionarlas en la rama principal. Tambi\u00e9n, considerar la implementaci\u00f3n de un changelog para documentar los cambios y mejoras en el proyecto.</p> </li> </ol>"},{"location":"frontend/workshop/#resultado","title":"Resultado","text":"<p>El resultado de este taller ser\u00eda una versi\u00f3n mejorada y m\u00e1s eficiente del proyecto en el repositorio de GitHub https://github.com/Antonius123-bb/frontend. Se habr\u00eda aplicado los principios de desarrollo frontend mencionados y se habr\u00eda mejorado la calidad del c\u00f3digo, la modularidad, la reutilizaci\u00f3n y la mantenibilidad del proyecto. Adem\u00e1s, se habr\u00eda establecido</p>"},{"location":"microservice/consumer_first/","title":"Consumer First","text":"<p>El principio \"Consumer first\" (enfoque en el consumidor) es uno de los principios clave en el dise\u00f1o y desarrollo de microservicios. Este principio se centra en la idea de que los microservicios deben estar dise\u00f1ados para satisfacer las necesidades espec\u00edficas de los consumidores que los utilizan.</p> <p>En lugar de dise\u00f1ar los microservicios desde una perspectiva de tecnolog\u00eda, con el enfoque en la arquitectura y la implementaci\u00f3n de servicios, el principio \"Consumer first\" propone que los equipos de desarrollo deben centrarse en las necesidades y expectativas de los consumidores de sus servicios.</p> <p>Para aplicar este principio, los equipos de desarrollo deben comprender las necesidades de los consumidores y dise\u00f1ar los servicios para satisfacer esas necesidades de manera efectiva y eficiente. Esto puede significar la implementaci\u00f3n de caracter\u00edsticas espec\u00edficas del consumidor, la optimizaci\u00f3n del rendimiento y la capacidad de respuesta, y la atenci\u00f3n a la facilidad de uso.</p> <p>Al dise\u00f1ar los microservicios con el principio \"Consumer first\", los equipos de desarrollo pueden mejorar la calidad de sus servicios y aumentar la satisfacci\u00f3n del consumidor. Adem\u00e1s, al dise\u00f1ar los servicios para satisfacer las necesidades espec\u00edficas de los consumidores, los equipos de desarrollo pueden reducir la complejidad y mejorar la escalabilidad de sus servicios, lo que permite una mayor flexibilidad y adaptabilidad en el futuro. En resumen, el principio \"Consumer first\" es fundamental para garantizar el \u00e9xito de la arquitectura de microservicios y para ofrecer servicios eficientes y eficaces que satisfagan las necesidades de los consumidores.</p>"},{"location":"microservice/consumer_first/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Identificar los consumidores: Es importante identificar a los consumidores de los microservicios y comprender sus necesidades y expectativas. Esto puede incluir la realizaci\u00f3n de entrevistas con los usuarios, la observaci\u00f3n de su comportamiento y la revisi\u00f3n de los datos de uso.</p> </li> <li> <p>Definir los requisitos del consumidor: Una vez identificados los consumidores, se deben definir sus requisitos y expectativas para los servicios. Esto puede incluir requisitos de rendimiento, escalabilidad, seguridad, usabilidad y otros.</p> </li> <li> <p>Dise\u00f1ar los microservicios para satisfacer las necesidades del consumidor: Los microservicios deben ser dise\u00f1ados para satisfacer las necesidades espec\u00edficas del consumidor. Esto puede incluir la implementaci\u00f3n de caracter\u00edsticas espec\u00edficas del consumidor, la optimizaci\u00f3n del rendimiento y la capacidad de respuesta, y la atenci\u00f3n a la facilidad de uso.</p> </li> <li> <p>Crear una interfaz de usuario f\u00e1cil de usar: La interfaz de usuario de los microservicios debe ser dise\u00f1ada para ser intuitiva y f\u00e1cil de usar para los consumidores. Esto puede incluir el uso de lenguaje claro y sencillo, la simplificaci\u00f3n de los flujos de trabajo y la disposici\u00f3n de la informaci\u00f3n de manera l\u00f3gica y coherente.</p> </li> <li> <p>Implementar la retroalimentaci\u00f3n del consumidor: Es importante implementar la retroalimentaci\u00f3n de los consumidores en el dise\u00f1o y desarrollo de los microservicios. Esto puede incluir la realizaci\u00f3n de pruebas de usabilidad y pruebas de rendimiento con usuarios reales, as\u00ed como la implementaci\u00f3n de actualizaciones y mejoras basadas en la retroalimentaci\u00f3n de los consumidores.</p> </li> <li> <p>Monitorear el rendimiento: Es importante monitorear el rendimiento de los microservicios para asegurarse de que satisfacen las necesidades de los consumidores. Esto puede incluir la supervisi\u00f3n del tiempo de respuesta de las llamadas API, el rendimiento de la base de datos y otros indicadores clave de rendimiento.</p> </li> <li> <p>Mejorar continuamente: Los equipos de desarrollo deben estar abiertos a la retroalimentaci\u00f3n de los consumidores y utilizarla para mejorar continuamente los microservicios. Esto puede incluir la implementaci\u00f3n de actualizaciones y mejoras basadas en la retroalimentaci\u00f3n de los consumidores.</p> </li> </ol> <p>Al seguir estos pasos, los equipos de desarrollo pueden aplicar el principio \"Consumer first\" en el dise\u00f1o y desarrollo de microservicios para ofrecer servicios efectivos y eficientes que satisfagan las necesidades espec\u00edficas de los consumidores.</p>"},{"location":"microservice/consumer_first/#ejemplo","title":"Ejemplo","text":"<p>A continuaci\u00f3n se presenta un ejemplo de un servicio ficticio de \"Consulta de saldo bancario\" que cumple con el principio \"Consumer first\":</p>"},{"location":"microservice/consumer_first/#servicio-de-consulta-de-saldo-bancario","title":"Servicio de Consulta de saldo bancario","text":"<p>El servicio de Consulta de saldo bancario proporciona una forma de recuperar el saldo disponible en una cuenta bancaria espec\u00edfica.</p>"},{"location":"microservice/consumer_first/#endpoints","title":"Endpoints","text":"<p>El servicio ofrece un \u00fanico endpoint:</p> <pre><code>GET /api/v1/accounts/{account_number}/balance\n</code></pre> <p>Este endpoint recupera el saldo disponible en la cuenta bancaria especificada por el n\u00famero de cuenta.</p>"},{"location":"microservice/consumer_first/#parametros-de-entrada","title":"Par\u00e1metros de entrada","text":"<p>El endpoint acepta un \u00fanico par\u00e1metro:</p> <ul> <li>account_number (obligatorio): El n\u00famero de cuenta de la cuenta bancaria para la cual se desea recuperar el saldo. Debe ser un valor num\u00e9rico de 10 d\u00edgitos.</li> </ul>"},{"location":"microservice/consumer_first/#autenticacion","title":"Autenticaci\u00f3n","text":"<p>El servicio utiliza autenticaci\u00f3n basada en token. Para autenticarse, el consumidor debe proporcionar un token v\u00e1lido en la cabecera Authorization de la solicitud. El token se puede obtener a trav\u00e9s de un proceso de registro de consumidor previo.</p>"},{"location":"microservice/consumer_first/#formato-de-respuesta","title":"Formato de respuesta","text":"<p>El endpoint devuelve una respuesta en formato JSON con los siguientes campos:</p> <ul> <li>account_number: El n\u00famero de cuenta bancaria especificado en la solicitud. balance: El saldo disponible en la cuenta bancaria en el momento de la consulta.</li> </ul>"},{"location":"microservice/consumer_first/#ejemplo-de-solicitud","title":"Ejemplo de solicitud","text":"<pre><code>GET /api/v1/accounts/1234567890/balance\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n</code></pre>"},{"location":"microservice/consumer_first/#ejemplo-de-respuesta","title":"Ejemplo de respuesta","text":"<pre><code>{\n\"account_number\": \"1234567890\",\n\"balance\": 5000.00\n}\n</code></pre>"},{"location":"microservice/consumer_first/#errores","title":"Errores","text":"<p>El servicio devuelve los siguientes errores en caso de que se produzca una situaci\u00f3n inesperada:</p> <ul> <li>401 Unauthorized: El consumidor no est\u00e1 autenticado o su token no es v\u00e1lido.</li> <li>404 Not Found: La cuenta bancaria especificada no existe o no est\u00e1 disponible.</li> <li>500 Internal Server Error: Se ha producido un error en el servidor.</li> </ul>"},{"location":"microservice/consumer_first/#guia-de-uso","title":"Gu\u00eda de uso","text":"<p>Para utilizar el servicio de Consulta de saldo bancario, sigue los siguientes pasos:</p> <ol> <li>Registra una cuenta de consumidor y obt\u00e9n un token de autenticaci\u00f3n v\u00e1lido.</li> <li>Realiza una solicitud GET a GET /api/v1/accounts/{account_number}/balance, especificando el n\u00famero de cuenta bancaria para la cual deseas recuperar el saldo y el token de autenticaci\u00f3n en la cabecera Authorization.</li> <li>La respuesta devolver\u00e1 el saldo disponible en la cuenta bancaria especificada en formato JSON.</li> </ol> <p>\u00a1Listo! Ahora puedes integrar el servicio de Consulta de saldo bancario en tu sistema y recuperar el saldo disponible de tus cuentas bancarias de manera f\u00e1cil y r\u00e1pida.</p>"},{"location":"microservice/consumer_first/#consecuencias","title":"Consecuencias","text":"<ol> <li> <p>Dificultades en la integraci\u00f3n de los servicios: si los servicios no est\u00e1n dise\u00f1ados pensando en el consumidor final, puede haber problemas de integraci\u00f3n entre ellos, lo que dificulta la implementaci\u00f3n de nuevas funcionalidades o la modificaci\u00f3n de las existentes.</p> </li> <li> <p>Incompatibilidades en la interfaz de usuario: si los servicios no est\u00e1n dise\u00f1ados para ser consumidos f\u00e1cilmente por el usuario final, puede haber problemas de incompatibilidad en la interfaz de usuario, lo que dificulta el uso de las aplicaciones y servicios.</p> </li> <li> <p>Dificultades en la adopci\u00f3n de nuevos servicios: si los servicios no est\u00e1n dise\u00f1ados pensando en el usuario final, puede haber dificultades en la adopci\u00f3n de nuevos servicios, lo que puede llevar a la p\u00e9rdida de oportunidades de negocio.</p> </li> <li> <p>Problemas de escalabilidad: si los servicios no est\u00e1n dise\u00f1ados para escalar de manera eficiente, puede haber problemas de rendimiento y disponibilidad cuando se enfrenten a una gran demanda, lo que puede afectar negativamente la experiencia del usuario final.</p> </li> </ol>"},{"location":"microservice/culture_automation/","title":"Culture of Automation","text":"<p>El principio de Culture of Automation es uno de los principios de los microservicios seg\u00fan Sam Newman. Este principio se centra en la automatizaci\u00f3n de los procesos de despliegue, pruebas y monitorizaci\u00f3n de los microservicios.</p> <p>La idea detr\u00e1s de este principio es que la automatizaci\u00f3n es fundamental para garantizar la calidad, la velocidad y la fiabilidad de la entrega de software en un entorno de microservicios. Al automatizar los procesos, se pueden reducir los errores y los tiempos de entrega, y se puede mejorar la eficiencia de todo el equipo de desarrollo.</p> <p>La cultura de la automatizaci\u00f3n implica establecer procesos autom\u00e1ticos de pruebas y despliegue continuos para reducir la carga de trabajo manual y permitir la liberaci\u00f3n r\u00e1pida y frecuente de nuevas versiones de software. Tambi\u00e9n implica la automatizaci\u00f3n del monitoreo de los servicios para detectar y solucionar r\u00e1pidamente los problemas.</p> <p>La implementaci\u00f3n de la cultura de la automatizaci\u00f3n puede requerir cambios culturales y de procesos en el equipo de desarrollo, pero puede ser muy beneficiosa a largo plazo, al permitir que los equipos de desarrollo sean m\u00e1s \u00e1giles, efectivos y eficientes.</p>"},{"location":"microservice/culture_automation/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Automatizaci\u00f3n de pruebas: Las pruebas son una parte fundamental en el ciclo de vida de cualquier servicio. La automatizaci\u00f3n de pruebas permite que los equipos puedan realizar pruebas de forma r\u00e1pida y eficiente, lo que resulta en una mayor calidad y velocidad de entrega.</p> </li> <li> <p>Automatizaci\u00f3n de despliegues: Los despliegues manuales son propensos a errores y llevan mucho tiempo. La automatizaci\u00f3n de despliegues permite que los equipos puedan desplegar servicios de forma r\u00e1pida y segura, lo que mejora la velocidad y la calidad de las entregas.</p> </li> <li> <p>Automatizaci\u00f3n de infraestructura: La infraestructura es la base sobre la que se ejecutan los servicios. La automatizaci\u00f3n de la infraestructura permite que los equipos puedan crear, modificar y eliminar infraestructura de forma r\u00e1pida y eficiente, lo que mejora la flexibilidad y la escalabilidad de los servicios.</p> </li> <li> <p>Automatizaci\u00f3n de monitoreo: El monitoreo es clave para entender el comportamiento y la salud de los servicios. La automatizaci\u00f3n del monitoreo permite que los equipos puedan detectar y resolver problemas de forma r\u00e1pida, lo que mejora la disponibilidad y el rendimiento de los servicios.</p> </li> </ol> <p>En resumen, la automatizaci\u00f3n es fundamental para poder cumplir con los principios de microservicios, permitiendo a los equipos de desarrollo y operaciones trabajar de forma m\u00e1s eficiente y en colaboraci\u00f3n, mejorando la calidad y la velocidad de entrega de los servicios.</p>"},{"location":"microservice/culture_automation/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Supongamos que tienes una aplicaci\u00f3n compuesta por varios microservicios que se ejecutan en un cl\u00faster de Kubernetes. Para aplicar el principio de Culture of Automation, puedes utilizar herramientas y pr\u00e1cticas de automatizaci\u00f3n en todo el ciclo de vida de la aplicaci\u00f3n, desde el desarrollo hasta la implementaci\u00f3n y la monitorizaci\u00f3n.</p> <p>Algunas de las pr\u00e1cticas que puedes utilizar incluyen:</p> <ol> <li> <p>Integraci\u00f3n y entrega continua (CI/CD): Utiliza una herramienta de CI/CD para automatizar la compilaci\u00f3n, pruebas y despliegue de tus microservicios en el cl\u00faster de Kubernetes. Puedes utilizar herramientas como Jenkins, GitLab CI, CircleCI, entre otras.</p> </li> <li> <p>Orquestaci\u00f3n y gesti\u00f3n de cl\u00fasteres: Utiliza herramientas de orquestaci\u00f3n y gesti\u00f3n de cl\u00fasteres para automatizar la implementaci\u00f3n y la administraci\u00f3n de tus microservicios. En Kubernetes, puedes utilizar herramientas como Helm para gestionar paquetes de aplicaciones y Kubeadm para crear y administrar cl\u00fasteres.</p> </li> <li> <p>Monitorizaci\u00f3n y an\u00e1lisis de registros: Utiliza herramientas de monitorizaci\u00f3n y an\u00e1lisis de registros para automatizar la detecci\u00f3n y resoluci\u00f3n de problemas en tus microservicios. Puedes utilizar herramientas como Prometheus y Grafana para recopilar y visualizar m\u00e9tricas de tus microservicios y Elasticsearch, Kibana y Fluentd para recopilar y analizar los registros.</p> </li> <li> <p>Escalabilidad autom\u00e1tica: Utiliza herramientas de escalabilidad autom\u00e1tica para ajustar autom\u00e1ticamente el n\u00famero de r\u00e9plicas de tus microservicios seg\u00fan la demanda de la aplicaci\u00f3n. En Kubernetes, puedes utilizar HPA (Horizontal Pod Autoscaler) para escalar autom\u00e1ticamente el n\u00famero de r\u00e9plicas de un conjunto de pods.</p> </li> </ol> <p>En resumen, para aplicar el principio de Culture of Automation en Kubernetes, debes utilizar herramientas y pr\u00e1cticas de automatizaci\u00f3n en todo el ciclo de vida de la aplicaci\u00f3n, desde el desarrollo hasta la implementaci\u00f3n y la monitorizaci\u00f3n. Esto te permitir\u00e1 mejorar la eficiencia, reducir errores y aumentar la escalabilidad y la disponibilidad de tus microservicios.</p>"},{"location":"microservice/culture_automation/#consecuencias","title":"Consecuencias","text":"<ol> <li> <p>Mayor complejidad: Si no se automatizan las tareas de configuraci\u00f3n, despliegue, pruebas, monitorizaci\u00f3n y escalabilidad, la gesti\u00f3n de los microservicios se vuelve m\u00e1s compleja y propensa a errores.</p> </li> <li> <p>Retrasos en la entrega: Si los procesos de construcci\u00f3n, integraci\u00f3n y despliegue no est\u00e1n automatizados, se requiere m\u00e1s tiempo y esfuerzo para realizar estas tareas manualmente, lo que puede retrasar la entrega del software.</p> </li> <li> <p>Errores y fallos: La falta de automatizaci\u00f3n aumenta el riesgo de errores humanos y fallos en el sistema, lo que puede tener un impacto negativo en la disponibilidad y el rendimiento del servicio.</p> </li> <li> <p>Escalabilidad limitada: Si no se automatiza la escalabilidad de los microservicios, puede ser dif\u00edcil y lento escalar los recursos necesarios para satisfacer la demanda.</p> </li> </ol>"},{"location":"microservice/decentralise_things/","title":"Decentralise All The Things","text":"<p>El principio \"Decentralise All The Things\" se refiere a la idea de que los microservicios deben ser dise\u00f1ados de tal manera que no dependan de un componente centralizado. En lugar de ello, cada microservicio debe ser lo suficientemente aut\u00f3nomo y capaz de realizar su trabajo sin depender de otros microservicios o componentes externos.</p> <p>Este principio busca evitar una arquitectura monol\u00edtica en la que un componente centralizado controla todo el sistema, lo que puede hacer que el sistema sea menos escalable y menos resiliente a las fallas. Al descentralizar todo, cada microservicio puede ser dise\u00f1ado para ser m\u00e1s independiente y escalable, lo que puede mejorar la eficiencia y la confiabilidad del sistema en general.</p> <p>En resumen, el principio \"Decentralise All The Things\" busca crear un sistema m\u00e1s resiliente y escalable mediante la descentralizaci\u00f3n de cada componente. Esto se logra mediante la implementaci\u00f3n de pr\u00e1cticas recomendadas como la autonom\u00eda, la arquitectura basada en eventos, el registro y descubrimiento de servicios, la tolerancia a fallos y el monitoreo de la actividad de los microservicios.</p>"},{"location":"microservice/decentralise_things/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Identificar los servicios que pueden ser descentralizados: Analice su arquitectura y determine qu\u00e9 servicios podr\u00edan ser descentralizados para mejorar la escalabilidad, la disponibilidad y la resiliencia.</p> </li> <li> <p>Utilizar patrones de dise\u00f1o adecuados: Aseg\u00farese de utilizar patrones de dise\u00f1o adecuados para garantizar una correcta distribuci\u00f3n y coordinaci\u00f3n de los servicios. Patrones como el Service Registry y el Circuit Breaker pueden ayudar a lograr una mayor resiliencia en el sistema.</p> </li> <li> <p>Asegurar una buena comunicaci\u00f3n entre los servicios: Es importante asegurarse de que los servicios puedan comunicarse de manera efectiva y segura. Utilice protocolos de comunicaci\u00f3n estandarizados y seguros, como HTTPS o gRPC.</p> </li> <li> <p>Implementar la autenticaci\u00f3n y la autorizaci\u00f3n: La autenticaci\u00f3n y la autorizaci\u00f3n son fundamentales para garantizar que s\u00f3lo los usuarios autorizados tengan acceso a los servicios adecuados. Implemente sistemas de autenticaci\u00f3n y autorizaci\u00f3n robustos para evitar posibles vulnerabilidades.</p> </li> <li> <p>Realizar pruebas exhaustivas: Antes de implementar los servicios en producci\u00f3n, es importante realizar pruebas exhaustivas para garantizar que los servicios funcionan correctamente en diferentes escenarios. Utilice herramientas de pruebas automatizadas para simular una carga de trabajo real.</p> </li> <li> <p>Implementar la monitorizaci\u00f3n y el registro: La monitorizaci\u00f3n y el registro son fundamentales para asegurar la resiliencia y la eficiencia de los servicios. Implemente sistemas de monitorizaci\u00f3n y registro para detectar posibles problemas en los servicios y poder solucionarlos r\u00e1pidamente.</p> </li> <li> <p>Considerar el impacto en la organizaci\u00f3n: La descentralizaci\u00f3n de los servicios puede tener un gran impacto en la organizaci\u00f3n. Aseg\u00farese de que el equipo de desarrollo est\u00e9 preparado para trabajar en un entorno descentralizado y que tenga las herramientas y la formaci\u00f3n adecuadas para gestionar correctamente los servicios distribuidos.</p> </li> <li> <p>Planificar la escalabilidad: La descentralizaci\u00f3n de los servicios permite una mayor escalabilidad, pero es importante planificar correctamente la escalabilidad de los servicios. Aseg\u00farese de que los servicios sean escalables horizontalmente y que puedan soportar una carga de trabajo creciente sin afectar a la eficiencia y a la resiliencia del sistema.</p> </li> </ol>"},{"location":"microservice/decentralise_things/#consecuencias","title":"Consecuencias","text":"<ol> <li> <p>Dependencia de servicios centrales: Si la arquitectura est\u00e1 dise\u00f1ada en torno a servicios centrales, entonces se vuelve muy dif\u00edcil para los equipos de desarrollo trabajar de forma aut\u00f3noma y desplegar sus servicios de manera independiente. Esto puede causar retrasos en la implementaci\u00f3n y problemas de escalabilidad.</p> </li> <li> <p>Dificultades en la resoluci\u00f3n de problemas: Si los servicios est\u00e1n altamente acoplados, puede ser muy dif\u00edcil para los equipos de desarrollo identificar y resolver problemas. La complejidad de la interconexi\u00f3n de los servicios puede llevar a un aumento en la complejidad de la resoluci\u00f3n de problemas.</p> </li> <li> <p>Falta de flexibilidad: Si los servicios no est\u00e1n dise\u00f1ados para ser desacoplados y altamente independientes, entonces los cambios en un servicio pueden requerir cambios en otros servicios, lo que aumenta la complejidad y puede ralentizar el proceso de desarrollo.</p> </li> <li> <p>Mayor costo: La dependencia de servicios centrales puede llevar a una mayor complejidad y a un mayor costo en t\u00e9rminos de desarrollo, mantenimiento y escalabilidad. La falta de autonom\u00eda tambi\u00e9n puede ralentizar el proceso de desarrollo y aumentar los costos en general.</p> </li> </ol>"},{"location":"microservice/deploy_independently/","title":"Deploy Independently","text":"<p>El principio \"Deploy Independently\" es uno de los principios fundamentales de la arquitectura de microservicios. Este principio establece que cada microservicio debe ser desplegado de manera independiente, sin afectar a otros servicios del sistema.</p> <p>Esto significa que los cambios en un microservicio no deben causar efectos secundarios en otros servicios. Cada microservicio debe ser empaquetado y desplegado como una unidad independiente, con sus propios procesos y recursos. Adem\u00e1s, cada servicio debe ser capaz de escalar de forma independiente seg\u00fan sus propias necesidades.</p> <p>El objetivo principal de este principio es permitir la evoluci\u00f3n independiente de los servicios. Al permitir que cada servicio evolucione por s\u00ed mismo, el equipo de desarrollo puede iterar y mejorar el servicio sin tener que esperar a que otros servicios se actualicen o ser bloqueados por ellos.</p> <p>Adem\u00e1s, este principio tambi\u00e9n permite la reducci\u00f3n de riesgos en el despliegue de cambios, ya que los cambios se pueden probar y desplegar en un entorno aislado antes de integrarlos en el sistema en su totalidad.</p> <p>En resumen, el principio \"Deploy Independently\" se trata de la capacidad de cada microservicio de ser desplegado y actualizado de forma independiente, lo que permite una mayor flexibilidad y evoluci\u00f3n en la arquitectura de microservicios.</p>"},{"location":"microservice/deploy_independently/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Automatizar el proceso de despliegue: Se debe invertir en herramientas y procesos que permitan el despliegue automatizado de los microservicios. Esto permitir\u00e1 un despliegue r\u00e1pido y consistente, lo que reduce la posibilidad de errores y tiempos de inactividad.</p> </li> <li> <p>Usar contenedores: El uso de contenedores, como Docker, es una buena pr\u00e1ctica para el despliegue de microservicios. Los contenedores proporcionan un entorno aislado para el servicio y sus dependencias, lo que facilita la portabilidad y el despliegue independiente del servicio.</p> </li> <li> <p>Separar las responsabilidades: Cada microservicio debe tener una responsabilidad clara y estar aislado de otros servicios. Esto significa que no debe haber dependencias directas entre servicios y que cada servicio debe ser capaz de funcionar de forma independiente.</p> </li> <li> <p>Usar versionado: Se debe utilizar una estrategia de versionado para los microservicios, lo que permite la gesti\u00f3n de cambios en los servicios y su despliegue independiente.</p> </li> <li> <p>Pruebas automatizadas: Las pruebas automatizadas son esenciales para garantizar que cada microservicio se despliegue correctamente y funcione correctamente. Se deben crear pruebas automatizadas para cada microservicio, lo que permitir\u00e1 una detecci\u00f3n r\u00e1pida de errores y una correcci\u00f3n m\u00e1s r\u00e1pida.</p> </li> <li> <p>Monitoreo y registro de errores: Es importante contar con un sistema de monitoreo y registro de errores para cada microservicio. Esto permitir\u00e1 una detecci\u00f3n temprana de errores y una soluci\u00f3n r\u00e1pida y eficiente.</p> </li> </ol> <p>En general, aplicar el principio \"Deploy Independently\" implica invertir en herramientas, procesos y pr\u00e1cticas que permitan el despliegue independiente de cada microservicio, lo que garantiza una mayor flexibilidad y evoluci\u00f3n en la arquitectura de microservicios.</p>"},{"location":"microservice/deploy_independently/#importante","title":"Importante","text":"<p>El principio \"Deploy Independently\" est\u00e1 estrechamente relacionado con DevOps, ya que una de las pr\u00e1cticas fundamentales de DevOps es la entrega continua (Continuous Delivery).</p> <p>La entrega continua implica que los cambios en el software se pueden implementar y desplegar de manera automatizada, r\u00e1pida y con frecuencia, de tal manera que los equipos de desarrollo y operaciones trabajan juntos para automatizar los procesos de compilaci\u00f3n, pruebas y despliegue.</p> <p>Para lograr una entrega continua efectiva, es necesario aplicar el principio \"Deploy Independently\", ya que cada microservicio debe ser desplegado de manera independiente sin afectar a otros servicios o al sistema en su conjunto. Esto requiere una buena planificaci\u00f3n y coordinaci\u00f3n entre los equipos de desarrollo y operaciones, y la implementaci\u00f3n de herramientas y pr\u00e1cticas de automatizaci\u00f3n, monitoreo y pruebas.</p> <p>Por lo tanto, DevOps es fundamental para garantizar que se pueda implementar el principio \"Deploy Independently\" de manera efectiva y eficiente.</p>"},{"location":"microservice/deploy_independently/#consecuencias","title":"Consecuencias","text":"<ol> <li> <p>Dependencia entre servicios: Si los servicios no se pueden implementar de forma independiente, es probable que haya una dependencia entre ellos. Esto significa que cualquier cambio en un servicio podr\u00eda afectar a otros servicios, lo que aumenta la complejidad de la implementaci\u00f3n.</p> </li> <li> <p>Problemas de integraci\u00f3n: La falta de independencia en la implementaci\u00f3n de los servicios puede provocar problemas de integraci\u00f3n, lo que aumenta el riesgo de errores y fallos en la aplicaci\u00f3n.</p> </li> <li> <p>Retrasos en la implementaci\u00f3n: Si los servicios no se pueden implementar de forma independiente, puede haber retrasos en la implementaci\u00f3n de nuevas caracter\u00edsticas o en la correcci\u00f3n de errores, ya que cualquier cambio en un servicio requerir\u00e1 cambios en otros servicios.</p> </li> <li> <p>Mayor complejidad en el control de versiones: Si los servicios no se pueden implementar de forma independiente, puede haber una mayor complejidad en el control de versiones, ya que cualquier cambio en un servicio podr\u00eda afectar a la compatibilidad con otros servicios.</p> </li> </ol>"},{"location":"microservice/hide_implementation/","title":"Hide Implementation Details","text":"<p>El principio de \"Hide Implementation Details\" se refiere a la idea de que los detalles de implementaci\u00f3n de un microservicio no deben ser expuestos a otros microservicios o a los consumidores finales del servicio. En lugar de eso, se debe proporcionar una interfaz clara y sencilla que oculte los detalles internos del servicio y permita que los consumidores interact\u00faen con \u00e9l de manera f\u00e1cil y segura.</p> <p>Este principio se basa en el concepto de encapsulamiento y abstracci\u00f3n en la programaci\u00f3n orientada a objetos. Al ocultar los detalles de implementaci\u00f3n de un microservicio, se logra una mayor flexibilidad y modularidad en la arquitectura de microservicios. Los cambios internos de un servicio no afectan a otros servicios que lo consumen, siempre y cuando la interfaz p\u00fablica del servicio permanezca sin cambios.</p> <p>Adem\u00e1s, al ocultar los detalles de implementaci\u00f3n, se mejora la seguridad de los servicios. Los atacantes no pueden aprovecharse de vulnerabilidades en la implementaci\u00f3n interna de un servicio si no tienen acceso a esos detalles.</p> <p>Para aplicar este principio, es necesario dise\u00f1ar una interfaz clara y sencilla para cada microservicio, que oculte los detalles internos de implementaci\u00f3n. Es importante establecer buenas pr\u00e1cticas de dise\u00f1o de API, como la utilizaci\u00f3n de nombres de recursos descriptivos y la limitaci\u00f3n de las operaciones expuestas a las necesarias para cumplir la funci\u00f3n del servicio.</p> <p>Tambi\u00e9n es importante establecer pol\u00edticas de seguridad para controlar el acceso a los detalles de implementaci\u00f3n, como las credenciales de acceso a la base de datos o la informaci\u00f3n de configuraci\u00f3n del servidor. Estas pol\u00edticas deben garantizar que solo las personas autorizadas tengan acceso a los detalles internos de implementaci\u00f3n.</p> <p>En resumen, el principio de \"Hide Implementation Details\" es esencial para lograr una arquitectura de microservicios flexible, modular y segura. Al dise\u00f1ar interfaces claras y sencillas para cada servicio y limitar el acceso a los detalles internos de implementaci\u00f3n, se pueden lograr servicios independientes y escalables que puedan evolucionar con facilidad sin afectar a otros servicios.</p>"},{"location":"microservice/hide_implementation/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Definir interfaces claras: es importante que las interfaces sean claras, concisas y f\u00e1ciles de entender. Esto permitir\u00e1 que los equipos que consumen los servicios puedan utilizarlos sin necesidad de conocer los detalles de implementaci\u00f3n.</p> </li> <li> <p>Utilizar contratos: los contratos son acuerdos entre el proveedor y el consumidor del servicio. Estos acuerdos deben incluir detalles sobre el formato de los datos, la frecuencia de actualizaci\u00f3n y los l\u00edmites de uso. De esta manera, se garantiza que los consumidores del servicio puedan acceder a los datos necesarios sin necesidad de conocer los detalles de implementaci\u00f3n.</p> </li> <li> <p>Ocultar la l\u00f3gica de negocio: la l\u00f3gica de negocio debe estar oculta detr\u00e1s de la interfaz del servicio. De esta manera, se evita que los consumidores del servicio puedan acceder directamente a la l\u00f3gica de negocio y se garantiza que el proveedor del servicio tenga el control sobre c\u00f3mo se accede y utiliza esa l\u00f3gica.</p> </li> <li> <p>Utilizar patrones de dise\u00f1o adecuados: existen diferentes patrones de dise\u00f1o que se pueden utilizar para ocultar los detalles de implementaci\u00f3n, como el patr\u00f3n facade o el patr\u00f3n adapter. Es importante elegir el patr\u00f3n adecuado para cada situaci\u00f3n para garantizar que se est\u00e1 ocultando adecuadamente los detalles de implementaci\u00f3n.</p> </li> <li> <p>Documentar adecuadamente: aunque se oculten los detalles de implementaci\u00f3n, es importante documentarlos adecuadamente para que los equipos de desarrollo puedan entender c\u00f3mo funciona el servicio. La documentaci\u00f3n debe incluir informaci\u00f3n detallada sobre la interfaz del servicio, los contratos, la l\u00f3gica de negocio y cualquier otro detalle relevante.</p> </li> <li> <p>Utilizar herramientas de monitoreo y an\u00e1lisis: para garantizar que se est\u00e1 ocultando adecuadamente los detalles de implementaci\u00f3n, es importante utilizar herramientas de monitoreo y an\u00e1lisis que permitan conocer c\u00f3mo se est\u00e1 utilizando el servicio y si hay alguna brecha de seguridad que permita acceder a los detalles de implementaci\u00f3n.</p> </li> </ol> <p>En resumen, el principio de \"hide implementation details\" es esencial para garantizar la independencia de los servicios en un entorno de microservicios. Para aplicarlo adecuadamente, es importante definir interfaces claras, utilizar contratos, ocultar la l\u00f3gica de negocio, utilizar patrones de dise\u00f1o adecuados, documentar adecuadamente y utilizar herramientas de monitoreo y an\u00e1lisis.</p>"},{"location":"microservice/hide_implementation/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>Para aplicar el principio de \"Hide Implementation Details\" en Kubernetes, se puede seguir la pr\u00e1ctica de encapsulaci\u00f3n de los detalles de implementaci\u00f3n de los contenedores en los Pods y utilizar Service Discovery para ocultar la complejidad de la red y la ubicaci\u00f3n de los servicios.</p> <p>Por ejemplo, se puede crear un deployment de una aplicaci\u00f3n web que tenga varios pods con contenedores de Nginx y Java, cada uno con su propia configuraci\u00f3n de entorno. Sin embargo, en lugar de exponer cada pod individualmente a trav\u00e9s de servicios, se puede crear un servicio que se encargue de enrutar las solicitudes a trav\u00e9s de todos los pods.</p> <p>Para lograr esto, se puede utilizar el objeto Kubernetes Service para crear el servicio y especificar el selector para identificar los pods que deben ser agrupados en el servicio. Luego, se pueden definir las reglas de enrutamiento en el servicio para que las solicitudes se enruten a trav\u00e9s de todos los pods que pertenecen al servicio.</p> <p>Adem\u00e1s, se puede utilizar Kubernetes Secrets para ocultar los detalles de la configuraci\u00f3n de los contenedores, como las credenciales de la base de datos, los tokens de autenticaci\u00f3n, etc. Los secrets se pueden montar en los contenedores como vol\u00famenes para que no se expongan directamente en el c\u00f3digo de la aplicaci\u00f3n.</p> <p>En resumen, al utilizar la encapsulaci\u00f3n y el Service Discovery de Kubernetes, junto con la ocultaci\u00f3n de la configuraci\u00f3n de los contenedores mediante el uso de Kubernetes Secrets, se puede aplicar el principio de \"Hide Implementation Details\" en Kubernetes para lograr una arquitectura m\u00e1s limpia y modular.</p>"},{"location":"microservice/hide_implementation/#ejemplo","title":"Ejemplo","text":"<p><pre><code>graph LR\nA[Frontend] -- API Request --&gt; B((Microservicio))\nB -- Database Query --&gt; C{Database}\nB -- Cache Query --&gt; D((Cache))\nD --&gt; C</code></pre> En este diagrama, se representa la interacci\u00f3n entre un frontend, un microservicio y una base de datos. El frontend env\u00eda solicitudes a trav\u00e9s de una API al microservicio, que puede acceder tanto a una base de datos como a una cach\u00e9. Para implementar el principio \"Hide Implementation Details\", se ocultan los detalles de implementaci\u00f3n de la base de datos y la cach\u00e9 detr\u00e1s del microservicio, que act\u00faa como intermediario. De esta manera, el frontend no necesita saber c\u00f3mo se accede a los datos, lo que permite una mayor flexibilidad en la implementaci\u00f3n y el mantenimiento del sistema.</p>"},{"location":"microservice/hide_implementation/#consecuencias","title":"Consecuencias","text":"<ol> <li> <p>Mayores dificultades para realizar cambios: Si la implementaci\u00f3n de un servicio est\u00e1 expuesta a otros servicios, cualquier cambio en la implementaci\u00f3n puede afectar a los servicios que lo utilizan. Esto puede hacer que sea m\u00e1s dif\u00edcil realizar cambios y actualizaciones en el servicio.</p> </li> <li> <p>Mayor acoplamiento: Al exponer detalles de implementaci\u00f3n, los servicios se acoplan m\u00e1s estrechamente entre s\u00ed. Esto puede hacer que sea m\u00e1s dif\u00edcil para los desarrolladores trabajar en los servicios de forma independiente, lo que reduce la capacidad de implementar cambios de manera r\u00e1pida y eficiente.</p> </li> <li> <p>Mayor complejidad: Al exponer detalles de implementaci\u00f3n, se puede aumentar la complejidad general del sistema. Esto puede hacer que sea m\u00e1s dif\u00edcil de entender y mantener el sistema a largo plazo.</p> </li> <li> <p>Mayor exposici\u00f3n a fallos de seguridad: Al exponer detalles de implementaci\u00f3n, se pueden introducir vulnerabilidades de seguridad en el sistema. Esto puede permitir a los atacantes acceder a informaci\u00f3n confidencial o manipular el sistema de manera no autorizada.</p> </li> </ol>"},{"location":"microservice/highly_observable/","title":"Highly Observable","text":"<p>El principio de Highly Observable (Alta Observabilidad) en los microservicios se refiere a la capacidad de tener una visibilidad clara y detallada de los sistemas distribuidos para detectar y solucionar problemas de forma r\u00e1pida y eficiente.</p> <p>Este principio se enfoca en la importancia de contar con herramientas y t\u00e9cnicas adecuadas para la monitorizaci\u00f3n, el registro y el an\u00e1lisis de los eventos generados por los microservicios, permitiendo tener una vista completa del comportamiento del sistema.</p> <p>La observabilidad es importante porque, en un entorno de microservicios, los componentes est\u00e1n altamente acoplados y distribuidos, lo que hace que sea dif\u00edcil detectar fallos y problemas en tiempo real. La alta observabilidad permite a los equipos de operaciones y desarrollo identificar problemas y tomar medidas para corregirlos de forma proactiva, antes de que afecten a la experiencia del usuario final.</p> <p>Entre las t\u00e9cnicas y herramientas para lograr la alta observabilidad se encuentran:</p> <ul> <li> <p>Registro centralizado de eventos y logs: Permite tener un registro completo de los eventos y acciones que suceden en cada uno de los microservicios, lo que facilita el an\u00e1lisis y la detecci\u00f3n de problemas.</p> </li> <li> <p>Monitoreo de m\u00e9tricas: Permite obtener informaci\u00f3n sobre la utilizaci\u00f3n de recursos de cada microservicio, lo que ayuda a detectar problemas de rendimiento.</p> </li> <li> <p>Tracing: Permite seguir el rastro de una solicitud a trav\u00e9s de los diferentes microservicios, lo que ayuda a identificar los cuellos de botella y los problemas de latencia.</p> </li> <li> <p>Alertas: Permite configurar alertas autom\u00e1ticas para detectar problemas y notificar a los equipos de operaciones y desarrollo en tiempo real.</p> </li> </ul> <p>En resumen, el principio de Highly Observable es clave para la resoluci\u00f3n r\u00e1pida y efectiva de problemas en un entorno de microservicios, permitiendo una mejor toma de decisiones y mejorando la experiencia del usuario final.</p>"},{"location":"microservice/highly_observable/#recomendaciones","title":"Recomendaciones","text":"<p>Para aplicar el principio de Highly Observable en arquitecturas de microservicios, se pueden seguir las siguientes recomendaciones:</p> <ol> <li> <p>Utilizar herramientas de monitoreo y registro: Es importante tener un sistema de monitoreo que permita conocer el estado de los servicios en tiempo real, as\u00ed como herramientas de registro para almacenar la informaci\u00f3n de las interacciones entre los servicios. De esta manera se puede detectar problemas de rendimiento y errores en la comunicaci\u00f3n entre los servicios.</p> </li> <li> <p>Utilizar m\u00e9tricas: Las m\u00e9tricas pueden ser utilizadas para medir el desempe\u00f1o de los servicios, permitiendo detectar cuellos de botella, tiempos de respuesta lentos y otros problemas de rendimiento. Estas m\u00e9tricas tambi\u00e9n pueden ser utilizadas para generar alertas cuando se exceden ciertos umbrales de rendimiento.</p> </li> <li> <p>Implementar logs:La implementaci\u00f3n de logs es una buena pr\u00e1ctica para el registro de informaci\u00f3n relevante sobre los servicios, como la informaci\u00f3n de las peticiones y respuestas, errores, etc. Esto permite detectar problemas de rendimiento, errores y facilita la tarea de debugging.</p> </li> <li> <p>Utilizar dashboards: Los dashboards permiten visualizar el estado de los servicios y las m\u00e9tricas en tiempo real. Pueden ser utilizados para monitorear la salud de los servicios, alertar sobre posibles problemas y detectar patrones de comportamiento.</p> </li> <li> <p>Utilizar herramientas de trazabilidad: Las herramientas de trazabilidad permiten seguir el flujo de las peticiones a trav\u00e9s de los diferentes servicios, lo que facilita la identificaci\u00f3n de problemas en la comunicaci\u00f3n entre los servicios.</p> </li> <li> <p>Implementar pruebas de regresi\u00f3n: Las pruebas de regresi\u00f3n son importantes para asegurar que los cambios en los servicios no impacten negativamente en su funcionamiento. Esto permite garantizar la estabilidad del sistema y minimizar el impacto de los cambios en la producci\u00f3n.</p> </li> <li> <p>Fomentar una cultura de pruebas y validaci\u00f3n: Es importante fomentar una cultura de pruebas y validaci\u00f3n en todo el equipo de desarrollo, para asegurar que todos los cambios realizados en los servicios sean probados y validados adecuadamente antes de ser puestos en producci\u00f3n.</p> </li> </ol> <p>Siguiendo estas recomendaciones se puede lograr una implementaci\u00f3n exitosa del principio de Highly Observable en arquitecturas de microservicios, lo que permitir\u00e1 tener un sistema m\u00e1s robusto, confiable y f\u00e1cilmente mantenible.</p>"},{"location":"microservice/highly_observable/#como-aplicar-el-principio","title":"\u00bfC\u00f3mo aplicar el principio?","text":"<p>El principio de Highly Observable en microservicios implica que debemos dise\u00f1ar nuestros sistemas para que sean altamente observables, es decir, capaces de proporcionar informaci\u00f3n clara y detallada sobre su estado interno y externo en tiempo real. En Kubernetes, podemos aplicar este principio siguiendo algunas recomendaciones:</p> <ol> <li> <p>Configurar m\u00e9tricas y monitoreo: Kubernetes proporciona herramientas integradas de monitoreo como Prometheus y Grafana, que pueden ser utilizadas para configurar m\u00e9tricas y monitoreo en tiempo real de los diferentes componentes de nuestro sistema.</p> </li> <li> <p>Logs estructurados: Es importante que los logs generados por nuestros contenedores sean estructurados y f\u00e1ciles de entender. Para esto, podemos utilizar herramientas como Fluentd o Elasticsearch para recolectar y analizar logs en tiempo real.</p> </li> <li> <p>Tracing distribuido: Kubernetes tambi\u00e9n ofrece herramientas de tracing distribuido, como Jaeger, que permiten realizar un seguimiento detallado de las transacciones entre los diferentes componentes del sistema.</p> </li> <li> <p>Pruebas y automatizaci\u00f3n: Es importante realizar pruebas automatizadas de nuestro sistema para garantizar su correcto funcionamiento y detectar cualquier problema o falla de manera temprana. Podemos utilizar herramientas como Testinfra para automatizar las pruebas y desplegarlas en entornos de preproducci\u00f3n y producci\u00f3n.</p> </li> </ol> <p>En resumen, para aplicar el principio de Highly Observable con Kubernetes, debemos configurar m\u00e9tricas y monitoreo, utilizar logs estructurados, implementar tracing distribuido y realizar pruebas y automatizaci\u00f3n de manera constante.</p>"},{"location":"microservice/highly_observable/#ejemplo","title":"Ejemplo","text":"<p><pre><code>sequenceDiagram\n  participant Client\n  participant Microservice\n  participant Tool\n  participant Servidor Traicing\n\n  Client -&gt;&gt; Microservice: Request\n  Microservice --&gt;&gt; Tool: Push trace\n  Tool --&gt;&gt; Servidor Traicing: Log event\n  Microservice -&gt;&gt; Client: Response</code></pre> Cuando el cliente env\u00eda una solicitud al microservicio, \u00e9ste utiliza una herramienta para enviar el registro de seguimiento a un servidor centralizado de eventos y registros de manera asincr\u00f3nica, evitando que se bloquee la respuesta del cliente.</p> <p>Existen muchas herramientas disponibles para el monitoreo de microservicios, algunas de las m\u00e1s populares incluyen:</p> <ul> <li> <p>Prometheus: una herramienta de monitoreo y alerta de c\u00f3digo abierto dise\u00f1ada para sistemas altamente din\u00e1micos como los microservicios.</p> </li> <li> <p>Grafana: una plataforma de an\u00e1lisis y monitoreo que proporciona paneles de visualizaci\u00f3n y alertas para los datos recopilados por herramientas como Prometheus.</p> </li> <li> <p>Jaeger: una plataforma de rastreo de transacciones distribuida que se utiliza para monitorear el rendimiento y la latencia de las solicitudes en microservicios.</p> </li> <li> <p>Zipkin: una herramienta de rastreo de solicitudes distribuida que se utiliza para monitorear el rendimiento de los microservicios.</p> </li> <li> <p>ELK Stack: una combinaci\u00f3n de tres herramientas, Elasticsearch, Logstash y Kibana, que se utilizan para la recopilaci\u00f3n, an\u00e1lisis y visualizaci\u00f3n de registros.</p> </li> <li> <p>Sysdig: una plataforma de monitoreo y seguridad de contenedores que se utiliza para monitorear la actividad del sistema, la red y la aplicaci\u00f3n en entornos de microservicios.</p> </li> <li> <p>AppDynamics: una plataforma de monitoreo y an\u00e1lisis de rendimiento de aplicaciones que se utiliza para monitorear el rendimiento de los microservicios.</p> </li> <li> <p>Dynatrace: una plataforma de inteligencia artificial de monitoreo de rendimiento de aplicaciones que se utiliza para monitorear los microservicios y proporcionar una vista completa del entorno de la aplicaci\u00f3n.</p> </li> </ul> <p>Cada una de estas herramientas tiene sus propias fortalezas y debilidades, y la elecci\u00f3n de una herramienta depender\u00e1 de las necesidades espec\u00edficas de monitoreo de los microservicios en cuesti\u00f3n.</p>"},{"location":"microservice/highly_observable/#consecuencia","title":"Consecuencia","text":"<ol> <li> <p>Dificultad para detectar y solucionar problemas: Al no tener una visibilidad completa de lo que est\u00e1 sucediendo en los diferentes microservicios, es m\u00e1s dif\u00edcil detectar problemas y errores. Esto puede llevar a que los problemas no se solucionen de manera oportuna, lo que puede causar interrupciones en el servicio y la insatisfacci\u00f3n de los clientes.</p> </li> <li> <p>Falta de control sobre el rendimiento: Si no se pueden monitorear y medir los indicadores clave de rendimiento (KPI) en los diferentes microservicios, no se puede tener un control efectivo sobre el rendimiento del sistema. Esto puede llevar a una disminuci\u00f3n en la calidad del servicio y la p\u00e9rdida de clientes.</p> </li> <li> <p>Dificultad para cumplir con los acuerdos de nivel de servicio (SLA): Al no tener una visibilidad completa del rendimiento del sistema, es m\u00e1s dif\u00edcil cumplir con los acuerdos de nivel de servicio. Esto puede llevar a multas, penalizaciones y a la p\u00e9rdida de contratos.</p> </li> <li> <p>Mayor tiempo de resoluci\u00f3n de problemas: La falta de observabilidad puede llevar a que se necesite m\u00e1s tiempo para solucionar los problemas, ya que puede ser necesario recopilar y analizar manualmente los datos de varios microservicios. Esto puede aumentar el tiempo de resoluci\u00f3n de problemas y afectar negativamente la experiencia del usuario.</p> </li> </ol>"},{"location":"microservice/isolate_failure/","title":"Isolate Failure","text":"<p>Este principio sugiere que los microservicios deben estar dise\u00f1ados de tal manera que los fallos se a\u00edslen lo m\u00e1s posible, es decir, que los fallos no se propaguen a otros microservicios o componentes del sistema.</p> <p>Esto significa que, en lugar de tener un solo monolito o servicio que maneje todo el flujo de trabajo, el sistema debe dividirse en microservicios individuales, cada uno con su propia responsabilidad espec\u00edfica. Cada microservicio debe tener un l\u00edmite claro en cuanto a sus responsabilidades y funciones, lo que hace que sea m\u00e1s f\u00e1cil identificar y resolver problemas.</p> <p>Al seguir este principio, se logra que los fallos est\u00e9n contenidos dentro de un solo microservicio, sin afectar a otros componentes del sistema, lo que facilita la identificaci\u00f3n y soluci\u00f3n de problemas. Adem\u00e1s, el aislamiento de fallos tambi\u00e9n ayuda a mejorar la escalabilidad del sistema, ya que se pueden agregar o quitar microservicios seg\u00fan sea necesario sin afectar el funcionamiento de otros componentes.</p> <p>En resumen, el principio \"Isolate Failure\" sugiere que los microservicios deben dise\u00f1arse para limitar los efectos de los fallos, de modo que no afecten a otros componentes del sistema. Esto se logra a trav\u00e9s de la creaci\u00f3n de microservicios individuales y la asignaci\u00f3n de responsabilidades espec\u00edficas a cada uno de ellos.</p>"},{"location":"microservice/isolate_failure/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Dividir la funcionalidad en microservicios: Cada microservicio debe tener una responsabilidad espec\u00edfica y claramente definida para evitar que los fallos se propaguen a otros componentes del sistema.</p> </li> <li> <p>Establecer l\u00edmites claros de responsabilidad: Es importante que cada microservicio tenga un l\u00edmite claro en cuanto a sus responsabilidades y funciones, para evitar que los fallos se propaguen a otros componentes del sistema.</p> </li> <li> <p>Implementar mecanismos de recuperaci\u00f3n de fallos: Los microservicios deben tener mecanismos de recuperaci\u00f3n de fallos, como reintentos y mecanismos de respaldo, para minimizar el impacto de los fallos.</p> </li> <li> <p>Monitorizar y registrar los errores: Es importante monitorizar y registrar los errores que se produzcan en cada microservicio, para poder identificar y solucionar los problemas de manera efectiva.</p> </li> <li> <p>Dise\u00f1ar para la resiliencia: Los microservicios deben dise\u00f1arse para ser resistentes a los fallos, y deben ser capaces de recuperarse r\u00e1pidamente de ellos.</p> </li> <li> <p>Definir y aplicar pol\u00edticas de tolerancia a fallos: Es importante definir pol\u00edticas de tolerancia a fallos, que establezcan c\u00f3mo se manejar\u00e1n los fallos en cada microservicio.</p> </li> <li> <p>Establecer l\u00edmites de tiempo y recursos: Es importante establecer l\u00edmites de tiempo y recursos para cada microservicio, para evitar que los fallos se propaguen a otros componentes del sistema.</p> </li> <li> <p>Pruebas de fallos: Es importante realizar pruebas de fallos en cada microservicio para asegurar que est\u00e9n dise\u00f1ados para contener los errores.</p> </li> </ol> <p>Al seguir estas recomendaciones, se puede dise\u00f1ar y desarrollar microservicios que est\u00e9n dise\u00f1ados para aislar los fallos y minimizar su impacto en el sistema en su conjunto.</p>"},{"location":"microservice/isolate_failure/#ejemplo","title":"Ejemplo","text":"<pre><code>sequenceDiagram\n    participant Cliente\n    participant API\n    participant Microservicio1\n    participant Microservicio2\n    Cliente-&gt;&gt;API: Realiza una solicitud\n    API-&gt;&gt;Microservicio1: Realiza una solicitud\n    Microservicio1-&gt;&gt;Microservicio2: Realiza una solicitud\n    Microservicio2--&gt;&gt;Microservicio1: Devuelve una respuesta\n    Microservicio1--&gt;&gt;API: Devuelve una respuesta\n    API--&gt;&gt;Cliente: Devuelve una respuesta\n    alt Si Microservicio1 falla\n        Microservicio1--&gt;&gt;Microservicio2: Cancela la solicitud\n        Microservicio1--&gt;&gt;API: Informa del error\n        API--&gt;&gt;Cliente: Informa del error\n    end\n</code></pre> <p>Este diagrama de secuencia que muestra la interacci\u00f3n entre el cliente, la API y dos microservicios. Tambi\u00e9n incluye un bloque \"alt\" que muestra c\u00f3mo se puede aplicar el principio de Isolate Failure si uno de los microservicios falla.</p>"},{"location":"microservice/isolate_failure/#consecuencias","title":"Consecuencias","text":"<ol> <li> <p>Dificultad para identificar la causa ra\u00edz de un problema: Si los microservicios no est\u00e1n dise\u00f1ados para aislar las fallas, un problema en uno de ellos podr\u00eda afectar a otros. En esta situaci\u00f3n, puede ser dif\u00edcil identificar el origen del problema y tomar medidas para solucionarlo.</p> </li> <li> <p>Fallos en cascada: Si un microservicio falla y no est\u00e1 aislado, puede provocar una falla en cadena que afecte a otros microservicios, lo que puede resultar en una interrupci\u00f3n de todo el sistema.</p> </li> <li> <p>Dificultad para escalar el sistema: Si los microservicios no est\u00e1n dise\u00f1ados para ser escalables y no pueden manejar fallos de manera aislada, puede ser dif\u00edcil agregar nuevas instancias de un servicio para manejar una mayor carga.</p> </li> <li> <p>Menor disponibilidad del servicio: La falta de aislamiento de las fallas puede provocar un aumento en el tiempo de inactividad del servicio, lo que puede tener un impacto negativo en la disponibilidad y la satisfacci\u00f3n del usuario.</p> </li> </ol>"},{"location":"microservice/modelled/","title":"Modelled Around Business Domain","text":"<p>El principio \"Modelado en torno al Dominio del Negocio\" (en ingl\u00e9s \"Modelled Around Business Domain\") es uno de los principios clave en la arquitectura de microservicios. El principio establece que los l\u00edmites de los microservicios deben definirse en torno a las necesidades del negocio, en lugar de basarse en factores t\u00e9cnicos como el almacenamiento de datos o el procesamiento de solicitudes.</p> <p>En otras palabras, el principio \"Modelado en torno al Dominio del Negocio\" implica que la arquitectura de microservicios debe dise\u00f1arse en torno a las entidades de negocio y los procesos empresariales, en lugar de estar dise\u00f1ada en funci\u00f3n de las capas de tecnolog\u00eda, como la base de datos o la capa de presentaci\u00f3n.</p> <p>El objetivo de este principio es permitir que los equipos de desarrollo se centren en las necesidades del negocio y proporcionen soluciones de software m\u00e1s eficientes y flexibles que se adapten a los requisitos empresariales en constante cambio.</p> <p>Al dise\u00f1ar microservicios de acuerdo con el principio \"Modelado en torno al Dominio del Negocio\", los equipos de desarrollo pueden identificar y definir los l\u00edmites del servicio de manera m\u00e1s clara y precisa. Esto a su vez facilita la comprensi\u00f3n del sistema por parte de los usuarios finales y reduce la complejidad y la dependencia de los sistemas subyacentes.</p>"},{"location":"microservice/modelled/#recomendaciones","title":"Recomendaciones","text":"<ol> <li> <p>Identifique los dominios de su negocio: Antes de comenzar a modelar, es importante comprender los diferentes dominios de su negocio. Esto ayudar\u00e1 a identificar los l\u00edmites de su modelo y a mantenerlo enfocado en los aspectos importantes.</p> </li> <li> <p>Dise\u00f1e los modelos en torno a los dominios del negocio: Una vez que se han identificado los dominios de su negocio, dise\u00f1e sus modelos en torno a ellos. Cada dominio debe tener su propio modelo que refleje las necesidades y requisitos espec\u00edficos de ese dominio.</p> </li> <li> <p>Use un lenguaje com\u00fan: Para que todos en su equipo entiendan el modelo de negocio, es importante utilizar un lenguaje com\u00fan. Aseg\u00farese de que todas las personas involucradas en el desarrollo del modelo de negocio est\u00e9n familiarizadas con los t\u00e9rminos y conceptos clave.</p> </li> <li> <p>Mantenga la simplicidad: No intente modelar cada aspecto del negocio en un solo modelo. En su lugar, mant\u00e9ngase enfocado en los aspectos m\u00e1s importantes y aseg\u00farese de que cada modelo sea simple y f\u00e1cil de entender.</p> </li> <li> <p>Alinee el modelo con los procesos de negocio: Aseg\u00farese de que su modelo est\u00e9 alineado con los procesos de negocio existentes. Esto har\u00e1 que sea m\u00e1s f\u00e1cil para las personas en su organizaci\u00f3n entender c\u00f3mo se relaciona el modelo con el negocio real.</p> </li> <li> <p>Mantenga el modelo actualizado: A medida que su negocio evoluciona, su modelo tambi\u00e9n debe evolucionar. Aseg\u00farese de mantener su modelo actualizado para reflejar los cambios en el negocio.</p> </li> <li> <p>Pruebe su modelo: Antes de implementar su modelo, aseg\u00farese de probarlo exhaustivamente. Esto ayudar\u00e1 a identificar cualquier problema y asegurar\u00e1 que el modelo funcione como se espera.</p> </li> <li> <p>Utilice herramientas de modelado de dominio: Existen herramientas de modelado de dominio disponibles que pueden ayudarlo a dise\u00f1ar y mantener sus modelos de negocio. Estas herramientas pueden facilitar el proceso de modelado y ayudarlo a mantener sus modelos actualizados.</p> </li> </ol>"},{"location":"microservice/modelled/#ejemplo","title":"Ejemplo","text":"<p>Supongamos que estamos creando una aplicaci\u00f3n de comercio electr\u00f3nico que consiste en varios microservicios, como el servicio de carrito de compras, el servicio de inventario, el servicio de pagos y el servicio de env\u00edo. En lugar de dise\u00f1ar estos microservicios seg\u00fan los componentes t\u00e9cnicos de la aplicaci\u00f3n, debemos dise\u00f1arlos en torno a los conceptos de negocio subyacentes de la aplicaci\u00f3n, como \"pedido\", \"producto\" y \"cliente\".</p> <p>Entonces, en lugar de tener un microservicio de \"base de datos de pedidos\" y un microservicio de \"base de datos de productos\", tendr\u00edamos un microservicio de \"gesti\u00f3n de pedidos\" y un microservicio de \"gesti\u00f3n de productos\". Cada microservicio se enfocar\u00eda en la l\u00f3gica de negocio espec\u00edfica de esa \u00e1rea, y la comunicaci\u00f3n entre ellos se realizar\u00eda a trav\u00e9s de interfaces claramente definidas que reflejen el lenguaje y los conceptos de negocio de la aplicaci\u00f3n.</p> <p>Esto puede hacer que el dise\u00f1o de microservicios sea m\u00e1s f\u00e1cil de entender y mantener a lo largo del tiempo, y tambi\u00e9n puede ayudar a alinear mejor la arquitectura de la aplicaci\u00f3n con las necesidades del negocio subyacente.</p>"},{"location":"microservice/modelled/#consecuencias","title":"Consecuencias","text":"<ol> <li> <p>Dificultad para entender el dominio del negocio: si los microservicios no est\u00e1n dise\u00f1ados en torno a las necesidades y conceptos del negocio, se corre el riesgo de que los equipos de desarrollo no comprendan completamente las necesidades de los usuarios y no puedan proporcionar soluciones adecuadas.</p> </li> <li> <p>Dificultad para mantener los servicios: si los servicios no est\u00e1n modelados alrededor del negocio, es posible que se hagan cambios que no est\u00e9n alineados con el dominio del negocio, lo que puede hacer que los servicios sean dif\u00edciles de mantener y actualizar.</p> </li> <li> <p>Dificultad para escalar: si los microservicios no est\u00e1n dise\u00f1ados en torno a las necesidades del negocio, puede ser dif\u00edcil escalarlos correctamente para manejar una carga de trabajo creciente. Esto puede llevar a cuellos de botella y a una disminuci\u00f3n en la eficiencia y la eficacia del sistema.</p> </li> <li> <p>Falta de flexibilidad: si los microservicios no est\u00e1n dise\u00f1ados para ser flexibles y adaptables a los cambios en el negocio, pueden requerir cambios significativos en el futuro que pueden ser costosos y dif\u00edciles de implementar.</p> </li> </ol>"},{"location":"microservice/workshop/","title":"Taller/Practica","text":"<p>Bienvenido al taller individual sobre los principios de microservicios de Sam Newman. A continuaci\u00f3n, te presentar\u00e9 algunas actividades que puedes realizar para profundizar en estos principios y aplicarlos en tu trabajo diario.</p>"},{"location":"microservice/workshop/#actividad-1-revisa-los-principios-de-microservicios-de-sam-newman","title":"Actividad 1: Revisa los principios de microservicios de Sam Newman","text":"<p>Antes de comenzar con las actividades pr\u00e1cticas, es importante que revises los principios de microservicios de Sam Newman. Puedes leer su libro \"Building Microservices\" o revisar sus presentaciones en l\u00ednea para tener una comprensi\u00f3n s\u00f3lida de los principios.</p>"},{"location":"microservice/workshop/#actividad-2-identifica-un-sistema-de-software-existente-y-analiza-su-arquitectura","title":"Actividad 2: Identifica un sistema de software existente y analiza su arquitectura","text":"<p>Selecciona un sistema de software existente y analiza su arquitectura. Identifica qu\u00e9 componentes del sistema son monol\u00edticos y cu\u00e1les podr\u00edan separarse en microservicios. Analiza c\u00f3mo se comunican los componentes del sistema y c\u00f3mo se pueden refactorizar para implementar los principios de microservicios.</p>"},{"location":"microservice/workshop/#actividad-3-aplica-el-principio-de-modelled-around-business-domain","title":"Actividad 3: Aplica el principio de \"Modelled Around Business Domain\"","text":"<p>Identifica el dominio de negocio de tu aplicaci\u00f3n y crea microservicios que se centren en cada uno de los aspectos del dominio. Cada microservicio debe tener su propio modelo de datos y l\u00f3gica de negocio. Realiza pruebas de integraci\u00f3n para asegurarte de que los microservicios se comuniquen de manera efectiva y satisfagan los requisitos del negocio.</p>"},{"location":"microservice/workshop/#actividad-4-implementa-el-principio-de-deploy-independently","title":"Actividad 4: Implementa el principio de \"Deploy Independently\"","text":"<p>Implementa un proceso de implementaci\u00f3n continuo para cada microservicio y aseg\u00farate de que los microservicios se puedan implementar de manera independiente. Crea una infraestructura de orquestaci\u00f3n de contenedores que permita la implementaci\u00f3n y actualizaci\u00f3n de cada microservicio de forma individual.</p>"},{"location":"microservice/workshop/#actividad-5-practica-el-principio-de-highly-observable","title":"Actividad 5: Practica el principio de \"Highly Observable\"","text":"<p>Implementa un sistema de registro centralizado y monitoreo para todos los microservicios. Utiliza herramientas como Prometheus y Grafana para monitorear los microservicios y detectar problemas en tiempo real. Tambi\u00e9n puedes implementar alertas autom\u00e1ticas para informar a los equipos de operaciones de cualquier problema.</p>"},{"location":"microservice/workshop/#actividad-6-aplica-el-principio-de-culture-of-automation","title":"Actividad 6: Aplica el principio de \"Culture of Automation\"","text":"<p>Fomenta una cultura de automatizaci\u00f3n dentro de tu equipo de desarrollo y operaciones. Utiliza herramientas de automatizaci\u00f3n de infraestructura, como Ansible o Chef, para automatizar la creaci\u00f3n y configuraci\u00f3n de los entornos de desarrollo y producci\u00f3n. Tambi\u00e9n puedes implementar pruebas autom\u00e1ticas y una integraci\u00f3n continua para acelerar el proceso de implementaci\u00f3n.</p> <p>Espero que estas actividades te ayuden a comprender mejor los principios de microservicios de Sam Newman y c\u00f3mo implementarlos en tu trabajo diario. \u00a1Que tengas una experiencia enriquecedora!</p>"},{"location":"microservice/workshop/#preguntas-de-repaso","title":"Preguntas de repaso","text":"<ol> <li>\u00bfCu\u00e1l es el objetivo principal de los microservicios?</li> <li>\u00bfCu\u00e1les son los seis principios clave de los microservicios seg\u00fan Sam Newman?</li> <li>\u00bfEn qu\u00e9 consiste el principio \"Modelled Around Business Domain\"?</li> <li>\u00bfPor qu\u00e9 es importante el principio \"Culture of Automation\"?</li> <li>\u00bfEn qu\u00e9 consiste el principio \"Deploy Independently\"?</li> <li>\u00bfQu\u00e9 significa \"Consumer first\" y por qu\u00e9 es importante?</li> <li>\u00bfQu\u00e9 significa \"Hide Implementation Details\" y por qu\u00e9 es importante?</li> <li>\u00bfEn qu\u00e9 consiste el principio \"Isolate Failure\"?</li> <li>\u00bfPor qu\u00e9 es importante tener sistemas \"Highly Observable\"?</li> <li>\u00bfEn qu\u00e9 consiste el principio \"Decentralise All The Things\"?</li> </ol>"}]}